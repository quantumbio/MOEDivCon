#svl

// The purpose of this file is to centralize all qbWebService functions in one place so that 
//  changes in protocol and the like can be fixed and maintained in a single file. Over time, if this
//  becomes unweildy, we could move these functions.

// WS spec
const CRLF = "\r\n";
const POST_MT = "POST /qmechanic/movabletype STDIO\n\n";
const SHUTDOWN = "SHUTDOWN /qmechanic/movabletype STDIO\n\n";
const GET_STATUS = "GET /qmechanic/movabletype STDIO\n\n";

// Forward Declarations
function json_Create;
function json_Extract;
function qbWriteJSONStream;
function qbReadJSONStream;
function json_Read;

function url_Parse;

const DEFAULT_MTOPT = [
    hamiltonian :   'garf',
    pocket      :   8.0,
    nb_cutoff   :   11.0,
    mtscore     :   'endstate'
];

// Local Functions
local function boundaryGen[]
    const boundary_chars = "_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return sample [shuffle boundary_chars, 40];
endfunction

global function which executable
    local outline;

    if OS_UNIX then
	executable = twrite ['command -v {}', executable];
    elseif OS_MSWIN then
	executable = twrite ['where {}', executable];
    else
	print 'Invalid OS'; return;
    endif

    local [pkey, err] = task_call ['exe_open_shell', [executable,cd [],[],0], [errmsg:'ignore']];
    if err == '' then
        pkey = exe_open_shell[executable,cd [],[],0];
        local out_fno = exe_stdout pkey;
        local in_fno = exe_stdin pkey;
        if exe_status pkey then
            outline = cat freadb [out_fno, 'line', 1];
        endif
        exe_close pkey;
    endif
    return token outline;
endfunction

global function ssh_which [executable, hostname, username]
    local outline;
    local err = '';
    local pkey;
    local port = 22;    // NOTE: this is currently assuming port=22 (it would be nice to allow the user to set the port too)
    
    if isnull username then
        username = MOE_USER;
    endif
    
    executable = twrite ['{} {}@{} -p {} -o BatchMode=yes command -v {}',exe_cmd_str['ssh'], username, hostname, port, executable];   

    if ssh_host_ok [hostname, 0, [ssh_user:username]] <> 1 then
        err = 'SSH ERROR';
    endif
    
    if err == '' then
        [pkey, err] = task_call ['exe_open_shell', [executable,cd [],[],0], [errmsg:'ignore']];
    endif
    
    if err == '' then
        pkey = exe_open_shell[executable,cd [],[],0];
        local out_fno = exe_stdout pkey;
        local in_fno = exe_stdin pkey;
        if exe_status pkey then
            outline = cat freadb [out_fno, 'line', 1];
        endif
        exe_close pkey;
        outline = twrite ['ssh://{}@{}:{}/{}', username, hostname, port, outline];
    endif

    return token outline;
endfunction

local function getTargetChunk target_mol
    return cat [
        "Content-Disposition: form-data; name=\"Target\"", CRLF,
        "Content-Type: text/plain", CRLF,
        CRLF,
        string twrite ['{}',qbWriteJSONStream json_Extract target_mol], CRLF
    ];
endfunction

local function getLigandChunk [ligand_mol,name]
    if isnull name then
        name='Ligand';
    endif

    return cat [
//        swrite ["Content-Disposition: form-data; name=\"{}\"",string name], CRLF,
        swrite ['Content-Disposition: form-data; name=\"{}\"', name], CRLF,
        "Content-Type: text/plain", CRLF,
        CRLF,
        string twrite ['{}',qbWriteJSONStream json_Extract ligand_mol], CRLF    
    ];
endfunction

local function getWSDefaults [hostname, port, username, stdion, qmechanicexec, protocol]

    if isnull qmechanicexec then
        qmechanicexec = GetRC ['QuantumBio.qbExecutable','qmechanic'];
    endif

    if qmechanicexec == 'noopt' then
        hostname = 'localhost';
        stdion = 1;
        protocol = 'file';
    endif

    if isnull hostname then
        hostname = GetRC ['QuantumBio.qbWSHostname','localhost'];
    endif

    if isnull stdion then
        stdion = ( 'Executable' === GetRC ['QuantumBio.qbInterface','qbWebService'] );
    endif

    if stdion then
        if hostname === 'localhost' then
            protocol = 'file';
        else
            protocol = 'ssh';
        endif
    else
        protocol = 'http';
    endif

    if isnull port then
        if protocol === 'ssh' then
            port = GetRCNumber ['QuantumBio.qbSSHPort',22];
        elseif protocol === 'http' or protocol === 'https' then
            port = GetRCNumber ['QuantumBio.qbWSPort',8080];
        else
            port = 0;
        endif
    endif
        
    if isnull username then
        username = GetRC ['QuantumBio.qbWSUsername',getenv 'MOE_USER'];
    endif
    
    if isnull qmechanicexec then
        qmechanicexec = GetRC ['QuantumBio.qbExecutable','qmechanic'];
    endif

    return [hostname, port, username, stdion, qmechanicexec, protocol];
    
endfunction

global function parseURL url

    local [info, err] = url_Parse url;
    local hostname, port, username, stdion, qmechanicexec, protocol;
    
    if err == '' then
        protocol = info.scheme;
        if protocol === 'ssh' or protocol === 'file' then stdion = 1; else stdion = 0; endif
        [username, hostname] = app token fieldsplit [string info.host, "@"];
        if isnull hostname then
            hostname = username;
            username = null[];
        endif
        port = info.port;
        qmechanicexec = info.path;
    else
        return [hostname, port, username, stdion, qmechanicexec, protocol];
    endif
    
    if not isnull qmechanicexec then
        if "/" == first string cat qmechanicexec then qmechanicexec = token dropfirst string qmechanicexec;  endif
    endif
        
    return [hostname, port, username, stdion, qmechanicexec, protocol];
        
endfunction

global function getWSHostNPort [hostname, port, username, stdion, qmechanicexec, protocol]
    [hostname, port, username, stdion, qmechanicexec, protocol] = getWSDefaults [hostname, port, username, stdion, qmechanicexec, protocol];
    
    if stdion then
        qmechanicexec = twrite ['/{}', qmechanicexec];
    else
        username = null[];
        qmechanicexec = null[];
    endif
    
    local function trusername inusername
        if not isnull inusername then
            return twrite ['{}@', inusername];
        else
            return inusername;
        endif
    endfunction
    
    return twrite ['{}://{}{}:{}{}', protocol, trusername username, hostname, port, qmechanicexec];
endfunction

// Global Functions

local function read_stderr [ekey, ctx]
    local stderr = exe_stderr ekey;
    while fwaitr stderr loop
    until not length freadb [stderr, 'char', 1] endloop
endfunction

global function qbWSTestEndpoint url
    static prevURL;
    static prevTime;
    static curl_out;
    static err;

    if isnull url then
        url = getWSHostNPort[];
    endif
    
    local [hostname, port, username, stdion, qmechanicexec, protocol] = parseURL url;
    
    local timeout;
    if protocol === 'http' or protocol === "https" then
        timeout = 5;        // to cut down chatter, for http/https limit checks to once every 5 seconds or when the URL changes or some error has occured (to allow more shots on goal)
    else
        timeout = 120;      // to cut down chatter, for executables limit checks to once every 120 seconds or when the URL changes or some error has occured (to allow more shots on goal)
    endif


    if not isnull prevTime and not isnull prevURL then 
        if timeout > (clock[] - prevTime) and url === prevURL and err === '' then 
            return qbReadJSONStream curl_out;
        endif
    endif
    
    prevURL = url;
    prevTime = clock[];
    
    curl_out = "";
    err = '';
    
    if qmechanicexec === 'noopt' then
        write ['SUCCESSFUL NOOPT\n'];
        return qbReadJSONStream qbWriteJSONStream [status:'success'];
    endif
    
    if protocol === 'http' or protocol === 'https' then
        local curlkey = curl_open [url: tok_cat [url, twrite ['/qmechanic/']]];
        [curl_out, err] = task_call [ 'curl_read',  curlkey, [errmsg:'ignore'] ];
        if err <> '' then
            err = twrite ['Unable to reach webservice: {}', tok_cat [url, twrite ['/qmechanic/']]];
        endif
        curl_close curlkey;
    elseif protocol === 'file' or protocol === 'ssh' then
        local qme_command;
        local pkey;
        if protocol === 'file' then
            if not OS_MSWIN then
                local tmpExec = which qmechanicexec;
                if tmpExec <> '' then qmechanicexec = tmpExec; endif
                qme_command = twrite ['{} {} --stdio 10 -v 1 --np 2 -O', exe_cmd_str['sh'], qmechanicexec];
                local file_info = fstat qmechanicexec;
                if isnull tmpExec or not exe_cmd_ok ['sh',exe_cmd_str['sh']] or file_info(1) <> 'file' or not bitand [file_info(3), 0x04] then
                    err = twrite ['Unable to execute {}',qme_command];
                endif
            else
                err = 'Microsoft Windows is not supported for local execution of qmechanic';
            endif
        else
            qme_command = twrite ['{} {}@{} -p {} -o BatchMode=yes {} --stdio -v 0 --np 2 -O', exe_cmd_str['ssh'], username, hostname, port, qmechanicexec];
            if ssh_host_ok [hostname, 0, [ssh_user:username]] <> 1 then
                err = twrite ['Unable to contact ssh://{}@{}:{} using passwordless ssh:\n    please contact your administrator', username, hostname, port];
            endif
        endif

        if err == '' then
            [pkey, err] = task_call ['exe_open_shell', [qme_command,cd [],[],0], [errmsg:'ignore']];
        endif
        
        if err == '' then
            pkey = exe_open_shell[qme_command,cd [],[],0];
            local out_fno = exe_stdout pkey;
            local err_fno = exe_stderr pkey;
            local in_fno = exe_stdin pkey;
            local outline = "";
            local exec_error = '';
            local boundary = "--";
            local boundCount = 0;
            if exe_status pkey then
                    fwriteb [in_fno, 'char', swrite ['{}\n',GET_STATUS]];            
                    while exe_status pkey loop
                        outline = cat freadb [out_fno, 'line', 1];
                        if strpos [boundary, outline] and boundCount == 1 then
        //                        write ['1 | {}\n', outline];
                            boundCount = 0;
                            break;
                        elseif strpos [boundary, outline] then
        //                        write ['2 | {}\n', outline];
                            boundCount = 1;
                        elseif boundCount == 1 then
        //                        write ['3 | {}\n', outline];
                            curl_out = cat [curl_out, outline];
                        else
//                            write ['X | {}\n', outline];
                        endif
                    endloop
            endif
            if exe_status pkey then task_call ['fwriteb', [in_fno, 'char', swrite ['{}\n',SHUTDOWN]], [errmsg:'ignore']]; endif // try to SHUTDOWN qmechanic, but it has a timeout and will die in a few seconds anyway
            exe_close pkey;
        
            if isnull qbReadJSONStream curl_out then
                err = twrite ['{}\n    (verify ssh username, hostname, port, path to qmechanic, and version)',qme_command];
            else
                err = '';
            endif
        endif
    endif

    if err === '' then
    else
        write ['ERROR: {}\n', err];
        curl_out = '';
    endif
    
    return qbReadJSONStream curl_out;

endfunction

// Function to call the MTScore webservice
global function qbWS_MTScore [target_mol, ligand_mol, hostname, port, username, stdion, qmechanicexec]
    local protocol;
    [hostname, port, username, stdion, qmechanicexec, protocol] = getWSDefaults [hostname, port, username, stdion, qmechanicexec];
    local url = getWSHostNPort [hostname, port, username, stdion, qmechanicexec];

    local tmpJSON;
    local err;
    
    if not length qbWSTestEndpoint url then
        write ['ERROR: Failed connection to {}\n', url];
        tmpJSON.success = 0;
        return tmpJSON;
    endif
    
    local boundary = boundaryGen[];
    local ctype = cat ["multipart/form-data; boundary=", boundary];
    boundary = cat ["--", boundary]; // add two dashes by the standards
        
    local Instructions = cat [
        "Content-Disposition: form-data; name=\"Instructions\"", CRLF,
        "Content-Type: text/plain", CRLF,
        CRLF,
        qbWriteJSONStream DEFAULT_MTOPT, CRLF
    ];

    local POST_CONTENT = cat [
        boundary, CRLF,
        Instructions,
        boundary, CRLF,
        getTargetChunk target_mol,
        boundary, CRLF,
        getLigandChunk [ligand_mol],
        boundary, "--", CRLF    
    ];

#if 1
    fwrite ['debug-WSPOST.json', '{}{}{}{}\n',droplast droplast POST_MT,CRLF,CRLF,POST_CONTENT];
#endif

    write ['Sending data in debug-WSPOST.json via {}\n', getWSHostNPort[hostname, port, username, stdion, qmechanicexec]];
    if stdion then
        local qme_command;
        if protocol === 'file' then
            if not OS_MSWIN then
                local tmpExec = which qmechanicexec;
                if tmpExec <> '' then qmechanicexec = tmpExec; endif
                qme_command = twrite ['{} {} --stdio -v 0 --np 2 -O',exe_cmd_str['sh'], qmechanicexec];
                local file_info = fstat qmechanicexec;
                if isnull tmpExec or not exe_cmd_ok ['sh',exe_cmd_str['sh']] or file_info(1) <> 'file' or not bitand [file_info(3), 0x04] then
                    err = twrite ['Unable to execute {}',qme_command];
                endif
            else
                err = 'Microsoft Windows is not supported for local execution of qmechanic';
            endif
        else
            if OS_MSWIN then
                // When fwaitr is used on Windows, it doesn't return data.
//                write ['Note: only blocking I/O is supported by MOE on Windows.\n  Use qbWebService instead of Executable if you wish to run calculation without blocking.\n'];
            endif
            qme_command = twrite ['{} {}@{} -p {} -C -o BatchMode=yes {} --stdio 30 -v 0 --np 2 -O', exe_cmd_str['ssh'], username, hostname, port, qmechanicexec];
        endif
        write ['Running: {}\n',qme_command];
        local pkey;
        [pkey, err] = task_call ['exe_open_shell', [qme_command,cd [],[],0], [errmsg:'ignore']];
        if err == '' then
            pkey = exe_open_shell[qme_command,cd [],[],0];
            local out_fno = exe_stdout pkey;
            local in_fno = exe_stdin pkey;
        
            if exe_status pkey then
                fwriteb [in_fno, 'char', swrite ['{}{}',POST_MT,POST_CONTENT]];            
                fflush in_fno;                
                local outline;
                local boundCount = 0;
                while exe_status pkey loop
                    if not OS_MSWIN then
//                        fwaitr out_fno;       // TODO: fwaitr doesn't seem to work on Windows or Mac. This may take some more experimentation.
                    endif
                    outline = cat freadb [out_fno, 'line', 1];
//                    write ['{} | {} | {} \n', length outline, length boundary, boundCount];
                    if strpos [boundary, outline] and boundCount == 1 then
//                        write ['1 | {}\n', outline];
                        boundCount = 0;
                        break;
                    elseif strpos [boundary, outline] then
//                        write ['2 | {}\n', outline];
                        boundCount = 1;
                    elseif boundCount == 1 then
//                        write ['3 | {}\n', outline];
                        tmpJSON = cat [tmpJSON, outline];
                    else
//                        write ['X | {}\n', outline];
                    endif
                endloop
            endif

            if exe_status pkey then task_call ['fwriteb', [in_fno, 'char', swrite ['{}\n',SHUTDOWN]], [errmsg:'ignore']]; endif // try to SHUTDOWN qmechanic, but it has a timeout and will die in a few seconds anyway
            exe_close pkey;
        
            if isnull qbReadJSONStream tmpJSON then
                err = 'qmechanic returned a problem - please see qmechanic.qb.log for more information and contact support@quantumbioinc.com';
            else
                err = '';
            endif
        else
            err = twrite ['{} ({})', err, pkey];
        endif
    else
        local urlHandle = curl_open [
            url: tok_cat [getWSHostNPort[hostname, port], '/qmechanic/movabletype'],
            httpheader: [ 'Transfer-Encoding: Chunked', 
                     'TargetName: target.json',
                     'LigandName: ligand.json']
                     // 'PosesName: poses.json'
        ]; 

        curl_write  [urlHandle, POST_CONTENT];

        [tmpJSON, err] = task_call [ 'curl_read',  urlHandle, [errmsg:'ignore'] ];
        curl_close urlHandle;
    endif

#if 1
        fwrite ['debug-WSRETURN.txt','{}',tmpJSON];
#endif

    tmpJSON = qbReadJSONStream tmpJSON;
    if err === '' and not isnull tmpJSON then
        write ['Complete: {}\n', tmpJSON];
        tmpJSON.success = 1;
    else
        write ['ERROR: {}\n', err];
        tmpJSON.success = 0;
    endif

    // Return the JSON tagged vector to be used by other functions
//    return qbReadJSONStream tmpJSON;
    return tmpJSON;
endfunction

// add env var

const DEFAULT_OPT = [
    hamiltonian :   'garf',
    pocket      :   8.0,
    nb_cutoff   :   11.0,
    mtscore     :   'ensemble',
    mtcs    : [ 
        opt  : [
            algorithm      : 'torsion',
            gnorm          : 0.01,
            maxOptCycles   : 100,
            species        : 'novel'
            ]
            ],
    mtdock  : [ 
        opt  : [
            algorithm      : 'torsion',
            gnorm          : 0.01,
            maxOptCycles   : 100,
            species        : 'novel'
            ]
            ]
];

local function recursiveTagCat [inopt,defopt]
    local tmpTag;
    for tmpTag in tags inopt loop
        if isflat inopt.(tmpTag) then
            defopt.(tmpTag) = inopt.(tmpTag);
        else
            defopt.(tmpTag) = recursiveTagCat [inopt.(tmpTag),defopt.(tmpTag)];
        endif
    endloop
    return defopt;
endfunction

global function qbWS_JSON_TEST opt
//    local retOpt = nestedTagCat [opt, DEFAULT_OPT];
//    opt = tagcat [opt, DEFAULT_OPT];
//    local function recursiveTagCat [inopt,defopt]
//        local tmpTag;
//        for tmpTag in tags inopt loop
//            write ['tmpTag: {}\n',tmpTag];
//            if isflat inopt.(tmpTag) then
//                defopt.(tmpTag) = inopt.(tmpTag);
//            else
//                defopt.(tmpTag) = recursiveTagCat [inopt.(tmpTag),defopt.(tmpTag)];
//            endif
//        endloop
//        return defopt;
//    endfunction
    
    write ['{}\n',qbWriteJSONStream recursiveTagCat[opt,DEFAULT_OPT]];
//    return qbWriteJSONStream recursiveTagCat[opt,DEFAULT_OPT];
endfunction
    
global function qbWS_MTScoreE [target_mol, ligand_mol, pose_mols, opt, hostname, port, username, stdion, qmechanicexec, protocol]
    opt = recursiveTagCat [opt, DEFAULT_OPT];
    [hostname, port, username, stdion, qmechanicexec, protocol] = getWSDefaults [hostname, port, username, stdion, qmechanicexec, protocol];
    local url = getWSHostNPort [hostname, port, username, stdion, qmechanicexec, protocol];

    local tmpJSON;
    local err;
    
    if not length qbWSTestEndpoint url then
        write ['ERROR: Failed connection to {}\n', url];
        tmpJSON.success = 0;
        return tmpJSON;
    endif
    
    local boundary = boundaryGen[];
    local ctype = cat ["multipart/form-data; boundary=", boundary];
    boundary = cat ["--", boundary]; // add two dashes by the standards
        
    local Instructions = cat [
        "Content-Disposition: form-data; name=\"Instructions\"", CRLF,
        "Content-Type: text/plain", CRLF,
        CRLF,
//        "{ \"options\": {\"mtscore\": \"endstate\"}}"
        qbWriteJSONStream opt
        , CRLF
    ];
    
    write ['process ligs: {}\n', length pose_mols];
    
    local poseChunks;
    local pdata;
//    pdata = SystemPush [];
    local pocketLigandChunk = getLigandChunk [ligand_mol,'Ligand'];
//    SystemPop pdata; 
//    pdata = SystemPush [];
    local novelLigandChunk = getLigandChunk [ligand_mol,'Novel'];
//    SystemPop pdata; 
    local i = 1;
    while i <= length pose_mols loop
        pdata = SystemPush [];
        write ['{}\n',i];
        poseChunks = append [poseChunks, cat [
        boundary, CRLF,
        getLigandChunk [mol_Create pose_mols(i),'Pose']
        ]];
        i = i + 1;
        SystemPop pdata;        
    endloop
    write ['process ligs: {} | {} \n', length poseChunks,  type poseChunks];
    write ['{}\n', length poseChunks];
    poseChunks = swrite ['{}', poseChunks];
    
//    poseChunks = append [poseChunks, getLigandChunk ligand_mol();
    
    local POST_CONTENT = cat [
        boundary, CRLF,
        Instructions,
        boundary, CRLF,
        getTargetChunk target_mol,
        boundary, CRLF,
        pocketLigandChunk,
        boundary, CRLF,
        novelLigandChunk,
//        getLigandChunk [firstLigandMol,'Ligand'],
        poseChunks,
        boundary, "--", CRLF    
    ];

#if 1
    fwrite ['debug-WSPOST.json', '{}{}{}{}\n',droplast droplast POST_MT,CRLF,CRLF,POST_CONTENT];
#endif

    if qmechanicexec === 'noopt' then
        write ['Complete: {}\n', 'SEE debug-WSPOST.json for INPUT'];
        tmpJSON.success = 1;
        return tmpJSON;
    endif
    
    write ['Sending data in debug-WSPOST.json via {}\n', getWSHostNPort[hostname, port, username, stdion, qmechanicexec]];
    if stdion then
        local qme_command;
        if protocol === 'file' then
            if not OS_MSWIN then
                local tmpExec = which qmechanicexec;
                if tmpExec <> '' then qmechanicexec = tmpExec; endif
                qme_command = twrite ['{} {} --stdio -v 0 --np 2 -O',exe_cmd_str['sh'], qmechanicexec];
                local file_info = fstat qmechanicexec;
                if isnull tmpExec or not exe_cmd_ok ['sh',exe_cmd_str['sh']] or file_info(1) <> 'file' or not bitand [file_info(3), 0x04] then
                    err = twrite ['Unable to execute {}',qme_command];
                endif
            else
                err = 'Microsoft Windows is not supported for local execution of qmechanic';
            endif
        else
            if OS_MSWIN then
                // When fwaitr is used on Windows, it doesn't return data.
//                write ['Note: only blocking I/O is supported by MOE on Windows.\n  Use qbWebService instead of Executable if you wish to run calculation without blocking.\n'];
            endif
            qme_command = twrite ['{} {}@{} -p {} -C -o BatchMode=yes {} --stdio 30 -v 0 --np 2 -O', exe_cmd_str['ssh'], username, hostname, port, qmechanicexec];
        endif
        write ['Running: {}\n',qme_command];
        local pkey;
        [pkey, err] = task_call ['exe_open_shell', [qme_command,cd [],[],0], [errmsg:'ignore']];
        if err == '' then
            pkey = exe_open_shell[qme_command,cd [],[],0];
            local out_fno = exe_stdout pkey;
            local in_fno = exe_stdin pkey;
            
            if exe_status pkey then
                fwriteb [in_fno, 'char', swrite ['{}{}',POST_MT,POST_CONTENT]];            
                fflush in_fno;                
                local outline;
                local boundCount = 0;
                while exe_status pkey loop
                    if not OS_MSWIN then
//                        fwaitr out_fno;       // TODO: fwaitr doesn't seem to work on Windows or Mac. This may take some more experimentation.
                    endif
                    outline = cat freadb [out_fno, 'line', 1];
//                    write ['{} | {} | {} \n', length outline, length boundary, boundCount];
                    if strpos [boundary, outline] and boundCount == 1 then
//                        write ['1 | {}\n', outline];
                        boundCount = 0;
                        break;
                    elseif strpos [boundary, outline] then
//                        write ['2 | {}\n', outline];
                        boundCount = 1;
                    elseif boundCount == 1 then
//                        write ['3 | {}\n', outline];
                        tmpJSON = cat [tmpJSON, outline];
                    else
//                        write ['X | {}\n', outline];
                    endif
                endloop
            endif

            if exe_status pkey then task_call ['fwriteb', [in_fno, 'char', swrite ['{}\n',SHUTDOWN]], [errmsg:'ignore']]; endif // try to SHUTDOWN qmechanic, but it has a timeout and will die in a few seconds anyway
            exe_close pkey;
        
            if isnull qbReadJSONStream tmpJSON then
                err = 'qmechanic returned a problem - please see qmechanic.qb.log for more information and contact support@quantumbioinc.com';
            else
                err = '';
            endif
        else
            err = twrite ['{} ({})', err, pkey];
        endif
    else
        local urlHandle = curl_open [
            url: tok_cat [getWSHostNPort[hostname, port], '/qmechanic/movabletype'],
            httpheader: [ 'Transfer-Encoding: Chunked', 
                     'TargetName: target.json',
                     'LigandName: ligand.json']
                     // 'PosesName: poses.json'
        ]; 

        curl_write  [urlHandle, POST_CONTENT];

        [tmpJSON, err] = task_call [ 'curl_read',  urlHandle, [errmsg:'ignore'] ];
        curl_close urlHandle;
    endif

#if 1
        fwrite ['debug-WSRETURN.txt','{}',tmpJSON];
#endif

    tmpJSON = qbReadJSONStream tmpJSON;
    if err === '' and not isnull tmpJSON then
        write ['Complete: {}\n', tmpJSON];
        tmpJSON.success = 1;
    else
        write ['ERROR: {}\n', err];
        tmpJSON.success = 0;
    endif

    // Return the JSON tagged vector to be used by other functions
//    return qbReadJSONStream tmpJSON;
    return tmpJSON;
endfunction

// Tester function for the MTScore tool

// Can be run in the SVL window or on the MOE/batch commandline:
//      $ moebatch -licwait -exec "eval [qbMTScoreFile ['4w7t_protein.pdb', '4w7t_ligand.mol2']]" -exit
global function qbMTScoreFile [targetfile,ligandfile]
    local pdata = SystemPush [];
    write ['MTScore: {} : {} | ', fbase ftail targetfile, fbase ftail ligandfile];
    local starttime = clock [];
    local targetobj, ligandobj;
    targetobj = ReadAuto targetfile;
    ligandobj = ReadAuto ligandfile;
    // ligandobj = _Atoms '$$ligand';
    
//    local tmpJSON = qbWS_MTScore [diff [Atoms[], _Atoms '$$ligand'],_Atoms '$$ligand'];
    local tmpJSON = qbWS_MTScore [targetobj,ligandobj];
    write ['{} {} {}  | {} sec\n', tmpJSON.('MTScoreES'),tmpJSON.('E_Sol'),tmpJSON.('dG'), (clock [] - starttime) ];
//    write ['MTScore: {} : {} | {} {} {}  | {} sec\n', fbase ftail targetfile, fbase ftail ligandfile, tmpJSON.('MTScore'),tmpJSON.('E_Sol'),tmpJSON.('dG'), (clock [] - starttime) ];

    SystemPop pdata;
endfunction

// Can be run in the SVL window or on the MOE/batch commandline:
//      $ moebatch -licwait -exec "eval [qbMTScoreEFile ['4w7t_protein.pdb', '4w7t_ligand.sdf']]" -exit
//          qmechanicexec should be left blank (null) if want to use default/current settings. qmechanicexec can be 'noopt' to skip calculation and just output JSON file.
//
// forward declarations:
function db_NextEntry;
function db_Open;
function db_ImportSD;
function db_ImportMOL2;
function db_Fields;

global function qbMTScoreEFile [targetfile,ligandfile,posefile,opt,qmechanicexec]
    local psys = SystemPush [];
    write ['MTScore: {} : {} | {}', fbase ftail targetfile, fbase ftail ligandfile, fbase ftail posefile];
    local starttime = clock [];
    local targetobj, ligandobj, poseobj;
    targetobj = ReadAuto targetfile;
    ligandobj = ReadAuto ligandfile;
        
    if fext posefile <> 'mdb' then
        local new_posefile = twrite ['{}.mdb',fbase ftail posefile];
        if fext ftail posefile == 'sdf' then
            db_ImportSD [db_Open [ new_posefile,'create' ], posefile,'mol'];
        elseif fext ftail posefile == 'mol2' then
            db_ImportMOL2 [posefile, db_Open [ new_posefile,'create' ],'mol'];
        endif
        posefile = new_posefile;
    endif
    
    local mdb = db_Open posefile;
    local mfield = '';
    local [fldnames, fldtypes] = db_Fields mdb;
    mfield = fldnames | fldtypes == 'molecule';
    local ent = 0;
    local pdata;
    while (ent = db_NextEntry [mdb, ent]) loop
        pdata = tag [fldnames, db_ReadFields [mdb, ent, fldnames]];
        poseobj =  append [poseobj, pdata.(first mfield)];
    endloop
    write ['{}\n',length poseobj];

    local tmpJSON = qbWS_MTScoreE [targetobj,ligandobj,poseobj,opt,[],[],[],[],qmechanicexec,[]];
    write ['{} {} {}  | {} sec\n', tmpJSON.('MTScoreES'),tmpJSON.('E_Sol'),tmpJSON.('dG'), (clock [] - starttime) ];
//    write ['MTScore: {} : {} | {} {} {}  | {} sec\n', fbase ftail targetfile, fbase ftail ligandfile, tmpJSON.('MTScore'),tmpJSON.('E_Sol'),tmpJSON.('dG'), (clock [] - starttime) ];

    SystemPop psys;
endfunction

global function qbRunMTPairList listfile
    local L;
    local fnum = fopen listfile;
    write ['CALC:      TARGET     :    LIGAND   | InteractE  E_sol  MTScoreES | TIME\n'];
    while length (L = cat freadb [fnum, 'line', 1]) loop
        if second task_fork [] == 'child' then
            L = fieldsplit [ L," "];
            qbMTScoreFile [token first L, token second L];
            exit[];
        endif
    endloop
endfunction

global function qbWSConfig [cmd, wkey, trigger, values]

    local [hostname, port, username, stdion, qmechanicexec, protocol] = getWSDefaults [];
    local url = getWSHostNPort [hostname, port, username, stdion, qmechanicexec];
    
    local DEFAULTS = [
        qbWSHostname: GetRC ['QuantumBio.qbWSHostname','localhost'],
        qbWSPort:     GetRCNumber ['QuantumBio.qbWSPort',8080]
    ];
    
    local config = gr_icon ['$MOE/lib/icon/config.ico', 12, 'foreground'];
    
    function apprHost inName
        const hostlen = 25;
        inName = string inName;
        if length inName > hostlen then
            inName = twrite ['{}...',resize [inName,hostlen]];
        endif
        return twrite ['{}',inName];
    endfunction

    if cmd == 'getWidget' then
        return [
//            Hbox:   [
                extendH: 1,
                Label: [
                    text: 'SVR:',
                    font: 'mediumFixedBold'
                ],
                Label: [
                    name: 'qbwebservice_info',
                    text: twrite ['{}:{}', apprHost twrite ['{}://{}@{}',protocol, username, hostname],port],
                    bubbleHelp:twrite ['{}://{}@{}:{}/{}',protocol, username, hostname, port, qmechanicexec]
                ],
                Button: [
                    title: '', name: 'button_WSsetup', graphics: config,
                    bubbleHelp: 'Configure QuantumBio WebSerice (host and port).'
                ]
//            ]
        ];
    elseif cmd == 'processWidget' then
    
        local wsPortList = ['8080','8081','8082'];
        local sshPortList = ['22'];
        local hostList = uniq cat [GetRC ['QuantumBio.qbWSHostname','localhost'],app token fieldsplit [string GetRC ['QuantumBio.hostList','localhost'],";"]];
        local execList = uniq cat [GetRC ['QuantumBio.qbExecutable','qmechanic'],app token fieldsplit [string GetRC ['QuantumBio.execList','qmechanic'],";"]];
        local sshUsername = [getenv 'MOE_USER'];
    
        if trigger === 'button_WSsetup' then
    
            local wConfKey = WindowCreate
            [
                title: 'DivCon Suite Setup',
                name: 'panel',
                text:   ['Save','Cancel'],
                onTrigger: ['validate','return'],
                bubbleHelp: [
                    'Configure qbWebService (hostname and port).'
                ], 
                Mbox : [
                    Radio   :  [
                        title: 'Interface', name: 'qbInterface',
                        text:   ['qbWebService','Executable'],
                        value: GetRC ['QuantumBio.qbInterface','qbWebService'],
                        onTrigger: 'return', 
                        bubbleHelp: 'Choose whether to use qbWebService or qmechanic to process commands.\nNote: if Executable and a remote hostname is selected than passwordless ssh\nbetween this host and the remote host is assumed (be sure that the proper\nqmechanic is in your remote PATH).'
                    ],
                    Text    :  [
                        title: 'Hostname:', name: 'qbWSHostname', type: 'char',allowBlank:0,len:30,
                        value: hostname,
                        shortcut: hostList,
                        onTrigger: 'return',
                        bubbleHelp: 'Enter hostname (default: localhost).'
                    ],
                    Text    :  [
                        title: 'Username (ssh):', name: 'qbWSUsername', type: 'char',allowBlank:1,len:20,sensitive:0,
                        value: username,
                        shortcut: sshUsername,
                        onTrigger: 'return',
                        bubbleHelp: twrite ['Enter your username which will be used if Executable is \nselected and a remote host is chosen (default: {}).',getenv 'MOE_USER']
                    ],
                    Hbox    :   [            
                        Text : [
                            title: 'Port:', name: 'qbWSPort', type: 'int',allowBlank:0,len:5,
                            value: port,
                            shortcut: wsPortList,
                            onTrigger: 'return',
                            bubbleHelp: 'Enter the port number (default: 8080 for webservice and 22 for ssh).'
                        ],
                        Label : [
                            text: '', name: 'wsStatus', centerH: 1, extendH: 1
                        ]
                    ],
                    Text    :  [
                        title: 'Executable:', name: 'qbExecutable', type: 'char',allowBlank:1,len:30,sensitive:0,
                        value: qmechanicexec,
                        shortcut: execList,
                        onTrigger: 'return',
                        bubbleHelp: twrite ['Enter the full path to the executable on the machine it will be run on.\n(DEFAULT: {} where qmechanic is in your $PATH)','qmechanic']
                    ]
                ]
            ];
            
            function UpdateStatus [wConfKey,trig]
                static prevHost;
                static prevURL;
                static prevTime;
                
                if isnull trig then
                    trig = '';
                endif
                
                if trig == 'init' then
                    prevHost = null[];
                    prevURL = null[];
                    prevTime = clock[];
                endif
                
                local vals = WindowValues wConfKey;
                local tmpURL;
                tmpURL = getWSHostNPort [
                    vals.qbWSHostname,
                    vals.qbWSPort,
                    vals.qbWSUsername,
                    vals.qbInterface === 'Executable',
                    vals.qbExecutable];
                if ((eqL [prevURL, tmpURL]) and (10 < (clock[] - prevTime))) then return;  endif
                prevURL = tmpURL;
                prevTime = clock[];

                WindowSetAttr [wConfKey, [wsStatus: [text: 'Checking Connection....', foreground: 'orange']]];
                WindowSetAttr [wConfKey, [panel: [sensitive:[0,1]]]];

                if vals.qbInterface === 'qbWebService' then
                    WindowSetAttr [wConfKey,[qbWSUsername : [sensitive:0]]];
                    WindowSetAttr [wConfKey,[qbExecutable : [sensitive:0]]];
                    WindowSetAttr [wConfKey,[qbWSPort : [sensitive:1]]];      
                    WindowSetAttr [wConfKey,[wsStatus : [bubbleHelp:'Be sure your remote hostname and port are set correctly and \nthat there are no firewalls between your host and the remote host.']]];
                    if trig <> 'qbWSPort' then WindowSetAttr [wConfKey,[qbWSPort : [shortcut: wsPortList,value: GetRCNumber ['QuantumBio.qbWSPort',8080]]]]; endif
                elseif vals.qbInterface === 'Executable' and vals.qbWSHostname <> 'localhost'  then
                    if neL [prevHost,vals.qbWSHostname] then
                        prevHost = vals.qbWSHostname;
                        execList = uniq cat [tok_drop [(first url_Parse ssh_which ['qmechanic',vals.qbWSHostname,vals.qbWSUsername]).path, 1], execList];
                        WindowSetAttr [wConfKey,[qbExecutable : [shortcut: execList]]];
                    endif
                    WindowSetAttr [wConfKey,[qbWSUsername : [sensitive:1]]];
                    WindowSetAttr [wConfKey,[qbExecutable : [sensitive:1]]];
                    WindowSetAttr [wConfKey,[qbWSPort : [sensitive:0]]];  // NOTE: currently MOE does not support ssh with alternate ports.
                    WindowSetAttr [wConfKey,[wsStatus : [bubbleHelp:'Be sure your remote username, hostname, ssh port, and executable path are set correctly \n(and ssh is set for passwordless entry to remote host from this localhost).']]];
                    if trig <> 'qbWSPort' then WindowSetAttr [wConfKey,[qbWSPort : [shortcut: sshPortList, value: GetRCNumber ['QuantumBio.qbSSHPort',22]]]]; endif
                elseif vals.qbInterface === 'Executable' and vals.qbWSHostname === 'localhost'  then
                    if neL [prevHost,vals.qbWSHostname] then
                        prevHost = vals.qbWSHostname;
                        execList = uniq cat [which ['qmechanic'], execList];
                        WindowSetAttr [wConfKey,[qbExecutable : [shortcut: execList]]];
                    endif
                    WindowSetAttr [wConfKey,[qbWSUsername : [sensitive:0]]];
                    WindowSetAttr [wConfKey,[qbExecutable : [sensitive:1]]];
                    WindowSetAttr [wConfKey,[qbWSPort : [sensitive:0]]];
                    WindowSetAttr [wConfKey,[wsStatus : [bubbleHelp:'Be sure the local executable path is set correctly and that you have permission to access/run this executable.']]];
                    if trig <> 'qbWSPort' then WindowSetAttr [wConfKey,[qbWSPort : [shortcut: sshPortList, value: GetRCNumber ['QuantumBio.qbSSHPort',22]]]]; endif
                endif
                vals = WindowValues wConfKey;

                tmpURL = getWSHostNPort [
                    vals.qbWSHostname,
                    vals.qbWSPort,
                    vals.qbWSUsername,
                    vals.qbInterface === 'Executable',
                    vals.qbExecutable];

                local tmpConnect = qbWSTestEndpoint tmpURL;
                if length tmpConnect == 0 then
                    WindowSetAttr [wConfKey, [wsStatus: [text: 'No Connection', foreground: 'red']]];
                    WindowSetAttr [wConfKey, [panel: [sensitive:[0,1]]]];
                else
                    WindowSetAttr [wConfKey, [wsStatus: [text: 'Connection OK', foreground: 'blue']]];
                    WindowSetAttr [wConfKey, [panel: [sensitive:[1,1]]]];
                endif
                
                prevURL = tmpURL;
                
            endfunction
            
            function HostMonitor wConfKey
                local prevHost;
                local vals;
                while WindowKey wConfKey loop
                    vals = WindowValues wConfKey;
//                    if neL [prevHost, vals.qbWSHostname] then
                        prevHost = vals.qbWSHostname;
                        UpdateStatus wConfKey;
//                    endif
                    sleep 2;
                endloop
            endfunction
            
            WindowShow wConfKey;
            UpdateStatus [wConfKey, 'init']; 
            if second task_fork [master:'none', idle:1, prio:0] === 'child' then
                HostMonitor wConfKey;
                exit [];
            endif
            loop
                local [vals, trig] = WindowWait wConfKey;
                if trig === 'panel' then
                    if vals.panel == 'Cancel' then break; endif
                    if vals.panel == 'Save' then
                        UpdateStatus [wConfKey,trig];
                        hostList = uniq cat [vals.qbWSHostname, GetRC ['QuantumBio.hostList','localhost']];
                        execList = uniq cat [vals.qbExecutable, GetRC ['QuantumBio.execList','qmechanic']];
                        SetRC ['QuantumBio.hostList',token droplast cat apt swrite ['{};', keep [uniq hostList,5]]];
                        SetRC ['QuantumBio.execList',token droplast cat apt swrite ['{};', keep [uniq execList,5]]];
                        SetRC ['QuantumBio.qbInterface',vals.qbInterface];
                        SetRC ['QuantumBio.qbWSHostname',vals.qbWSHostname];
                        if vals.qbInterface === 'qbWebService' then
                            SetRCNumber ['QuantumBio.qbWSPort',vals.qbWSPort];
                        else
                            SetRCNumber ['QuantumBio.qbSSHPort',vals.qbWSPort];
                            SetRC ['QuantumBio.qbExecutable',vals.qbExecutable];
                            if vals.qbWSHostname <> 'localhost' then
                                SetRC ['QuantumBio.qbWSUsername',vals.qbWSUsername];
                            endif
                        endif
                        break;
                    endif
                else
                    hostList = uniq cat [vals.qbWSHostname, app token fieldsplit [string GetRC ['QuantumBio.hostList','localhost'],";"]];
                    execList = uniq cat [vals.qbExecutable, app token fieldsplit [string GetRC ['QuantumBio.execList','qmechanic'],";"]];
                    SetRC ['QuantumBio.hostList',token droplast cat apt swrite ['{};', keep [uniq hostList,5]]];
                    SetRC ['QuantumBio.execList',token droplast cat apt swrite ['{};', keep [uniq execList,5]]];
                    WindowSetAttr [wConfKey,[qbWSHostname : [shortcut:hostList ]]];
                    WindowSetAttr [wConfKey,[qbExecutable : [shortcut:execList ]]];
                    UpdateStatus [wConfKey,trig];
                endif
            endloop
            WindowDestroy wConfKey;
            
            [hostname, port, username, stdion, qmechanicexec, protocol] = getWSDefaults [];
    
            WindowSetAttr [wkey, [
            qbwebservice_info: [text:twrite ['{}:{}', apprHost twrite ['{}://{}@{}',protocol, username, hostname],port],
                bubbleHelp:twrite ['{}://{}@{}:{}/{}',protocol, username, hostname, port, qmechanicexec]
            ]]];
            return 1;
        endif
        return 0;
    endif
        
endfunction

function json_Read;

// qbWS2JSON - a simple function to access a webservice and return a JSON vector
global function qbWS2JSON url
    local curl_out;
    local err;

    if isnull url then
        url = getWSHostNPort[];
    endif
    
    local [hostname, port, username, stdion, qmechanicexec, protocol] = parseURL url;
    
    if protocol === 'http' or protocol === 'https' then
        local curlkey = curl_open [url: url];
        [curl_out, err] = task_call [ 'curl_read',  curlkey, [errmsg:'ignore'] ];
        if err <> '' then
            err = twrite ['Unable to reach webservice: {}', err];
        endif
        curl_close curlkey;
    endif

    if err === '' then
    else
        write ['ERROR: {}\n', err];
        curl_out = '';
    endif
    
//    return qbReadJSONStream curl_out;
write ['DATA: {}\n', curl_out];
    return json_Read [curl_out,[]];

endfunction

// For running on the command line ()
//
//  EXAMPLE: % moebatch -run $QBHOME/svl/qbWebService.svl -rec thrombin_030215.pdb -lig thrombin_030215_Lig3b.mol2 -host localhost -port 8080
//
global argv;

function ArgvPull;

local function main []

    local startcputime = cpuclock[];
    local starttime = clock[];
    local inopt;
    local protocol;
    local qmechanicexec;
    ArgvReset ArgvExpand argv;
    local [mtscoreexe] = ArgvGet [ ['-mtscoreexe'], [0]];
    local [recfilename, ligfilename, hostname, port, username, stdion] = ArgvPull [ ['-rec', '-lig','-host','-port','-user','-stdio'], [1,1,1,1,1,0] ];
    local [runqmechanic] = ArgvPull [ ['-mtscoreexe'], [1] ];
    local remaining = ArgvAll [];
    if not isnull remaining then
        exit twrite ['ERROR: Unknown command line options: {}\n',remaining];
    endif
        
    if not isnull recfilename then
        local rec = cat cat cAtoms ReadAuto recfilename;
        if isnull rec then
            exit twrite ['Cannot read receptor file {}', recfilename];
        endif
    else
        exit twrite ['Use -rec command line argument to provide an input file for RECEPTOR'];
    endif
    
    if not isnull ligfilename then
        local lig = cat cat cAtoms ReadAuto ligfilename;
        local ligResidue = aResidue first lig;
        oReparent [diff [lig, first lig], ligResidue];  // MOE appears to need all lignad atoms in a single residue
        if isnull lig then
            exit twrite ['Cannot read receptor file {}', ligfilename];
        endif
    else
        exit twrite ['Use -lig command line argument to provide an input file for LIGAND'];
    endif
    
    [hostname, port, username, stdion, qmechanicexec, protocol] = getWSDefaults [hostname, port, username, stdion, qmechanicexec];

    local qbhome;
    if mtscoreexe then
        if not isnull runqmechanic then
            qbhome = runqmechanic;
        elseif not isnull getenv ['QBHOME'] then
            qbhome = getenv ['QBHOME'];
        else
//            usage [];
            exit twrite ['Envionrment variable QBHOME is not set. Either set this shell variable or provide the path to QBHOME in -mtscoreexe argument.\n'];
        endif
        
        qmechanicexec = twrite ['{}/bin/qmechanic', qbhome];
        
        if hostname == 'localhost' then
            local file_info = fstat qmechanicexec;
            if file_info(1) <> 'file' then
    //            usage [];
                exit twrite ['Executable: {} does not exist\n\tPlease correctly set your QBHOME enivronment variable or -mtscoreexe argument.\n',qmechanicexec];
            endif
            if not bitand [file_info(3), 0x04] then
    //            usage [];
                exit twrite ['Executable: {} is not allowed to be executed\n',qmechanicexec];
            endif
        elseif length qbWSTestEndpoint getWSHostNPort [hostname, port, username, stdion, qmechanicexec] == 0 then
            exit twrite ['Executable: {} is not allowed to be executed\n',getWSHostNPort [hostname, port, username, stdion, qmechanicexec]];
        endif
    endif

    write ['Scoring {} target atoms & {} ligand atoms on qbWebService: {}\n', length rec, length lig, getWSHostNPort[hostname, port, username, stdion]];
    local scoreData = qbWS_MTScore [rec, lig, hostname, port, username, stdion, qmechanicexec];
    write ['scoreData: {}\n', qbWriteJSONStream scoreData];
    
endfunction

#eof

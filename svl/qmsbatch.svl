#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.

 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information,
 including trade secrets, belonging to QuantumBio Inc. and/or its
 affiliates.

 Use, duplication, or disclosure of this source code is strictly
 prohibited without prior written authorization by the management of
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif

//    qmsbatch.svl    Executes QMScore calculations in batch mode

#set title   'QuantumBio QMScore Batch'
#set class   'QuantumBio'
#set version '2010.02'
#set main    'qb_QMScoreBatch'

function qb_GetPoseFields;
function qb_GetRecFields;
function qb_GetQMSEnv;
function qb_GetStatusFlags;
function qb_SaveDivconStatus;
function qb_SaveQMScore;
function qb_QMScore;


/****************************************************************************
 *                          qb_QMScoreBatch
 *
 *  Execute QMScore for each row of the scoring database.
 *
 *  HACK alert:  an extra flag was added to the LIGOK and RECOK flag vectors
 *  in order to force moe to treat is as them as vectors, not as scalars.
 *
 ****************************************************************************/
global function qb_QMScoreBatch [dbpath]

    if not MOE_BATCH then return; endif

    //  Extract molecules and run options from the database environment
    local dbkey = db_Open [dbpath, 'read-write'];
    local [recmols, ligmol, s, coreopts, qmsopts] = qb_GetQMSEnv [dbkey];
    local [recmolsok, ligmolsok] = qb_GetStatusFlags dbkey;
    local recoklen = length recmolsok - 1;
    local ligoklen = length ligmolsok - 1;
    local nrows = db_nEntries dbkey;

    //  Have rows been added or deleted?
    if coreopts.mode === 'One-to-Many' then
        if neL [recoklen, 1] or neL [ligoklen, nrows] then
            exit 'QMScore database has been modified'
                 ' and is not longer consistent.\n';
        endif
    else
        if neL [recoklen, ligoklen, nrows] then
            exit 'QMScore database has been modified'
                 ' and is not longer consistent.\n';
        endif
    endif

    local recchg;
    local workdir;
    if coreopts.pwd === 1 then
        workdir = getenv 'PWD';
    else
        workdir = fabsname coreopts.workdir;
    endif

    coreopts.workdir = workdir;
    write ['Work Dir:  {}\n', workdir];  //DEBUG

    //  For each ligand pose in the database, calculate QM score.
    local rowkey = 0, , reccnt = 1, rowcnt = 0;
    local poseflds = qb_GetPoseFields [dbkey];
    local recflds = qb_GetRecFields [dbkey];
    local tid = task_key -1;
    loop
        if rowcnt === 0 or rowkey <> 0 then
            rowkey = db_NextEntry [dbkey, rowkey];
        endif

        if rowkey <> 0 then
            rowcnt = rowcnt + 1;
            if coreopts.mode === 'Many-to-Many' then
                reccnt = rowcnt;
            endif

            if not recmolsok(reccnt) or not ligmolsok (rowcnt) then
                qb_SaveDivconStatus [dbkey, rowkey, swrite [
                    'Error:  Bad {}, skipping computation!\n',
                    qb_GetWhich [not recmolsok(reccnt),
                    not ligmolsok (rowcnt)]]];
                continue;
            endif

            coreopts.task = rowcnt;
            local [posemol, posechg] = db_ReadFields [dbkey, rowkey, poseflds];

            if coreopts.mode === 'Many-to-Many' then
                [recmols, recchg] = db_ReadFields [dbkey, rowkey, recflds];
            else
                recchg = coreopts.recchg;
            endif
        endif

        coreopts.ligchg = posechg;
        coreopts.recchg = recchg;

        local [[results, errmess], code, seqno, indkey] = mpu_batch [
            select ['', 'call', rowkey === 0],
            'qb_QMScore', [recmols, posemol, coreopts, appopts], [rowkey, tid]];

        if rowkey <> 0 then
            write ['Scoring pose {} of {}\n', rowcnt, nrows];
        endif

        if code === '' then
            if neL [tid, indkey(2)] then
                exit 'MPU/task conflict, aborting calculation.';
            endif

            if results === [] then
                if errmess === [] or errmess === '' then
                    errmess = "Unknown error!";
                endif
                qb_SaveDivconStatus [dbkey, indkey(1),
                    swrite ['Error:  {}\n', errmess]];
                write ['QMScore Error on pose {}:\n    {}\n', seqno, errmess];
            else
                qb_SaveQMScore [dbkey, indkey(1), results];
                errmess = cat [ "Success\n", errmess];
                qb_SaveDivconStatus [dbkey, indkey(1), errmess];
            endif

        elseif code === 'error' then
            if errmess === [] or errmess === '' then
                errmess = "Unknown error!";
            endif
            qb_SaveDivconStatus [dbkey, indkey(1),
                swrite ['Error:  {}\n', errmess]];

            write ['QMScore Error on pose {}:\n    {}\n', seqno, errmess];
        endif

    until code === 'eof'
    endloop

    db_Close dbkey;

endfunction

#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif   

/****************************************************************************
 *                                qbPrep2Files.svl
 *
 *  Read in a PDB, MOL2, or any other file MOE supports, add protons using
 *  Protonate3D, and finally tether-minimize all atoms in the system. Two
 *  mol2 file are produced: 
 *      p_${basefilename}.mol2  - corresponds to protonated form.
 *      mp_${basefilename}.mol2 - corresponds to minimized form.
 *
 *  Main function:
 *
 *    qbPrep2Files [target_filename, ligand_filename, [options]]
 *
 *  Example moebatch call:
 *
 *    qbmoebatch -licwait -exec "run ['qbPrep2Files.svl',['target.mol2','ligand.mol2',[]]]" -exit
 *          Run the script on target.mol2 and ligand.mol2 files in CWD.
 *          This setup will use default options.
 *
 *    qbmoebatch -licwait -exec "run ['qbPrep2Files.svl',['D_glucose.mol2',[],[enableOpt:0,enableLigFix:0]]]" -exit
 *          Run the script on D_glucose.mol2 within the CWD.
 *          This setup will only run the job on a single ligand mol2 file, and it will turn off
 *              optimization and fixing the ligand protonation during protonation.
 *
 *   moebatch -licwait -exec "run ['qbPrep2Files.svl',['HYP_reduce.pdb',[],[enableOpt:0,enableLigFix:0,enableProtonate:1,protAtomList:[3],enablePreciseHOH:0]]]" -exit
 *          The script can also be used to only protonate atoms you wish to protonate.
 *              protAtomList:[3] will protonate just the 3rd atom in the file. protAtomList:[3,5] will
 *              protonate both the 3rd and the 5th atoms in the file. (and so on).
 *
 *  moebatch -licwait -exec "run ['$HOME/svl/qbPrep2Files.svl',['testing.moe',[],[enableOpt:0,enableProtonate:0,enableCropOnLig:0,enableCutWat:0]]]" -exit
 *          Simply splits the complex into target and ligand.
 *
 *      NOTE: -licwait is used to wait for a license to free. It will wait forever.
 *
 ****************************************************************************/

#set main 'qbPrep2Files' 

function Protonate3D;
function _Atoms;
function fwrite_TriposMOL2;
function fwrite_PDB;
function pro_Align;
function pro_Join;
function MM;

// QB Toolbox:
function qbSelectOnRadius;
function qbCleanDelAtoms;
function qbSelectResidueOnRadius;
function qbNearby;
function qb_TestDivCon;
function qbSelectWatOnRadius;

const DEFAULTS = [
    enableWatPart:0,        // partitions waters into each of the atoms/residues and reprotonates.
    enableAutoPrep:0,       // Run the MOE structure preparation tool.
    enableOpt:1,            // turn on optimization
    tether_val:100,         // tethers the heavy atoms at a certain restraint.
    enableProtonate:0,      // turns on Protonate3D
    protAtomList:[],        // list of atom indices to protonate
    enablePreciseHOH:0,     // turns on precise waters in Protonate3D (can cause LONG calc if turned on).
    enableLigFix:1,         // but fixes the ligand protonation
    enableCutWat:0,         // it will not remove all waters beyond ligand
    wat_radius:4.5,         // using this distance from ligand
    enableCropOnLig:0,      // turns off cropping target around ligand
    qmcrop_radius:0,        // acceptable distance around ligand to leave in
    residueRenumber:0,      // renumbers the residues (not implemented)
    hamiltonian:'pm6',     // the Hamiltonian to be used downstream
    qmApplication:'qms',       // the particular QM application to be used downstream
    quitonerror:0,          // by default, the run will continue even on error (not good if used in shell script)
    outfiletype:'mol2',     // output file type supported by script (can be either mol2 or PDB).
    prtElementList:['H','C']       // elements to print to atom list file (such as for NMR or belly)
];

local function writeElementList [outpat,chains,prtElementList]

    if not isnull prtElementList then
        local atmlist = sort cat indicesof [prtElementList,cat aElement cat cAtoms chains];
        local fileHDL = fopenw twrite ['{}.atms',fbase ftail outpat];
        local atmID;
        for atmID in atmlist loop
            fwrite [fileHDL,'    ATOM {}\n',atmID];
        endloop
        fclose fileHDL;
    endif

endfunction

local function writeMol2 [outpat,chains,opt]

    if isnull chains then
        return;
    endif

    pot_SetCharges [];
    
    cSetTag [chains, cTag first chains];
//    cSetName [chains, cName first chains];
//    chains = pro_Join[chains];
    if opt.outfiletype === 'pdb' then
        write ['outfile: {}\n', twrite ['{}.pdb',outpat]];
        fwrite_PDB [twrite ['{}.pdb',outpat],chains];
    else
        write ['outfile: {}\n', twrite ['{}.mol2',outpat]];
        fwrite_TriposMOL2 [twrite ['{}.mol2',outpat],chains];
    endif
    writeElementList [outpat,chains,opt.prtElementList];
    
endfunction

local function qbWriteElementList [targ_patt,opt]
    opt = tagcat[opt, DEFAULTS];
    local srcfilelist_targ = flist [cd [], targ_patt];
    local fname_targ, targ_chains = [], lig_chains = [];
    for fname_targ in srcfilelist_targ loop
        oDestroy Chains [];
        write ['\nReading ... {}\n', fname_targ];
        targ_chains = ReadAuto [fname_targ,[multi_model:1]];
        local tmpChainTag = first cName targ_chains;
        writeElementList[twrite ['{}_rec.atms',tmpChainTag],targ_chains,opt.prtElementList];
    endloop
endfunction
    
local function qbVennStructures [targ_patt, opt, ligand_mdb]

    opt = tagcat[opt, DEFAULTS];

    local srcfilelist_targ = flist [cd [], targ_patt];
    local fname_targ, targ_chains = [], lig_chains = [];
    local tmpChainTag;

    // read in the targets
    for fname_targ in srcfilelist_targ loop
        write ['\nReading ... {}\n', fname_targ];
        local tmpRecChains = ReadAuto [fname_targ,[multi_model:1]];
        targ_chains = append [targ_chains,diff[tmpRecChains,join[tmpRecChains,uniq aChain _Atoms '$$ligand']]];
        lig_chains = append [lig_chains,join[tmpRecChains,uniq aChain _Atoms '$$ligand']];
    endloop
    
// process the mdb file if its provided
    if not isnull ligand_mdb then
        local mdb = db_Open ligand_mdb;
        local mfield = db_RequireFieldType [mdb, 'molecule'];
        local entCnt = 0;
        local ent = 0;
        while (ent = db_NextEntry [mdb, ent]) loop
            entCnt = entCnt + 1;
            local mol = first db_ReadFields [mdb, ent, mfield];
            local tmp_chains = mol_Create mol;
            cSetName [tmp_chains, twrite ['{}_{}',mol(1)(MOL_NAME),entCnt]];
            pot_SetCharges [];
            lig_chains = append[lig_chains,tmp_chains];
        endloop
    endif

    targ_chains = cat targ_chains;
    lig_chains = cat lig_chains;
    
    oSetCollection['Receptor',cat targ_chains];
    View[];
    write ['\nnChains= {}\n', nChains[] ];
    
    pro_Align [Chains[],[superpose:1,enable_structural:0]];
    if length targ_chains == 1 then
        rSetPos[cResidues targ_chains,cAlignmentPositions targ_chains];
    endif
// return;
    if opt.enableCropOnLig then
        local vennAtms = qbSelectOnRadius [cat cAtoms lig_chains, opt.qmcrop_radius];
        vennAtms = diff [vennAtms, cat cAtoms lig_chains];
        local all_rObject = cat cResidues targ_chains;
        aSetSelected [Atoms[],0];
        aSetSelected [rAtoms all_rObject [x_diff [cat cAlignmentPositions targ_chains,uniq sort cat rPos aResidue vennAtms]],1];
        qbCleanDelAtoms cat rAtoms all_rObject [x_diff [cat cAlignmentPositions targ_chains,uniq sort cat rPos aResidue vennAtms]];
    endif

    if opt.enableCutWat then
    // get the solvent atoms that are far from the ligand
        qbCleanDelAtoms qbSelectWatOnRadius [_Atoms '$$ligand',opt.wat_radius,'invert'];
    endif

    local tmpChains;
//    for tmpChainTag in cTag targ_chains loop
//        local tmpChains = Chains[] | cTag Chains [] == tmpChainTag;
    for tmpChainTag in cName targ_chains loop
        tmpChains = Chains[] | cName Chains [] == tmpChainTag;   
        writeMol2[twrite ['{}_rec',tmpChainTag],join [tmpChains,targ_chains],opt];
    endloop
    for tmpChainTag in cName lig_chains loop
        tmpChains = Chains[] | cName Chains [] == tmpChainTag;   
        writeMol2[twrite ['{}_lig',tmpChainTag],join [tmpChains,lig_chains],opt];
    endloop

endfunction

global function qbTetherMMMin [weight]
//    pot_Load ['$MOE/lib/mmff94x.ff'];    // switch to OPLS-AA as this will do a better job.

	pot_SetCharges [];

    pot_Setup
        [
        strEnable:1, angEnable:1, stbEnable:1, oopEnable:1, torEnable:1,
        vdwEnable:1, eleEnable:1, solEnable:1, resEnable:1, strWeight:1, 
        angWeight:1, stbWeight:1, oopWeight:1, torWeight:1, vdwWeight:1, 
        eleWeight:1, solWeight:1, cutoffEnable:1, cutoffOn:8, cutoffOff:10, 
        angForm:0, eleDist:0, vdwScale14:0.5, vdwBuffer1:0, vdwBuffer2:0, 
        eleScale14:0.5, eleDielectric:1, eleBuffer:0, solDielectric:80, 
        solDielectricOffset:0, state0:1, state1:0, state2:1, threadCount:0
        ];
    
    pot_Info [];

    local atoms = Atoms [];
    local m = aMMType atoms == '??';
    if anytrue m then
	    write ['\nWARNING:  There are unparameterized atoms in the system.\n\n'];
    endif

    local tetherWeight = rep [weight, length atoms];
    (tetherWeight | aAtomicNumber atoms <= 1) = 0;
    
    if weight > 0 then
        MM [    tetherWeight:    tetherWeight    ];
    else
        MM[];
    endif
    
endfunction

local function qbReparentSolvent []
    local solvChains = uniq aChain _Atoms ['$$solvent'];
    oDestroy [cat cAtoms solvChains | aElement cat cAtoms solvChains == 'H'];   // destroys all protons on oxygens
    local solvChain, oxAtm;
    for solvChain in solvChains loop
        local origResidues = cat cResidues solvChain;
        for oxAtm in cat cAtoms solvChain loop
            local newResidue = oCreate solvChain;
            rSetName[newResidue,'HOH'];
            oReparent[oxAtm, newResidue];
        endloop
        oDestroy origResidues;
    endloop
    local atomsToProtonate = cat cAtoms solvChains;
    Protonate3D [atomsToProtonate,atomsToProtonate,atomsToProtonate,[],[],[]];
endfunction

// function to pull a ligand out of a complex and give it its own chain (return chain)
local function qbReparentLigand[inAtoms]
    local ligandResidue = uniq aResidue inAtoms;
    local newChain = oCreate [0];
    cSetName [newChain,cName rChain first ligandResidue];
    cSetTag [newChain, cTag rChain first ligandResidue];
    oReparent[ligandResidue,newChain];
    return newChain;
endfunction

global function qbPrep2Files [fname_targ, fname_lig, opt]     // x is the function argument

    opt = tagcat[opt, DEFAULTS];
    
    local targ_chains, lig_chains;
        
    pot_Load ['$MOE/lib/mmff94x.ff'];    // switch to OPLS-AA as this will do a better job.

    oDestroy Chains [];
    
    write ['\nReading ... {}\n', fname_targ];
    targ_chains = ReadAuto fname_targ;
    if not isnull fname_lig then
        write ['\nReading ... {}\n', fname_lig];
        lig_chains = ReadAuto fname_lig;
    else
        fname_lig = fname_targ;
        lig_chains = uniq aChain _Atoms '$$ligand';
        local tmp_targ_chains = uniq aChain _Atoms '$$receptor';
        if length join[tmp_targ_chains,lig_chains] then
            lig_chains = qbReparentLigand[_Atoms '$$ligand'];
        endif
    endif
    
    if opt.enableAutoPrep then
        run ['$MOE/lib/svl/run/structprep_ui.svl',[cmd:'cli',batch_protonate3d:0]];
    endif

    if isnull targ_chains or isnull lig_chains then
        opt.enableCropOnLig = 0;
        opt.enableCutWat = 0;
    endif

    if targ_chains === lig_chains then
        opt.enableCropOnLig = 0;
        opt.enableCutWat = 0;
    endif
    
    if opt.enableWatPart then
        qbReparentSolvent[];
    endif
    
    targ_chains = diff [Chains[],lig_chains];
    
    write ['\nnChains= {}\n', nChains[] ];
    
    if opt.enableCropOnLig then
        qbCleanDelAtoms cat diff [Atoms[],qbSelectResidueOnRadius [cat cAtoms lig_chains, opt.qmcrop_radius]];
    endif
        
    if opt.enableCutWat then
    // get the solvent atoms that are far from the ligand
        qbCleanDelAtoms qbSelectWatOnRadius [_Atoms '$$ligand',opt.wat_radius,'invert'];
    endif
    
    if opt.enableProtonate then
        local preciseWaters = [];
        if opt.enablePreciseHOH then
            preciseWaters = _Atoms '$$solvent';
        endif
        local atomsToProtonate = Atoms[];
        if not isnull opt.protAtomList then
            atomsToProtonate = (Atoms[])[indexof[opt.protAtomList,aNumber Atoms[]]];
        endif
        if opt.enableLigFix then
//            Protonate3D [Atoms[],Atoms[],Atoms[],cat cAtoms lig_chains,preciseWaters,[]];
            Protonate3D [atomsToProtonate,atomsToProtonate,atomsToProtonate,cat cAtoms lig_chains,preciseWaters,[]];
        else
//            Protonate3D [Atoms[],Atoms[],Atoms[],[],preciseWaters,[]];
            Protonate3D [atomsToProtonate,atomsToProtonate,atomsToProtonate,[],preciseWaters,[]];
        endif
    endif
    
    if opt.enableOpt then
        qbTetherMMMin [opt.tether_val];
    endif
    
    targ_chains = join [targ_chains,Chains[]];

    oSetCollection['Receptor', targ_chains];
    oSetCollection['Ligand', lig_chains];
    
    if not isnull opt.hamiltonian and not isnull opt.qmApplication then
        local testErrs=qb_TestDivCon [twrite ['{} + {}',fname_targ,fname_lig],Atoms[],opt.qmApplication,opt.hamiltonian];
        if first testErrs == 0 then
            write ['ERROR: DivCon Test Prep Failed! Reported:\n'];
            write ['  {}',second testErrs];
            if opt.quitonerror then
                write [' Output Aborted\n'];
                return first testErrs;
            else
                write [' WARNING: output mol2 files should not be used in DivCon calculation!\n'];
            endif
        endif
    endif
    
    writeMol2[twrite ['mp_{}',fbase ftail fname_lig],Chains[],opt];
    writeMol2[twrite ['targ_{}',fbase ftail fname_lig],targ_chains,opt];
    writeMol2[twrite ['lig_{}',fbase ftail fname_lig],lig_chains,opt];

endfunction 

global function qbProcessFileGroup [targ_patt,fname_lig,opt]

    write ['Running set ... \n'];

    local srcfilelist_targ = flist [cd [], targ_patt];
    local fname_targ;
    for fname_targ in srcfilelist_targ loop
        oDestroy Chains [];
        qbPrep2Files [fname_targ, fname_lig, opt];
    endloop

endfunction

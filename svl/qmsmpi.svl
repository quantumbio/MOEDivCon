#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.

 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information,
 including trade secrets, belonging to QuantumBio Inc. and/or its
 affiliates.

 Use, duplication, or disclosure of this source code is strictly
 prohibited without prior written authorization by the management of
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif

	//    qmsmpi.svl    Executes QMScore calculations in parallel

#set title   'QuantumBio QMScore MPI'
#set class   'QuantumBio'
#set version '2010.01'
#set main    'qb_QMScoreMPI'

function qb_CheckChgTestDivConComplex;
function qb_GetDivConStatus;
function qb_GetPoseFields;
function qb_GetRecFields;
function qb_GetQMSEnv;
function qb_GetWhich;
function qb_HamSetsInit;
function qb_PassBackbone;
function qb_SaveDivConStatus;
function qb_SaveQMScore;

function qb_PassValues;
function qb_GetCoreFields;
function qb_GetQMS_dbFields;

// NEED MAC VERSION
global qboldversion;


/*  NOTE:  If you change the key lists here, you need to update the
 *         option lists and default indices in qbcore.svl and qmspanel.svl.
           The unused Hamilitonians were masked when the core was created.
 */

const HAM_KEYS =
    [
    'am1',
    'mndo',
    'mndod',
    'pddgpm3',
    'pm3',
    'pm6'
    ];

const LIG_KEYS =
    [
    'NOOPT',
    'LIGOPT',
    'COMPLEXOPT'
    ];

local function ManageMOEDivConMPI[stdout,stdin,process_keys,warnings,dbkey,numokay]

    local results = [];
    local return_statement = [];
    local divconerrmess = "";
    
    const NUMRESULTS = 11;
    local status_length=0;
    local rowcnt;
    
    local dbrowkeys = db_Entries [dbkey];

    local result_ith = 0;
    while exe_status process_keys(1) and result_ith <= numokay loop
        [[return_statement]] = fread [stdout, '{c:*}'];

        write ['DivCon: {}\n', return_statement];//DEBUG

        if return_statement === "status" then
            [[rowcnt]] = fread [stdout, '{n:}'];
            write ['Getting status for pose {} ({} of {})\n', rowcnt, 
                result_ith, numokay];
	    [[status_length]] = fread [stdout, '{n:}'];
            for status_length loop
                [[return_statement]] = fread [stdout, '{c:*}'];
                print ['running', return_statement];
            endloop
            fwrite [stdin, '{c:}\n', 'Ok'];
        elseif return_statement === "success" then

            [[rowcnt]] = fread [stdout, '{n:}'];
            write ['Getting results for pose {} ({} of {})\n', rowcnt, 
                result_ith, numokay];

            local name, nameValue;
            local parameter, parameterValue;
            [[name]] = fread [stdout, '{c:*}'];
            [[nameValue]] = fread [stdout, '{c:*}'];
            results = cat [results, [[name, nameValue]]];
            for NUMRESULTS loop
                [[parameter]] = fread [stdout, '{c:*}'];
                [[parameterValue]] = fread [stdout, '{n:}'];
                results = cat [results, [[parameter, parameterValue]]];
            endloop

            fwrite [stdin, '{c:}\n', 'Ok'];

            qb_SaveQMScore [dbkey, dbrowkeys(rowcnt), results];
            local sucmess = "Success";
            if not isnull  warnings (rowcnt)
                    and neL [warnings (rowcnt), '']
                    and neL [warnings (rowcnt), '\n'] then

                sucmess = cat [sucmess, "-warnings!\n", string warnings (rowcnt)];
            else
                sucmess = cat [sucmess, "\n"];
            endif

            qb_SaveDivConStatus [dbkey, dbrowkeys(rowcnt), sucmess];
            result_ith = result_ith + 1;

        elseif return_statement === "error" then

            [[rowcnt]] = fread [stdout, '{n:}'];
            if rowcnt < 1 or rowcnt > length dbrowkeys then
                write ['Getting chairman error message:\n'];

                while neL [return_statement, "DivCon done."] loop
                    [[return_statement]] = fread [stdout, '{c:*}'];
                    write ['    {}\n', return_statement];
                endloop;

                fwrite [stdin, '{c:}\n', 'Ok'];
            else
                write ['Getting error message for pose {} ({} of {})\n', rowcnt, 
                    result_ith, numokay];

                [[return_statement]] = fread [stdout, '{c:*}'];
                if neL [return_statement, "DivCon done."] then
                    divconerrmess = cat [divconerrmess, return_statement];
                    [[return_statement]] = fread [stdout, '{c:*}'];
                endif
                while neL [return_statement, "DivCon done."] loop
                    divconerrmess = cat [divconerrmess, "\n", return_statement];
                    [[return_statement]] = fread [stdout, '{c:*}'];
                endloop;

                fwrite [stdin, '{c:}\n', 'Ok'];

                if isnull divconerrmess then
                    divconerrmess = "Error:  unknown error!";
                else
                    divconerrmess = cat ["Error:  ", divconerrmess];
                endif

                if not isnull warnings (rowcnt) then
                    divconerrmess = cat [divconerrmess, 
                        string warnings (rowcnt)];
                endif

                qb_SaveDivConStatus [dbkey, dbrowkeys(rowcnt), divconerrmess];
            endif

            result_ith = result_ith + 1;

        elseif return_statement === "DivCon done." then
            print ['return_statement at DivCon done. Sending Ok '];
            fwrite [stdin, '{c:}\n', 'Ok'];
            return;

        else
            write ['what is: {}\n', return_statement];  //  abort?
        endif
    endloop
    
endfunction

local function ManageMOEDivConScoring[stdout,stdin,process_keys,warnings,dbkey,numokay]

    local results = [];
    local return_statement = [];
    local divconerrmess = "";
    
    const NUMRESULTS = 11;
    local status_length=0;
    
    local success = 0;
    
    local sleep_time = 0.1;

    while exe_status process_keys(1) loop
        fwrite [stdin, '{c:}\n', 'status'];
        [[return_statement]] = fread [stdout, '{c:*}'];

        if return_statement === "noupdate" then
        elseif return_statement === "running" then
	    [[status_length]] = fread [stdout, '{n:}'];
            for status_length loop
                [[return_statement]] = fread [stdout, '{c:*}'];
                write ['    running | {}\n', return_statement];
            endloop
        elseif return_statement === "success" then
            local name, nameValue;
            local parameter, parameterValue;
            [[name]] = fread [stdout, '{c:*}'];
            [[nameValue]] = fread [stdout, '{c:*}'];
            results = cat [results, [[name, nameValue]]];
            for NUMRESULTS loop
                [[parameter]] = fread [stdout, '{c:*}'];
                [[parameterValue]] = fread [stdout, '{n:}'];
                results = cat [results, [[parameter, parameterValue]]];
            endloop
            success = 1;
            fwrite [stdin, '{c:}\n', 'Ok'];

        elseif return_statement === "error" then
            [[return_statement]] = fread [stdout, '{c:*}'];
            if neL [return_statement, "DivCon done."] then
                divconerrmess = cat [divconerrmess, return_statement];
                [[return_statement]] = fread [stdout, '{c:*}'];
            endif
            while neL [return_statement, "DivCon done."] loop
                divconerrmess = cat [divconerrmess, "\n", return_statement];
                [[return_statement]] = fread [stdout, '{c:*}'];
            endloop;
            fwrite [stdin, '{c:}\n', 'Ok'];
        endif
        sleep sleep_time;
    endloop
    return success;
endfunction

local function InitMOEDivConQMScore[perfile,workdir,nrows,qmsopts,coreopts]

    write ['Persistent File:  {}\n', perfile];
    write ['Work Dir:  {}\n', workdir];

    //  exe_open child process inherits parent's environment.
    local process_key;
    if not MOE_BATCH then
        process_key = exe_open ['moedivconmpi', workdir, [], 1];
    else
        process_key = exe_open ['moedivconscoring', workdir, [], 0];
    endif
    
    local process_keys = [process_key];
    local exestatus = exe_status process_keys;

    local prios = exe_getpriority process_keys;
    exe_setpriority [process_keys, prios];

    local stdin = exe_stdin process_keys;
    local stdout = exe_stdout process_keys;
    local stderr = exe_stderr process_keys;

    //  Pass down the dirs, options and number of possible jobs.
    fwrite [stdin, '{c:}\n', perfile];
    fwrite [stdin, '{c:}\n', select ['PWD', 'NOPWD', qmsopts.analpwd]];
if not qboldversion then
    fwrite [stdin, '{c:}\n', select ['COMPRESSION', 'NOCOMPRESSION', 1]];
    fwrite [stdin, '{c:}\n', select ['PERSISTCOMPLEXDENSITY', 'NOPERSISTCOMPLEXDENSITY', 0]];
endif
    fwrite [stdin, '{c:}\n', HAM_KEYS(coreopts.ham)];
    fwrite [stdin, '{c:}\n', select ['NOSTANDARD', 'STANDARD', coreopts.scaling === 1]];
    fwrite [stdin, '{c:}\n', select ['FREQ', 'NOFREQ', qmsopts.freq]];
    fwrite [stdin, '{c:}\n', LIG_KEYS(qmsopts.opt)];
    fwrite [stdin, '{n:}\n', qmsopts.shift];
    fwrite [stdin, '{n:}\n', nrows];

    return [process_keys,stdin,stdout,stderr];
endfunction

local function ShutdownMOEDivConQMScore [process_keys]
    exe_kill  [process_keys(1), 0];
    exe_kill  process_keys(1);
    exe_close process_keys;
endfunction

local function SendPairForScore [stdin,stdout,recmol,ligmol,coreopts,status,nonQBtagged,rowcnt,dbkey,rowkey,numokay,warnings]

    local recchg = coreopts.recchg;
    local ligchg = coreopts.ligchg;
    local dbrowkeys = db_Entries [dbkey];
    local nrows = length dbrowkeys;
    local errmess = "";

    //  Run all error tests unless forced not to do so by user.
    local [recressets, recok, recchgok, ligressets, ligok, ligchgok, ckmsg]
        = qb_CheckChgTestDivConComplex [recmol, recchg, ligmol, ligchg,
            status.notforced, status.notforced, status.notforced,
            coreopts.testH, coreopts.testMM, 'qms',
            HAM_KEYS (coreopts.ham)];

    if alltrue [recok, recchgok, ligok, ligchgok] then
        numokay = numokay + 1;

        //  Pass the two backbones to QuantumBio's DivCon QMScore
        write ['Sending pose {} of {}\n', rowcnt, nrows];
        fwrite [stdin, '{n:}\n', rowcnt];

if qboldversion then
fwrite [stdin, '{c:}\n', recmol(1)(MOL_NAME)];
fwrite [stdin, '{c:}\n', ligmol(1)(MOL_NAME)];
fwrite [stdin, '{n:}\n', recchg];
fwrite [stdin, '{n:}\n', ligchg];
endif

        // we already did the work of figuring out which is receptor and which is ligand.
        // @todo: the divcon structure testing code changes the ressets. It is unclear if this was significant. Need to do some testing, but it seems redundent.
        recressets = mol_Create recmol;
        ligressets = mol_Create ligmol;

if not qboldversion then
        fwrite [stdin, '{c:}\n', recmol(1)(MOL_NAME)];
        fwrite [stdin, '{n:}\n', recchg];
endif
        qb_PassBackbone [stdout, stdin, recressets];
if not qboldversion then
        qb_PassValues [stdout, stdin, [] ];

        fwrite [stdin, '{c:}\n', ligmol(1)(MOL_NAME)];
        fwrite [stdin, '{n:}\n', ligchg];
endif
        qb_PassBackbone [stdout, stdin, ligressets];
if not qboldversion then
        qb_PassValues [stdout, stdin, nonQBtagged ];
endif

        warnings (rowcnt) = ckmsg;

    else
        if not alltrue [recok, ligok] then
            if tok_length ckmsg > 0 then
                errmess = cat [errmess, swrite ['Skipping!\n{}', ckmsg]];
                errmess = droplast errmess;  //drop the extra newline
            else
                errmess = cat [errmess, 
                    swrite ['Problematic molecule in {}, skipping!\n',
                    qb_GetWhich [not recok, not ligok]]];
            endif
        endif

        if not alltrue [recchgok, ligchgok] then
            errmess =  cat [errmess, 
                swrite ['Problematic charge for {}, skipping!', 
                qb_GetWhich [not recchgok, not ligchgok]]];
        endif

        qb_SaveDivConStatus [dbkey, rowkey, swrite ['Error:  {}\n', errmess]];
        write ['Skipping pose {} of {}\n', rowcnt, nrows];
        write ['QMScore Error:  {}\n', errmess];

        fwrite [stdin, '{n:}\n', 0];            //  skipping
    endif

    oDestroy uniq cat oChains cat recressets;
    oDestroy uniq cat oChains cat ligressets;
    
    return [warnings,numokay];
    
endfunction

/****************************************************************************
 *                          qb_QMScoreMPI
 *
 *  Pass all of the jobs in the database down to moedivconmpi, then collect
 *  all of the results.
 *
****************************************************************************/
global function qb_QMScoreMPI [dbpath, jobid]
qboldversion = 1;
sleep 1;
    local [osys, nsys] = SystemPush [];
//    if not MOE_BATCH then exit ['Should only be run from moebatch.']; endif
    //  Extract molecules and run options from the database environment
    if neL [fext dbpath, 'mdb'] then
        exit twrite ['{}\nis not a MOE database.', dbpath];
    endif

    if neL [ftype dbpath, 'file'] then
        exit twrite ['Unable to find the database:\n    {}', dbpath];
    endif

//    local dbkey = db_Open [dbpath, 'read-write'];
    local dbkey = dbpath;
    local [recmol, ligmol, status, coreopts, qmsopts] = qb_GetQMSEnv [dbkey];
    local ligflds = qb_GetPoseFields [];
    local recflds = qb_GetRecFields [];
    local dbrowkeys = db_Entries [dbkey];
    local nrows = db_nEntries [dbkey];
    
    local workdir = cd [];
    local pertail = fbase ftail dbpath;
    local perfile = twrite ['{}/{}.h5', workdir, pertail];
    
//    local currdir = getenv 'PWD';
//    local perpath = fpath dbpath;
//    local workdir = select [currdir, fabsname coreopts.workdir, coreopts.cwd];

    if not isnull jobid then
        workdir = twrite ['{}/{}', workdir, jobid];
        local okay = _fmkdir workdir;
        if okay === -1 then
            exit twrite ['Unable to create subdirectory:  {}\n',  workdir];
        endif
    endif

    local [process_keys,stdin,stdout,stderr] = InitMOEDivConQMScore[perfile,workdir,nrows,qmsopts,coreopts];

    // process the fields in the QMScore mdb file and strip out the stuff we added
    local [fields, field_types] = db_Fields dbkey;  
    local nonQBfields = fields | (field_types <> 'molecule');
    nonQBfields = diff [nonQBfields,totok cat [qb_GetCoreFields[], qb_GetQMS_dbFields[]] ];

    //  For each receptor/pose in the database, check tests, then send down
    //  to moedivconmpi
    qb_HamSetsInit [];
    local rowkey = 0, rowcnt = 0, numokay = 0, warnings = [];
    local recchg = coreopts.recchg;
    local ligchg = coreopts.ligchg;
    for rowkey in dbrowkeys loop
        local errmess = "", success = 0;
        rowcnt = rowcnt + 1;

        local oldstatus = qb_GetDivConStatus [dbkey, rowkey];
        if  eqL ["Success", keep [oldstatus, 7]] then
            write ['Skipping on success pose {} of {}\n', rowcnt, nrows];
            fwrite [stdin, '{n:}\n', 0];            //  skipping
            continue;
        endif

        coreopts.task = rowcnt;
        [ligmol, ligchg] = db_ReadFields [dbkey, rowkey, ligflds];
        
        if indexof [recflds(1), fields] then
            [recmol, recchg] = db_ReadFields [dbkey, rowkey, recflds];
        endif
        
        coreopts.recchg = recchg;
        coreopts.ligchg = ligchg;
        
        local nonQBtagged = tag [nonQBfields, db_ReadFields [dbkey,rowkey,nonQBfields]];
        
        [warnings,numokay] = SendPairForScore [stdin,stdout,recmol,ligmol,coreopts,status,nonQBtagged,rowcnt,dbkey,rowkey,numokay,warnings];

    endloop

    //  Abort if there are no results to collect
    if numokay === 0 then
        fwrite [stdin, '{c:}\n', 'Ok'];
        ShutdownMOEDivConQMScore[process_keys];
//        db_Close dbkey;
        exit [];
    endif

    //  Collect and store results

    if not MOE_BATCH then
        ManageMOEDivConMPI[stdout,stdin,process_keys,warnings,dbkey,numokay];
    else
        ManageMOEDivConScoring[stdout,stdin,process_keys,warnings,dbkey,numokay];
    endif

    //  Look for error messages from stderr.
    errmess = "";
    local [[newerror]] = fread [stderr, '{c:*}'];
    while length newerror > 0 loop
        // Hack!  Skip openmpi ignored error messages
        local errstrs = wordsplit [newerror, "()"];
        local errtoks = app token errstrs;
        local idx = indexof ['ignored', errtoks];
        if idx === 0 then
            write ['MOEDivCon: {}\n', newerror];
            errmess = cat [newerror, errmess];
        endif

        [[newerror]] = fread [stderr, '{c:*}'];
    endloop

    ShutdownMOEDivConQMScore[process_keys];
    
//    db_Close dbkey;
    SystemPop [osys, nsys];
endfunction


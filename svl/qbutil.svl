#svl

//    qbutil.svl    Utilities to support data management

#set title   'QuantumBio Utilities'
#set class   'QuantumBio'
#set version '2009.01'

function _Atoms;


//  Data fields are in the order in which they are returned by Divcon.

const POSE_FIELD = 'Ligand/Pose';
const REC_FIELD = 'Receptor';
const STATUS_FIELD = 'Status';

const QMS_DATA_TAGS =
    [
    "LIGAND",
    "TOTAL SCORE",
    "GAS PHASE HEAT OF FORMATION",
    "ELECTROSTATIC SOLVATION",
    "ATTRACTIVE LENNARD JONES",
    "SOLVATION ENTROPY",
    "VIBRATIONAL ENTROPY",
    "ELECTRONIC INTERACTION ENERGY",
    "MRM STERIC ENERGY",
    "MRM ELECTROSTATIC ENERGY",
    "MRM SOLVATION ENERGY",
    "MRM TOTAL ENERGY"
    ];
 
const QMS_DB_FIELDS =
    [
    POSE_FIELD,
    'QMScore',
    'dHf_g',
    'Solv_elec',
    'LJ_att',
    'S_solv',
    'S_vib',
    'E_eInt',
    'MRMScore',
    'E_stericMRM',
    'E_elecMRM',
    'E_solvMRM'
    ];


// Environment tags
const LIGAND = 'ligand';
const TARGET = 'target';
const OPTIONS = 'options';

//  Local Functions

/****************************************************************************
 *                          SplitReceptor
 *
 *  Given a set of receptor atoms, returns subsets which represent
 *  individual molecules (connected pieces) in the receptor.
 *
 ****************************************************************************/
local function SplitReceptor [receptoratoms]

    if receptoratoms === [] then return []; endif

    local atomsets = [];
    local [recidx, reccnt] = sac aMoleculeNumber receptoratoms;
    if length reccnt > 1 then
        receptoratoms = receptoratoms [recidx];
        atomsets = split [receptoratoms, reccnt];
    else
        atomsets = [receptoratoms];
    endif

    return atomsets;

endfunction

//  Global Functions

/****************************************************************************
 *                          qb_AtomsToMols
 *
 *  Given the set of atoms in the MOE Window, identify and separate the
 *  ligand, then split up the receptor atoms into individual molecules.
 *  Returns the extracted molecules.
 *
 ****************************************************************************/
global function qb_AtomsToMols []

    local complexatoms = Atoms [];
    if length complexatoms === 0 then
        return [[], [], 'No molecular complex loaded in MOE Window.'];
    endif

    local recatoms, ligatoms;
    const LIGXNAME = 'LIGX_LIGAND';
    local colnames = oCollections [];

    if anytrue eqE [LIGXNAME, colnames] then
        ligatoms  = cat oAtoms oGetCollection LIGXNAME;
        ligatoms = join [ligatoms, complexatoms];
    endif

    if length ligatoms === 0 then
        ligatoms  = _Atoms '$$ligand';
    endif

    if length ligatoms === 0 or length ligatoms >= length complexatoms then
        return [[], [], 'No ligand was recognized.\n  Use LigX to define it.'];
    endif

    if 1 <> length uniq aMoleculeNumber ligatoms then
        return [[], [], 'Ligand has to be a single molecule.'];
    endif

    recatoms = diff [complexatoms, ligatoms];
    local recsets = SplitReceptor [recatoms];

    if recsets === [] then
        return [[], [], 'No receptor was recognized.'];
    endif

    local ligmol = mol_Extract ligatoms;
    local recmols = app mol_Extract recsets;

    return [recmols, ligmol, []];

endfunction


/****************************************************************************
 *                          qb_CopyPoseDB
 *
 *  Copy the Poses database into the QMScore output database.
 *
 ****************************************************************************/
global function qb_CopyPoseDB [resultskey, poseskey]

    local mess = '';
    local [fields, ftypes] = db_Fields poseskey;
    local molfield = fields | (ftypes == 'molecule');

    if 1 <> length molfield then
        mess = 'The poses database has\n'
            'more than one molecule field.';
        return mess;
    endif

    //  HACK alert:  temporarily renames mol field to make copying easier
    db_RenameField [resultskey, POSE_FIELD, molfield];
    apt db_EnsureField [resultskey,  fields, ftypes];

    local rowkey = 0;

    while rowkey = db_NextEntry [poseskey, rowkey] loop
        local rowdata = db_Read [poseskey, rowkey];
        db_Write [resultskey, 0, rowdata];
    endloop

    db_RenameField [resultskey, molfield, POSE_FIELD];

    return mess;
endfunction

/****************************************************************************
 *                          qb_CopyRecPoseDB
 *
 *  Copy the Receptors and Poses databases into the QMScore output database.
 *
 *  HACK alert:  temporarily renames mol fields to make copying easier.
 *
****************************************************************************/
global function qb_CopyRecPoseDB [resultskey, recskey, poseskey]

    local mess = '';
    if db_nEntries recskey <> db_nEntries poseskey then
        mess = 'The receptor and pose databases\n'
            'have different number of entries.';
        return mess;
    endif

    local [recfields, recftypes] = db_Fields recskey;
    local recmolfield = recfields | (recftypes == 'molecule');
    if 1 <> length recmolfield then
        mess = 'The ligand poses database has\n'
            'more than one molecule field.';
        return mess;
    endif

    db_RenameField [resultskey, REC_FIELD, recmolfield];
    apt db_EnsureField [resultskey, recfields, recftypes];

    local recrowkey = 0;
    while recrowkey = db_NextEntry [recskey, recrowkey] loop
        local recrowdata = db_Read [recskey, recrowkey];
        db_Write [resultskey, 0, recrowdata];
    endloop

    db_RenameField [resultskey, recmolfield, REC_FIELD];

    local [posefields, poseftypes] = db_Fields poseskey;
    local posemolfield = posefields | (poseftypes == 'molecule');
    if 1 <> length posemolfield then
        mess = 'The pose database has\n'
            'more than one molecule field.';
        return mess;
    endif

    db_RenameField [resultskey, POSE_FIELD, posemolfield];
    apt db_EnsureField [resultskey, posefields, poseftypes];

    local poserowkey = 0;
    local resultrowkey = 0;
    while poserowkey = db_NextEntry [poseskey, poserowkey] loop
        resultrowkey = db_NextEntry [resultskey, resultrowkey];
        local poserowdata = db_Read [poseskey, poserowkey];
        db_Write [resultskey, resultrowkey, poserowdata];
    endloop

    db_RenameField [resultskey, posemolfield, POSE_FIELD];

    return mess;
endfunction

/****************************************************************************
 *                          qb_GetPoseField
 *
 ****************************************************************************/
global function qms_GetPoseField []

    return POSE_FIELD;

endfunction

/****************************************************************************
 *                          qb_GetRecField
 *
 ****************************************************************************/
global function qms_GetRecField []

    return REC_FIELD;

endfunction


/****************************************************************************
 *                          qb_GetEnv
 *
 *  Get the molecules (ligand and receptor) and options from the QMScore 
 *  database.
 *
 ****************************************************************************/
global function qms_GetEnv [dbkey]
    local tgttok = db_GetEnv [dbkey, TARGET];
    local [[tgtmols]] = sread [string tgttok, '{v}'];
    local ligtok = db_GetEnv [dbkey, LIGAND];
    local [[ligmol]] = sread [string ligtok, '{v}'];
    local opttok = db_GetEnv [dbkey, OPTIONS];
    local [[options]] = sread [string opttok, '{v}'];

    return [tgtmols, ligmol, options];

endfunction

/****************************************************************************
 *                          qms_SaveDBRow
 *
 *  Save a row of data in the QMScore database.
 *
 ****************************************************************************/
global function qms_SaveDBRow [mdbkey, rowkey, ligand, scoredata]

    if alltrue (DATA_TAGS === app first scoredata) then
        local rowdata = tag [POSE_FIELD, [ligand]];
        rowdata = cat [rowdata, tag [dropfirst DB_FIELDS, 
            dropfirst app second scoredata]];
        db_Write [mdbkey, rowkey, rowdata];
    endif

endfunction

/****************************************************************************
 *                          qms_SaveEnv
 *
 *  Save the molecules (ligand and receptor) and options in the QMScore
 *  database.
 *
 ****************************************************************************/
global function qms_SaveEnv [dbkey, tgtmols, ligmol, options]

    db_SetEnv [dbkey, TARGET, twrite ['{v}', tgtmols]];
    db_SetEnv [dbkey, LIGAND, twrite ['{v}', ligmol]];
    db_SetEnv [dbkey, OPTIONS, twrite ['{v}', options]];

endfunction

/****************************************************************************
 *                          qms_SaveScore
 *
 *  Save just the score data in the QMScore database.
 *
 ****************************************************************************/
global function qms_SaveScore [mdbkey, rowkey, scoredata]

    if alltrue (DATA_TAGS === app first scoredata) then
        db_Write [mdbkey, rowkey, tag [dropfirst DB_FIELDS, 
            dropfirst app second scoredata]];
    endif

endfunction

/****************************************************************************
 *                          qms_SaveStatus
 *
 *  Save the error/status message for the given row.
 *
 ****************************************************************************/
global function qms_SaveStatus [dbkey, rowkey, message]

    local fielddata = tag [ERR_FIELD, [message]];
    db_Write [dbkey, rowkey, fielddata];

endfunction

/****************************************************************************
 *                          qms_SetErrField
 *
 *  Ensure that the error/status field is present.
 *
 ****************************************************************************/
global function qms_SetErrField [dbkey]

    db_EnsureField [dbkey, ERR_FIELD, 'char'];

endfunction

/****************************************************************************
 *                          qms_SetFields
 *
 *  Ensure that the required fields are present.
 *
 ****************************************************************************/
global function qms_SetFields [dbkey, addreceptor]

    if addreceptor then
        db_EnsureField [dbkey, REC_FIELD, 'molecule'];
    endif

    db_EnsureField [dbkey, POSE_FIELD, 'molecule'];
    apt db_EnsureField [dbkey, dropfirst DB_FIELDS, 'double'];

endfunction

/****************************************************************************
 *                          qms_SetRecField
 *
 *  Ensure that the receptor field is present.
 *
 ****************************************************************************/
global function qms_SetRecField [dbkey]

    db_EnsureField [dbkey, REC_FIELD, 'moleclule'];

endfunction


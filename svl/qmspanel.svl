#svl
//    qmspanel.svl    User-interface entrypoint to QMScore calculations

#set title   'QMScore Panel'
#set class   'QM'
#set version '2009.01'
#set main    'qms_SetupPanel'


function qb_AtomsToMols;

function qms_CopyPoseDB;
function qms_CopyRecPoseDB;
function qms_GetEnv;
function qms_GetPoseField;
function qms_SaveScore;
function qms_SaveStatus;
function qms_SaveEnv;
function qms_SetErrField;
function qms_SetFields;

function qms_Score;
function qms_ScoreBatch;


const OPT_TAGS =
    [
    'mode',
    'pwd',
    'workdir',
    'scoredb',
    'posedb',
    'recdb',
    'ham',
    'freq',
    'opt',
    'task'
    ];

/*  NOTE:  If you change the Option lists here, you need to update the
 *         default indices below and the Keys in qmsinterface.svl.
 */

const RUN_MODES =
    [
    'One-to-One',
    'One-to-Many',
    'Many-to-Many'
    ];

const HAMILTONIANS =
    [
    'AM1',
    'MNDO',
    'MNDO/d',
    'PDDG-PM3',
    'PM3',
    'PM6'
    ];

const LIG_OPTS =
    [
    'none',
    'in isolation',
    'in complex'
    ];

/****************************************************************************
 *                          SetUpRun
 *
 *  Create the output database for storing QMScore results and ensure that
 *  the required fields are present.  Store the molecules and run options 
 *  in the DB environment.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
 ****************************************************************************/
local function SetUpRun [opts]

    local qmskey = db_Open [opts.scoredb, 'create'];
    qms_SetFields [qmskey, opts.mode === 'Many-to-Many'];

    if opts.mode === 'One-to-One' or opts.mode === 'One-to-Many' then
        local [recset, ligand, errmess] = qb_AtomsToMols [];
        if recset === [] or ligand === [] then
            Warning [errmess];
            exit [];
        endif

        qms_SaveEnv [qmskey, recset, ligand, opts];
    else
        qms_SaveEnv [qmskey, [], [], opts];
    endif

    if opts.mode === 'One-to-One' then
        local posedata = tag [qms_GetPoseField [], [ligand]];
        db_Write [qmskey, 0, posedata];

    else
        local posekey = db_Open [opts.posedb, 'read'];
        if qmskey === posekey then
            Warning twrite ['{} and {}\n are the same database', 
                opts.scoredb, opts.posedb];
            exit [];
        endif

        if opts.mode === 'One-to-Many' then
            qms_CopyPoseDB [qmskey, posekey];
        else
            local reckey = db_Open [opts.recdb, 'read'];
            if qmskey === reckey then
                Warning twrite ['{} and {}\n are the same database', 
                    opts.scoredb, opts.recdb];
                exit [];
            endif

            qms_CopyRecPoseDB [qmskey, reckey, posekey];
            db_Close reckey;
        endif

        db_Close posekey;
    endif

    qms_SetErrField [qmskey];

    return qmskey;
endfunction

/****************************************************************************
 *
 *                          qms_SetupPanel
 *
 ****************************************************************************/
global function qms_SetupPanel [cfg, parent]

    if MOE_BATCH then return [];
    endif

    parent = add parent;

    local wkey = WindowCreate
        [
        name: 'panel', 
        title: 'QMScore',
        windowName: 'QMScorePanel',
        text: ['Run', 'Save', 'Cancel'],
        onTrigger: ['validate', 'validate', 'return'],
        bubbleHelp: ['Execute QMScore from MOE Window.',
            'Save run parameters in database\n'
            'for later execution on cluster.', ''],

        Hbox :
            [
            extendH: 1,
            FSBText :
                [
                name: 'scoredb', len: 40, extendH: 1, title: 'Output DB:',
                mode: 'saveAs', allowBlank: 0,
                bubbleHelp:
                    'The name of the output database that will hold\n'
                    'the run paramaters and scoring results.'
                ],
            Button : [ name: 'browse_scoredb', text: 'Browse...' ]
            ],

        Separator : [flushLeft:1, extendH:1, margin:1],

        Hbox :
            [
            extendH: 1,
            Text :
                [
                name: 'workdir', len: 40, extendH: 1, title: 'Working Dir:',
                type: 'char', allowBlank: 0, onTrigger: 'return',
                shortcut: ['~', '~/tmp', '.', '/tmp'],
                bubbleHelp:
                    'The name of the working directory for storing\n'
                    'QB Divcon intermediate calculations.  The\n'
                    'absolute path to the specified directory will\n'
                    'be stored and used at execution time.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Checkbox :
                [
                name: 'pwd', text: 'Use PWD', onTrigger: 'return', 
                bubbleHelp:
                    'Use the PWD environment variable at\n'
                    'run time to determine working directory.'
                ]
            ],

        Vbox :
            [
            Option :
                [
                name: 'ham', title: 'Hamiltonian:', text: HAMILTONIANS,
                type: 'int', minWidth: 11,
                bubbleHelp:
                    ''
                ],
            Hbox :
                [
                extendH: 1,
                Option :
                    [
                    name: 'opt', title: 'Ligand Optimization:', text: LIG_OPTS,
                    type: 'int', minWidth: 11, extendH: 1,
                    bubbleHelp:
                        'A QM-based ligand optimization can be performed\n'
                        'prior to scoring. This optimization may occur\n'
                        'either while the ligand is docked within the target\n'
                        'or while the ligand is separate from the target.\n'
                        'Warning: this optional step will significantly\n'
                        'increase the CPU cost of the calculation.'
                    ],
                Separator : 
                    [
                    vertical:0, shadow:'noline', extendH: 1, margin:1
                    ],
                Checkbox :
                    [
                    name: 'freq', text: 'Frequency',
                    bubbleHelp:
                        'Perform frequency calculation to determine ligand\n'
                        'entropy in score function.  Warning: may increase\n'
                        'CPU cost of the calculation.'
                    ]
                ]
            ],


        Separator : [flushLeft:1, extendH:1, margin:1],

        Hbox :
            [
            Radio :
                [
                name: 'mode', text: RUN_MODES, columns: 3, minWidth: 12, 
                extendH: 1, onTrigger: 'return', title: 'Mapping Mode:',
                type: 'char',
                bubbleHelp:
                    'The mapping mode of receptors to ligand/poses:\n'
                    '  One ligand docked into one receptor.\n'
                    '  Many ligand poses docked into the same receptor.\n'
                    '  Many ligand poses docked into its own receptor.'
                ]
            ],

        Hbox :
            [
            name: 'posebox', extendH: 1, sensitive: 0,
            FSBText :
                [
                name: 'posedb', len: 40, extendH: 1, title: 'Ligand/Pose DB:',
                mode: 'open', allowBlank: 0,
                bubbleHelp:
                    'The name of the input database that holds\n'
                    'the ligand poses (and possibly scores).'
                ],
            Button : [ name: 'browse_posedb', text: 'Browse...' ]
            ],

        Hbox :
            [
            name: 'recbox', extendH: 1, sensitive: 0,
            FSBText :
                [
                name: 'recdb', len: 40, extendH: 1, title: 'Receptor DB:',
                mode: 'open', allowBlank: 0,
                bubbleHelp:
                    'The name of the input database that holds\n'
                    'the receptors.'
                ],
            Button : [ name: 'browse_recdb', text: 'Browse...' ]
            ],

        Separator : [flushLeft:1, extendH:1, margin:1]
        ];

    // ---------------------- embedded functions begin ----------------------

    function CheckWD [dirname]
        local wdpath = fabsname dirname;
        local ft = ftype wdpath;
        if ft === '' then
            Warning twrite ['{}\n does not exist.', wdpath];
            return 0;
        elseif ft === 'dir' then
            return 1;
        endif

        Warning twrite ['{}\n is not a directory.', wdpath];
        return 0;
    endfunction

    function RunCalc [dbkey]
        local msgkey = Message [0, 'QMScore is running ...'];
        sleep -1;    // Allow parent to close input window.

        local [recset, ligand, options] = qms_GetEnv [dbkey];
        local [results, errmess] = qms_Score [recset, ligand, options];

        local rowkey = first db_Entries [dbkey];
        if results === [] then
            if errmess === [] or errmess === '' then
                qms_SaveStatus [dbkey, rowkey, "Error:  Unknown error!"];
                write ['QMScore Error:  Unknown error!\n'];
            else
                qms_SaveStatus [dbkey, rowkey, 
                    swrite ['Error:  {}', errmess]];
                write ['QMScore Error:  {}\n', errmess];
            endif
        else
            qms_SaveScore [dbkey, rowkey, results];
            qms_SaveStatus [dbkey, rowkey, "Success"];
        endif

        Message [msgkey, 'QMScore is done.'];

        return;
    endfunction

    // ----------------------- embedded functions end -----------------------

    local btid, browsetasks = [];
    local options = []; 
    local qmskey = 0;
    local prevwd = '';

    WindowSetData [wkey, [scoredb: 'qmscore.mdb', pwd:0, workdir: '~',
        ham: 5, opt:1, freq: 0]];
    WindowSetAttr [wkey, [freq: [sensitive: 0],
         workdir: [sensitive: 1, allowBlank: 0],
         posebox: [sensitive: 0], posedb: [allowBlank: 1],
         recbox: [sensitive: 0], recdb: [allowBlank: 1]]];

    WindowShow [wkey, 1];
    loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'mode' then
            if vals.mode === 'One-to-One' then
                WindowSetAttr [wkey, [posebox: [sensitive: 0],
                    posedb: [allowBlank: 1], recbox: [sensitive: 0], 
                    recdb: [allowBlank: 1], panel:[sensitive: [1,1,1]]]];
            elseif vals.mode === 'One-to-Many' then
                WindowSetAttr [wkey, [posebox: [sensitive: 1],
                    posedb: [allowBlank: 0],recbox: [sensitive: 0], 
                    recdb: [allowBlank: 1], panel:[sensitive: [0,1,1]]]];
            elseif vals.mode === 'Many-to-Many' then
                WindowSetAttr [wkey, [posebox: [sensitive: 1],
                    posedb: [allowBlank: 0], recbox: [sensitive: 1], 
                    recdb: [allowBlank: 0], panel:[sensitive: [0,1,1]]]];
            endif

        elseif trig === 'pwd' then
            if vals.pwd === 1 then
                prevwd = vals.workdir;
                WindowSetAttr [wkey, [workdir: [sensitive: 0, allowBlank: 1]]];
                WindowSetData [wkey, [workdir: '']];
            else
                WindowSetAttr [wkey, [workdir: [sensitive: 1, allowBlank: 0]]];
                WindowSetData [wkey, [workdir: prevwd]];
            endif

        elseif trig === 'workdir' then
            local flag = CheckWD [vals.workdir];
            if not flag then continue; endif

        elseif trig === 'browse_scoredb' then
            btid = run ['fbrowse.svl', [trig, wkey, 'Select QMScore DB File', 
                'none', '*.mdb', 'scoredb']];
        if btid then browsetasks = append [browsetasks, btid]; endif

        elseif trig === 'browse_posedb' then
            btid = run ['fbrowse.svl', [trig, wkey, 'Select Pose DB File', 
                'open', '*.mdb', 'posedb']];
        if btid then browsetasks = append [browsetasks, btid]; endif

        elseif trig === 'browse_recdb' then
            btid = run ['fbrowse.svl', [trig, wkey, 'Select Receptor DB File', 
                'open', '*.mdb', 'recdb']];
        if btid then browsetasks = append [browsetasks, btid]; endif

       elseif trig === 'panel' then
            local tskttl = task_title -1;
            if vals.panel === 'Cancel' then 
                break;

            elseif vals.panel === 'Run' then
                if not istrue CheckWD [vals.workdir] then continue; endif

                if second task_fork [] === 'child' then
                    task_settitle [-1, tskttl];

                    options = tag [OPT_TAGS, [vals.mode, vals.pwd,
                      fabsname vals.workdir, fabsname vals.scoredb, [], [],
                      vals.ham, vals.freq, vals.opt, []]];

                    qmskey = SetUpRun [options];
                    RunCalc [qmskey];
                    dbv_Open db_Filename qmskey;
                    db_Close qmskey;
                    exit [];
                else
                    break;
                endif

            elseif vals.panel === 'Save' then
                if not istrue CheckWD [vals.workdir] then continue; endif

                if second task_fork [] === 'child' then
                    task_settitle [-1, tskttl];

                    options = tag [OPT_TAGS, [vals.mode, vals.pwd,
                        fabsname vals.workdir, fabsname vals.scoredb,
                        fabsname vals.posedb, fabsname vals.recdb, vals.ham,
                        vals.freq, vals.opt, []]];
                    qmskey = SetUpRun [options];
                    dbv_Open db_Filename qmskey;
                    db_Close qmskey;
                    exit [];
                else
                    break;
                endif
            endif
        endif
    endloop

    task_kill browsetasks;
    WindowDestroy wkey;

endfunction

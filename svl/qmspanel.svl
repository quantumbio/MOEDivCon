#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
	
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

//    qmspanel.svl    User-interface entrypoint to QMScore calculations

#set title   'QuantumBio QMScore Panel'
#set class   'QuantumBio'
#set version '2010.02'
#set main    'qb_QMScoreSetupPanel'


function qb_CoreHandler;
function qb_GetCoreEnv;
function qb_GetCorePanel;
function qb_GetDefaultsCore;
function qb_GetDefaultsStatus;
function qb_GetEnvApp;
function qb_GetEnvTag;
function qb_GetWhich;
function qb_InitCorePanel;
function qb_IsModeOneToOne;
function qb_IsShowingAllPoses;
function qb_ResetLigand;
function qb_LoadCoreScoreDB;
function qb_SaveDivconStatus;
function qb_SetAppStatus;
function qb_SetUpScoreDB;
function qb_TagCoreVals;
function qb_UpdateCorePanel;
function qb_VerifyDivcon;

function qb_QMScore;
function qb_QMScoreBatch;

//  Data tags are in the order in which they are returned by Divcon.

const QMS_DATA_TAGS =
    [
    "LIGAND",
    "TOTAL SCORE",
    "GAS PHASE HEAT OF FORMATION",
    "ELECTROSTATIC SOLVATION",
    "ATTRACTIVE LENNARD JONES",
    "SOLVATION ENTROPY",
    "VIBRATIONAL ENTROPY",
    "ELECTRONIC INTERACTION ENERGY",
    "MRM STERIC ENERGY",
    "MRM ELECTROSTATIC ENERGY",
    "MRM SOLVATION ENERGY",
    "MRM TOTAL ENERGY"
    ];
 
const QMS_NUM_FIELDS =
    [
    'QMScore',
    'dHf_g',
    'Solv_elec',
    'LJ_att',
    'S_solv',
    'S_vib',
    'E_eInt',
    'MRMScore',
    'E_stericMRM',
    'E_elecMRM',
    'E_solvMRM'
    ];

/*  NOTE:  If you change the Option lists here, you need to update the
 *         Keys in qmsinterface.svl.
 */

const QMSCORE_OPT_DEFAULTS =
    [
    ['freq',         0             ],
    ['opt',          1             ],
    ['shift',        0.0           ],
    ['analpwd',      0             ]       //  Generate PWD row data

    ];

const LIG_OPTS =
    [
    'none',
    'free',
    'bound'
    ];

const HEADER = 
    [
    name: 'panel', 
    title: 'QMScore',
    windowName: 'QMScorePanel',
    text: ['Run', 'Save', 'Load', 'Close'],
    onTrigger: ['validate', 'validate', 'return', 'return'],
    bubbleHelp: ['Execute QMScore from MOE Window.',
        'Save run parameters in database\n'
        'for later execution on cluster.', 
        'Load run parameters from a QMScore database.', 
        '']
    ];

const PANEL =
    [
    Vbox :
        [
        Hbox :
            [
            extendH: 1,
            Option :
                [
                name: 'opt', title: 'Ligand Optimization:', text: LIG_OPTS,
                type: 'int', minWidth: 5, extendH: 1,
                bubbleHelp:
                    'A QM-based ligand optimization can be performed\n'
                    'prior to scoring. This optimization may occur\n'
                    'either while the ligand is docked within the target\n'
                    'or while the ligand is separate from the target.\n'
                    'Warning: this optional step will significantly\n'
                    'increase the CPU cost of the calculation.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 1, margin:1
                ],
            Text :
                [
                name: 'shift', title: 'Shift:', len: 20, extendH: 1, 
                type: 'real', allowBlank: 0,
                shortcut: ['0.0', '2.0', '4.0', '8.0', '16.0'],
                bubbleHelp:
                    'Initial dynamic level shift (eV).'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 1, margin:1
                ],
            Checkbox :
                [
                name: 'freq', text: 'Frequency',
                bubbleHelp:
                    'Perform frequency calculation to determine ligand\n'
                    'entropy in score function.  Warning: may increase\n'
                    'CPU cost of the calculation.'
                ]
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        extendH: 1,
        name: 'analbox',
        Checkbox :
            [
            name: 'analpwd', text: 'PWD', title: 'Analysis:',
            bubbleHelp:
                'Perform pair-wise decomposition analysis\n'
                'after the QMScore calculations.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 1, margin:1
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1]
    ];

//  Local Functions

/****************************************************************************
 *                          LoadDB
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
local function LoadDB [dbpath]

    local [dbkey, recset, ligand, status, coreopts, c, mess] = 
        qb_LoadCoreScoreDB [dbpath, 'qmscore'];
    if dbkey === 0 and status === [] and coreopts === [] then
        Warning mess;
        exit [];
    endif

    local qmsopts = qb_GetEnvApp [dbkey];
    qmsopts = tagcat [qmsopts, tag tr QMSCORE_OPT_DEFAULTS];

    return [dbkey, recset, ligand, status, coreopts, qmsopts];
endfunction

function qb_GetQMSEnv;
function qb_SaveQMScore;

/****************************************************************************
 *                          RunCalc
 *
 *  Run the One-to-One scoring from the MOE Window.
 *
 *  WARNING:  breaking into core
 *
 ****************************************************************************/
local function RunCalc [dbkey]
    local msgkey = Message [0, 'QMScore is running ...'];
    sleep -1;    // Allow parent to close input window.

    local rowkey = first db_Entries [dbkey];
    local [recset, ligand, status, coreopts, qmsopts] = qb_GetQMSEnv [dbkey];

    local workdir;
    if coreopts.cwd === 1 then
        workdir = getenv 'PWD';
    else
        workdir = fabsname coreopts.workdir;
    endif

    coreopts.workdir = workdir;
    write ['Work Dir:  {}\n', workdir];

    local [results, errmess] = qb_QMScore [recset, ligand, coreopts, qmsopts,
        status.notforced];

    if results === [] then
        if errmess === [] or errmess === '' then
            qb_SaveDivconStatus [dbkey, rowkey, "Error:  Unknown error!\n"];
            write ['QMScore Error:  Unknown error!\n'];
        else
            qb_SaveDivconStatus [dbkey, rowkey, 
                swrite ['Error:  {}\n', errmess]];
            write ['QMScore Error:  {}\n', errmess];
        endif
    else
        qb_SaveQMScore [dbkey, rowkey, results];
        local sucmess = "Success";
        if not isnull errmess then
            sucmess = cat [sucmess, "-warnings!\n", errmess];
        else
            sucmess = cat [sucmess, "\n"];
        endif

        qb_SaveDivconStatus [dbkey, rowkey, sucmess];
    endif

    Message [msgkey, 'QMScore is done.'];

    return;
endfunction

function qb_GetPoseFields;

/****************************************************************************
 *                          RunOneToManyCalc
 *
 *  Execute QMScore for each row of the scoring database.
 *
 *  WARNING:  breaking into core
 *
 ****************************************************************************/
global function RunOneToManyCalc [oldkey]

    if MOE_BATCH then return; endif

    if oldkey === 0 then
        Warning 'The QMScore database hasn\'t been created.';
        return;
    endif

    local dblist = dbv_KeyList [];
    if not isnull dblist and not isnull indexof [oldkey, dblist] then
        Warning 'The QMScore database is still open.';
        return;
    endif

    //  Extract molecules and run options from the database environment
    local dbkey = db_Open [oldkey, 'read-write'];
    local [recmols, l, status, coreopts, qmsopts] = qb_GetQMSEnv [dbkey];

    local msgkey = 0;
    local workdir;
    if coreopts.cwd === 1 then
        workdir = getenv 'PWD';
    else
        workdir = fabsname coreopts.workdir;
    endif

    coreopts.workdir = workdir;
    write ['Work Dir:  {}\n', workdir];

    //  For each ligand pose in the database, calculate QM score.
    local nrows = db_nEntries dbkey;
    local rowkey = 0, rowcnt = 0;
    local poseflds = qb_GetPoseFields [dbkey];

    while rowkey = db_NextEntry [dbkey, rowkey] loop
        rowcnt = rowcnt + 1;
        msgkey = Message [msgkey, twrite ['Scoring pose {} of {}\n', rowcnt,
            nrows]];

        coreopts.task = rowcnt;
        local [posemol, posechg] = db_ReadFields [dbkey, rowkey, poseflds];
        coreopts.ligchg = posechg;
        local [results, errmess] = qb_QMScore [recmols, posemol, coreopts,
            qmsopts, status.notforced];

        if results === [] then
            if errmess === [] or errmess === '' then
                errmess = "Unknown error!";
            endif
            qb_SaveDivconStatus [dbkey, rowkey,
                swrite ['Error:  {}\n', errmess]];
            write ['QMScore Error on pose {}:\n    {}\n', rowcnt, errmess];
            msgkey = Message [msgkey, 
                twrite ['QMScore Error on pose {}:\n    {}\n', rowcnt,
                    errmess]];
            sleep 3;
        else
            qb_SaveQMScore [dbkey, rowkey, results];
            local sucmess = "Success";
            if not isnull errmess then
                sucmess = cat [sucmess, "-warnings!\n", errmess];
            else
                sucmess = cat [sucmess, "\n"];
            endif
            qb_SaveDivconStatus [dbkey, rowkey, sucmess];
        endif
    endloop

    db_Close dbkey;

endfunction


//  Global Functions

/****************************************************************************
 *                          qb_GetQMSEnv
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
global function qb_GetQMSEnv [dbkey]

    local [recset, ligand, status, coreopts, c] = qb_GetCoreEnv [dbkey];
    local qmsopts = qb_GetEnvApp [dbkey];
    qmsopts = tagcat [qmsopts, tag tr QMSCORE_OPT_DEFAULTS];

    return [recset, ligand, status, coreopts, qmsopts];
endfunction

/****************************************************************************
 *                          qb_SaveQMScore
 *
 *  Save just the score data in the QMScore database.
 *
 ****************************************************************************/
global function qb_SaveQMScore [mdbkey, rowkey, scoredata]

    if alltrue (QMS_DATA_TAGS === app first scoredata) then
        db_Write [mdbkey, rowkey, tag [QMS_NUM_FIELDS, 
            dropfirst app second scoredata]];
    endif

endfunction

/****************************************************************************
 *
 *                          qb_QMScoreSetupPanel
 *
 ****************************************************************************/
global function qb_QMScoreSetupPanel []

    static status;                     //  Shared with child tasks.

    if MOE_BATCH then return; endif
    if WindowShow ['QMScorePanel', 1] then return; endif

    local coreopts = [], qmsopts = [], browsetasks = [], dbkey = 0;
    status = qb_GetDefaultsStatus [];
    status = qb_SetAppStatus [status, 'qms'];
    local coredflts = qb_GetDefaultsCore [];
    local appdflts = tag tr QMSCORE_OPT_DEFAULTS;
    coredflts = tagpoke [coredflts, 'scoredb', 'qmscore.mdb'];

    local wkey = WindowCreate cat [HEADER, qb_GetCorePanel [], PANEL];
    status = qb_InitCorePanel [wkey, status, coredflts];
    WindowSetData [wkey, appdflts];
    WindowShow [wkey, 1];

    loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'panel' then
            if vals.panel === 'Close' then 
                break;

            elseif vals.panel === 'Load' then 
                if second task_fork [master: 'parent',
                        statics:'share'] === 'child' then
                    task_prio 0;

                    local dbpath = FilePrompt [title: 'Load Database', 
                        filter: '*.mdb', allowEmptyList: 0];
                    if not isnull dbpath then
                        if neL [ftype dbpath, 'file']
                                or neL [fext dbpath, 'mdb'] then
                            Warning 'The QMScore database doesn\'t exist.';
                            exit [];
                        endif

                        local [ldkey, ldrec, ldlig, ldsts, ldcoreopts,
                            ldqmropts] = LoadDB [dbpath];

    	                Close [force:1];
                        if neL [ldrec, []] and neL [ldlig, []] then
                            local ldligmol = mol_Create ldlig;
                            local ldligatoms = cat oAtoms ldligmol;
                            oSetCollection ['QB_LIGAND', ldligatoms];
                            aSetNucleusLook [ldligatoms, 'small-sphere'];
                            aSetBondLook [ldligatoms, 'cylinder'];
                            mol_Create ldrec;
        	                View [];
                        endif

                        dbv_Open db_Filename ldkey;
                        db_Close ldkey;
                        status = qb_UpdateCorePanel [wkey, ldsts, ldcoreopts];
                        WindowSetData [wkey, ldqmropts];
                    endif

                    exit [];
                endif

            elseif vals.panel === 'Run' then

                if qb_IsShowingAllPoses [vals] then
                    vals = qb_ResetLigand [wkey, vals];
                endif

                if second task_fork [statics:'share'] === 'child' then

                    status = qb_VerifyDivcon [wkey, status, vals];
                    if not status.verified then exit []; endif

                    coreopts = qb_TagCoreVals [vals];
                    qmsopts = tag [first tr QMSCORE_OPT_DEFAULTS, [
                        vals.freq, vals.opt, vals.shift,
                        vals.analpwd]];

                    dbkey = qb_SetUpScoreDB [status, coreopts, qmsopts, 
                        [], QMS_NUM_FIELDS, 'qmscore', 0];

                    if qb_IsModeOneToOne [coreopts] then
                        RunCalc [dbkey];
                    else
                        RunOneToManyCalc [dbkey];
                    endif

                    dbv_Open db_Filename dbkey;
                    db_Close dbkey;
                    exit [];
                else
                    break;
                endif

            elseif vals.panel === 'Save' then

                if qb_IsShowingAllPoses [vals] then
                    vals = qb_ResetLigand [wkey, vals];
                endif

                if second task_fork [statics:'share'] === 'child' then

                    status = qb_VerifyDivcon [wkey, status, vals];
                    if not status.verified then exit []; endif

                    coreopts = qb_TagCoreVals [vals];
                    qmsopts = tag [first tr QMSCORE_OPT_DEFAULTS, [
                        vals.freq, vals.opt, vals.shift,
                        vals.analpwd]];

                    dbkey = qb_SetUpScoreDB [status, coreopts, qmsopts,
                        [], QMS_NUM_FIELDS, 'qmscore', status.notforced];

                    dbv_Open db_Filename dbkey;
                    db_Close dbkey;
                    exit [];
                endif
            endif
        else
           [status, browsetasks] = qb_CoreHandler [wkey, trig, status, vals,
               browsetasks];
        endif
    endloop

    task_kill browsetasks;
    WindowDestroy wkey;

endfunction

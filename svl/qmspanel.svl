#svl
//    qmspanel.svl    User-interface entrypoint to QMScore calculations

#set title   'QMScore Panel'
#set class   'QM'
#set version '2009.01'
#set main    'qms_SetupPanel'

function _Atoms;

function qms_CopyPosesDB;
function qms_GetMolField;
function qms_SaveDBRow;
function qms_SaveOptions;
function qms_SaveEnv;
function qms_SetFieldNames;

function qms_SetFieldNames;

function qms_Score;
function qms_ScoreBatch;


const OPT_TAGS =
    [
    'mode',
    'workdir',
    'scoredb',
    'posedb',
    'recdb',
    'ham',
    'freq',
    'opt',
    'task'
    ];

const RUN_MODES =
    [
    '1to1',
    '1toN',
    'NtoN'
    ];

/****************************************************************************
 *                          CreateResultDB
 *
 *  Create the output database for storing QMScore results and ensure that
 *  the required fields are present.
 *
 ****************************************************************************/
local function CreateResultDB [filename]

    local type = ftype filename;
    local dbkey = 0;
    if type == 'dir' then
        return dbkey;
    elseif type == 'file' then
        if not MOE_BATCH and not YesNo token swrite ['Overwrite {}?', filename] then
            return dbkey;
        endif
    endif

    write ['Creating database: {}\n', filename];  //DEBUG
    dbkey = db_Open [filename, 'create'];

    qms_SetFieldNames [dbkey];

    return dbkey;
endfunction

/****************************************************************************
 *                          OpenPosesDB
 *
 *  Opens the input database of ligand poses.
 *
 ****************************************************************************/
local function OpenPosesDB [filename]

    local type = ftype filename;
    local dbkey = 0;
    if type == 'file' then
        write ['Reading database: {}\n', filename];  //DEBUG
        dbkey = db_Open [filename, 'read'];
    endif

    return dbkey;
endfunction


/****************************************************************************
 *                          SplitReceptor
 *
 ****************************************************************************/
local function SplitReceptor [receptoratoms]

    if receptoratoms === [] then return []; endif

    local atomsets = [];
    local [recidx, reccnt] = sac aMoleculeNumber receptoratoms;
    if length reccnt > 1 then
        receptoratoms = receptoratoms [recidx];
        atomsets = split [receptoratoms, reccnt];
    else
        atomsets = [receptoratoms];
    endif

    return atomsets;

endfunction

/****************************************************************************
 *                          ChainsToMols
 *
 ****************************************************************************/
local function ChainsToMols []

    local complexatoms = Atoms [];
    if length complexatoms == 0 then
        return [[], [], 'No molecular complex loaded'];
    endif

    local recatoms, ligatoms;
    const LIGXNAME = 'LIGX_LIGAND';
    local colnames = oCollections [];

    if anytrue eqE [LIGXNAME, colnames] then
        ligatoms  = cat oAtoms oGetCollection LIGXNAME;
        ligatoms = join [ligatoms, complexatoms];
    endif

    if length ligatoms == 0 then
        ligatoms  = _Atoms '$$ligand';
    endif

    if length ligatoms == 0 or length ligatoms >= length complexatoms then
        return [[], [], 'No ligand was recognized.  Use LigX to define it.'];
    endif

    if 1 <> length uniq aMoleculeNumber ligatoms then
        return [[], [], 'Ligand has to be a single molecule.'];
    endif

    recatoms = diff [complexatoms, ligatoms];
    local recsets = SplitReceptor [recatoms];

    if recsets === [] then
        return [[], [], 'No receptor was recognized.'];
    endif

    local ligmol = mol_Extract ligatoms;
    local recmols = app mol_Extract recsets;

    return [recmols, ligmol, []];

endfunction


/****************************************************************************
 *                          SameDB
 *
 *  Borrowed from dock_ui.svl
 *
 * Returns 1 if name1 and name2 refer to the same MDB.
 * Otherwise return 0.
 *
 ****************************************************************************/
local function SameDB [name1, name2]
    if ftype name1 <> 'file' or ftype name2 <> 'file' then
        return 0;
    endif

    local d1 = db_Open [name1,'read'];
    local d2 = db_Open [name2,'read'];
    db_Close d1;
    db_Close d2;
    return (d1==d2);

endfunction


/****************************************************************************
 *
 *                          qms_SetupPanel
 *
 ****************************************************************************/
global function qms_SetupPanel [cfg, parent]

    if MOE_BATCH then return [];
    endif

    parent = add parent;

    local wkey = WindowCreate [
        name: 'panel', 
        title: 'QMScore',
        windowName: 'QMScorePanel',
        text: ['Run', 'Save', 'Cancel'],
        Label: [text: '                   <input data>', margin: 1, minWidth: 20]
        ];

    // ---------------------- embedded functions begin ----------------------

    function RunCalc [recset, ligand, options]
        local msgkey = Message [0, 'QMScore is running ...'];

        sleep -1;    // Allow parent to close input window.

        local results = qms_Score [recset, ligand, options];

        Message [msgkey, 'QMScore is done.'];

        return results;
    endfunction

    // ----------------------- embedded functions end -----------------------

    //DEBUG replace with vals from dialog
    local outname = '~daren/playground/MOEDivcon/qmscore.mdb';
    local inname = '~daren/playground/MOEDivcon/examples/ligand/poses.mdb';
    local options = []; 
    local qmskey = 0;
    local ligkey = 0;
    local recset, ligand;
    local errmess = [];

    WindowShow [wkey, 1];
    while wkey loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'panel' then
            local tskttl = task_title -1;
            if vals.panel === 'Run' then
                if second task_fork [] == 'child' then
                    task_settitle [-1, tskttl];

                    qmskey = CreateResultDB [outname];
                    if qmskey == 0 then
                        Warning token swrite ['Unable to create database {}', 
                            outname];
                        exit [];
                    endif

                    [recset, ligand, errmess] = ChainsToMols [];
                    if recset === [] or ligand == []then
                        Warning [errmess];
                        exit [];
                    endif

                    options = tag [OPT_TAGS, [RUN_MODES(1), '/tmp', 
                        outname, [], [], [], [], [], []]];
                    qms_SaveEnv [qmskey, recset, ligand, options];

                    local results = RunCalc [recset, ligand, options];
                    qms_SaveDBRow [qmskey, 0, ligand, results];
                    dbv_Open db_Filename qmskey;
                    db_Close qmskey;
                    exit [];
                else
                    WindowDestroy wkey;
                    wkey = 0;
                endif

            elseif vals.panel === 'Save' then
                if second task_fork [] == 'child' then
                    task_settitle [-1, tskttl];

                    if SameDB [inname, outname] then
                        Warning token swrite ['{} and {} are the same database', 
                            inname, outname];
                        exit [];
                    endif

                    ligkey = OpenPosesDB (inname);
                    if ligkey == 0 then
                        Warning token swrite ['Unable to open database {}',
                            inname];
                        exit [];
                    endif

                    qmskey = CreateResultDB [outname];
                    if qmskey == 0 then
                        Warning token swrite ['Unable to create database {}', 
                            outname];
                        db_Close [ligkey];
                        exit [];
                    endif

                    local absoutname = fabsname outname;
                    qms_CopyPosesDB [qmskey, ligkey];
                    db_Close ligkey;

                    [recset, ligand, errmess] = ChainsToMols [];
                    if  recset === [] or ligand === [] then
                        Warning [errmess];
                        exit [];
                    endif
                    options = tag [OPT_TAGS, [RUN_MODES(2), '/tmp', outname, inname,
                        [], [], [], [], []]];
                    qms_SaveEnv [qmskey, recset, ligand, options];

                    dbv_Open db_Filename qmskey;
                    db_Close qmskey;

                    qms_ScoreBatch [absoutname];

                    exit [];
                else
                    WindowDestroy wkey;
                    wkey = 0;
                endif

            elseif vals.panel === 'Cancel' then 
                WindowDestroy wkey;
                wkey = 0;
            endif
        endif
    endloop

endfunction

#svl
//    qmspanel.svl    User-interface entrypoint to QMScore calculations

#set title   'QMScore Panel'
#set class   'QM'
#set version '2009.01'
#set main    'qms_SetupPanel'

function _Atoms;

function qms_CopyPoseDB;
function qms_CopyRecPoseDB;
function qms_GetEnv;
function qms_GetPoseField;
function qms_SaveScore;
function qms_SaveEnv;
function qms_SetErrField;
function qms_SetFields;

function qms_Score;
function qms_ScoreBatch;


const OPT_TAGS =
    [
    'mode',
    'workdir',
    'scoredb',
    'posedb',
    'recdb',
    'ham',
    'freq',
    'opt',
    'task'
    ];

const RUN_MODES =
    [
    'One-to-One',
    'One-to-Many',
    'Many-to-Many'
    ];

const HAMILTONIANS =
    [
    'AM1',
    'MNDO',
    'MNDO/d',
    'MNDO/NMR',
    'PDDG-PM3',
    'PM3',
    'PM6'
    ];

const LIG_OPTS =
    [
    'in complex',
    'in isolation',
    'none'
    ];

/****************************************************************************
 *                          SplitReceptor
 *
 ****************************************************************************/
local function SplitReceptor [receptoratoms]

    if receptoratoms === [] then return []; endif

    local atomsets = [];
    local [recidx, reccnt] = sac aMoleculeNumber receptoratoms;
    if length reccnt > 1 then
        receptoratoms = receptoratoms [recidx];
        atomsets = split [receptoratoms, reccnt];
    else
        atomsets = [receptoratoms];
    endif

    return atomsets;

endfunction

/****************************************************************************
 *                          ChainsToMols
 *
 ****************************************************************************/
local function ChainsToMols []

    local complexatoms = Atoms [];
    if length complexatoms == 0 then
        return [[], [], 'No molecular complex loaded'];
    endif

    local recatoms, ligatoms;
    const LIGXNAME = 'LIGX_LIGAND';
    local colnames = oCollections [];

    if anytrue eqE [LIGXNAME, colnames] then
        ligatoms  = cat oAtoms oGetCollection LIGXNAME;
        ligatoms = join [ligatoms, complexatoms];
    endif

    if length ligatoms == 0 then
        ligatoms  = _Atoms '$$ligand';
    endif

    if length ligatoms == 0 or length ligatoms >= length complexatoms then
        return [[], [], 'No ligand was recognized.  Use LigX to define it.'];
    endif

    if 1 <> length uniq aMoleculeNumber ligatoms then
        return [[], [], 'Ligand has to be a single molecule.'];
    endif

    recatoms = diff [complexatoms, ligatoms];
    local recsets = SplitReceptor [recatoms];

    if recsets === [] then
        return [[], [], 'No receptor was recognized.'];
    endif

    local ligmol = mol_Extract ligatoms;
    local recmols = app mol_Extract recsets;

    return [recmols, ligmol, []];

endfunction


/****************************************************************************
 *                          SetUpRun
 *
 *  Create the output database for storing QMScore results and ensure that
 *  the required fields are present.  Store the molecules and run options 
 *  in the DB environment.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
 ****************************************************************************/
local function SetUpRun [opts]

    local qmskey = db_Open [opts.scoredb, 'create'];
    qms_SetFields [qmskey, opts.mode === 'Many-to-Many'];

    if opts.mode === 'One-to-One' or opts.mode === 'One-to-Many' then
        local [recset, ligand, errmess] = ChainsToMols [];
        if recset === [] or ligand === [] then
            Warning [errmess];
            exit [];
        endif

        qms_SaveEnv [qmskey, recset, ligand, opts];
    else
        qms_SaveEnv [qmskey, [], [], opts];
    endif

    if opts.mode === 'One-to-One' then
        local posedata = tag [qms_GetPoseField [], [ligand]];
        db_Write [qmskey, 0, posedata];

    else
        local posekey = db_Open [opts.posedb, 'read'];
        if qmskey == posekey then
            Warning token swrite ['{} and {} are the same database', 
                opts.scoredb, opts.posedb];
            exit [];
        endif

        if opts.mode === 'One-to-Many' then
            qms_CopyPoseDB [qmskey, posekey];
        else
            local reckey = db_Open [opts.recdb, 'read'];
            if qmskey == reckey then
                Warning token swrite ['{} and {} are the same database', 
                    opts.scoredb, opts.recdb];
                exit [];
            endif

            qms_CopyRecPoseDB [qmskey, reckey, posekey];
            db_Close reckey;
        endif

        db_Close posekey;
    endif

    qms_SetErrField [qmskey];

    return qmskey;
endfunction

/****************************************************************************
 *
 *                          qms_SetupPanel
 *
 ****************************************************************************/
global function qms_SetupPanel [cfg, parent]

    if MOE_BATCH then return [];
    endif

    parent = add parent;

    local wkey = WindowCreate
        [
        name: 'panel', 
        title: 'QMScore',
        windowName: 'QMScorePanel',
        text: ['Run', 'Save', 'Cancel'],
        onTrigger: ['validate', 'validate', 'return'],
        bubbleHelp: ['Execute QMScore from MOE',
            'Save run parameters in database for later execution on cluster.', ''],

        Hbox :
            [
            extendH: 1,
            FSBText :
                [
                name: 'scoredb', len: 40, extendH: 1, title: 'Output DB:',
                mode: 'saveAs', allowBlank: 0,
                bubbleHelp:
                    'The name of the output database that will hold\n'
                    'the run paramaters and scoring results.'
                ],
            Button : [ name: 'browse_scoredb', text: 'Browse...' ]
            ],

        Separator : [flushLeft:1, extendH:1, margin:1],

        Hbox :
            [
            extendH: 1,
            Text :
                [
                name: 'workdir', len: 40, extendH: 1, title: 'Working Dir:',
                type: 'char', allowBlank: 0, onTrigger: 'return',
                bubbleHelp:
                    'The name of the working directory for storing\n'
                    'QB Divcon intermediate calculations.'
                ],
            Button : [ name: 'browse_workdir', text: 'Browse...' ]
            ],

        Vbox :
            [
            Hbox :
                [
                extendH: 1,
                Option :
                    [
                    name: 'ham', title: 'Hamiltonian:', text: HAMILTONIANS,
                    type: 'int', minWidth: 8, extendH: 1,
                    bubbleHelp:
                        'TODO.'
                    ],
                Checkbox :
                    [
                    name: 'freq', text: 'Frequency',
                    bubbleHelp:
                         'TODO.\n'
                        'The vibrational entropy calculation is computationally\n'
                        'intensive and using the frequency option can easily\n'
                        'double the execution time.'
                    ]
                ],
            Option :
                [
                name: 'opt', title: 'Ligand Optimization:', text: LIG_OPTS,
                type: 'int', minWidth: 11, extendH: 1,
                bubbleHelp:
                    'TODO.'
                ]
            ],


        Separator : [flushLeft:1, extendH:1, margin:1],

        Hbox :
            [
            Radio :
                [
                name: 'mode', text: RUN_MODES, columns: 3, minWidth: 12, 
                extendH: 1, onTrigger: 'return', title: 'Mapping Mode:',
                type: 'char',
                bubbleHelp:
                    'The mapping mode of receptors to ligand/poses.'
                ]
            ],

        Hbox :
            [
            name: 'posebox', extendH: 1, sensitive: 0,
            FSBText :
                [
                name: 'posedb', len: 40, extendH: 1, title: 'Ligand/Pose DB:',
                mode: 'open', allowBlank: 0,
                bubbleHelp:
                    'The name of the input database that holds\n'
                    'the ligand poses (and possibly scores).'
                ],
            Button : [ name: 'browse_posedb', text: 'Browse...' ]
            ],

        Hbox :
            [
            name: 'recbox', extendH: 1, sensitive: 0,
            FSBText :
                [
                name: 'recdb', len: 40, extendH: 1, title: 'Receptor DB:',
                mode: 'open', allowBlank: 0,
                bubbleHelp:
                    'The name of the input database that holds\n'
                    'the receptors.'
                ],
            Button : [ name: 'browse_recdb', text: 'Browse...' ]
            ],

        Separator : [flushLeft:1, extendH:1, margin:1]
        ];

    // ---------------------- embedded functions begin ----------------------

    function RunCalc [dbkey]
        local msgkey = Message [0, 'QMScore is running ...'];
        sleep -1;    // Allow parent to close input window.

        local [recset, ligand, options] = qms_GetEnv [dbkey];
        local results = qms_Score [recset, ligand, options];
        qms_SaveScore [dbkey, first db_Entries [dbkey], results];

        Message [msgkey, 'QMScore is done.'];

        return;
    endfunction

    // ----------------------- embedded functions end -----------------------

    local btid, browsetasks = [];
    local options = []; 
    local qmskey = 0;

    WindowSetData [wkey, [scoredb: 'qmscore.mdb', freq: 0, workdir: '.']];
    WindowSetAttr [wkey, [posebox: [sensitive: 0], posedb: [allowBlank: 1],
         freq: [sensitive: 0], recbox: [sensitive: 0], recdb: [allowBlank: 1]]];

    WindowShow [wkey, 1];
    loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'mode' then
            if vals.mode === 'One-to-One' then
                WindowSetAttr [wkey, [posebox: [sensitive: 0],
                    posedb: [allowBlank: 1], recbox: [sensitive: 0], 
                    recdb: [allowBlank: 1], panel:[sensitive: [1,1,1]]]];
            elseif vals.mode === 'One-to-Many' then
                WindowSetAttr [wkey, [posebox: [sensitive: 1],
                    posedb: [allowBlank: 0],recbox: [sensitive: 0], 
                    recdb: [allowBlank: 1], panel:[sensitive: [0,1,1]]]];
            elseif vals.mode === 'Many-to-Many' then
                WindowSetAttr [wkey, [posebox: [sensitive: 1],
                    posedb: [allowBlank: 0], recbox: [sensitive: 1], 
                    recdb: [allowBlank: 0], panel:[sensitive: [0,1,1]]]];
            endif

        elseif trig === 'workdir' then
            local wdpath = fabsname vals.workdir;
            if not ftype wdpath === 'dir' then
                Warning token swrite ['{} is not a directory.', wdpath];
                continue;
            endif

        elseif trig == 'browse_scoredb' then
            btid = run ['fbrowse.svl', [trig, wkey, 'Select QMScore DB File', 
                'none', '*.mdb', 'scoredb']];
        if btid then browsetasks = append [browsetasks, btid]; endif

         elseif trig == 'browse_workdir' then
            btid = run ['fbrowse.svl', [trig, wkey, 'Select Working Directory', 
                'none', '*', 'workdir']];
        if btid then browsetasks = append [browsetasks, btid]; endif

        elseif trig == 'browse_posedb' then
            btid = run ['fbrowse.svl', [trig, wkey, 'Select Pose DB File', 
                'open', '*.mdb', 'posedb']];
        if btid then browsetasks = append [browsetasks, btid]; endif

        elseif trig == 'browse_recdb' then
            btid = run ['fbrowse.svl', [trig, wkey, 'Select Receptor DB File', 
                'open', '*.mdb', 'recdb']];
        if btid then browsetasks = append [browsetasks, btid]; endif

       elseif trig === 'panel' then
            local tskttl = task_title -1;
            if vals.panel === 'Cancel' then 
                break;

            elseif vals.panel === 'Run' then
                if second task_fork [] == 'child' then
                    task_settitle [-1, tskttl];

                    options = tag [OPT_TAGS, [vals.mode, 
                      fabsname vals.workdir, fabsname vals.scoredb, [], [],
                      vals.ham, vals.freq, vals.opt, []]];

                    qmskey = SetUpRun [options];
                    RunCalc [qmskey];
                    dbv_Open db_Filename qmskey;
                    db_Close qmskey;
                    exit [];
                else
                    break;
                endif

            elseif vals.panel === 'Save' then
                if second task_fork [] == 'child' then
                    task_settitle [-1, tskttl];

                    options = tag [OPT_TAGS, [vals.mode, 
                        fabsname vals.workdir, fabsname vals.scoredb,
                        fabsname vals.posedb, fabsname vals.recdb, vals.ham,
                        vals.freq, vals.opt, []]];
                    qmskey = SetUpRun [options];
                    dbv_Open db_Filename qmskey;
                    db_Close qmskey;

//                    qms_ScoreBatch [vals.scoredb];

                    exit [];
                else
                    break;
                endif
            endif
        endif
    endloop

    task_kill browsetasks;
    WindowDestroy wkey;

endfunction

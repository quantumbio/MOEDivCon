#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
	
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

	//    qmspanel.svl    User-interface entrypoint to QMScore calculations

#set title   'QuantumBio QMScore Panel'
#set class   'QuantumBio'
#set version '2010.02'
#set main    'qb_QMScoreSetupPanel'


function qb_CoreHandler;
function qb_GetCoreEnv;
function qb_GetCorePanel;
function qb_GetDefaultsCore;
function qb_GetDefaultsStatus;
function qb_GetEnvApp;
function qb_GetWhich;
function qb_InitCorePanel;
function qb_IsModeOneToOne;
function qb_IsShowingAllPoses;
function qb_ResetLigand;
function qb_LoadCoreScoreDB;
function qb_SaveDivConStatus;
function qb_SaveOptions;
function qb_SetAppStatus;
function qb_SetUpScoreDB;
function qb_TagCoreVals;
function qb_UpdateCorePanel;
function qb_VerifyDivConComplex;

function qb_QMScore;
function qb_QMScoreBatch;

function qb_GetCoreFields;
function qb_GetQMS_dbFields;

function pro_Join;

	//  Data tags are in the order in which they are returned by DivCon.

const QMS_DATA_TAGS =
    [
    "LIGAND",
    "TOTAL SCORE",
    "GAS PHASE HEAT OF FORMATION",
    "ELECTROSTATIC SOLVATION",
    "ATTRACTIVE LENNARD JONES",
    "SOLVATION ENTROPY",
    "VIBRATIONAL ENTROPY",
    "ELECTRONIC INTERACTION ENERGY",
    "MRM STERIC ENERGY",
    "MRM ELECTROSTATIC ENERGY",
    "MRM SOLVATION ENERGY",
    "MRM TOTAL ENERGY"
    ];
 
const QMS_NUM_FIELDS =
    [
    'QMScore',
    'dHf_g',
    'Solv_elec',
    'LJ_att',
    'S_solv',
    'S_vib',
    'E_eInt',
    'MRMScore',
    'E_stericMRM',
    'E_elecMRM',
    'E_solvMRM'
    ];

/*  NOTE:  If you change the Option lists here, you need to update the
 *         Keys in qmsinterface.svl.
 */

const QMSCORE_OPT_DEFAULTS =
        [
        ['freq',         0             ],
        ['opt',          1             ],
        ['shift',        9.0           ],
        ['analpwd',      1             ]       //  Generate PWD row data
    ];

const LIG_OPTS =
    [
    'none',
    'free',
    'bound'
    ];

const HEADER = 
    [
    name: 'panel', 
    title: 'QMScore',
    windowName: 'QMScorePanel',
    text: ['Run', 'Create', 'Update', 'Load', 'Close'],
    onTrigger: ['validate', 'validate', 'return', 'return', 'return'],
    bubbleHelp: ['Execute QMScore from MOE Window.',
        'Create a QMScore database with receptor(s), ligand(s)\n'
        'and run parameters for later execution on cluster.', 
        'Update only the run parameters in the QMScore database.', 
        'Load run parameters and complex from a QMScore database.', 
        '']
    ];

const PANEL =
    [
    Vbox :
        [
        Hbox :
            [
            extendH: 1,
            Option :
                [
                name: 'opt', title: 'Ligand Optimization:', text: LIG_OPTS,
                type: 'int', minWidth: 5, extendH: 1,
                bubbleHelp:
                    'A QM-based ligand optimization can be performed\n'
                    'prior to scoring. This optimization may occur\n'
                    'either while the ligand is docked within the target\n'
                    'or while the ligand is separate from the target.\n'
                    'Warning: this optional step will significantly\n'
                    'increase the CPU cost of the calculation.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 1, margin:1
                ],
            Text :
                [
                name: 'shift', title: 'Shift:', len: 30, extendH: 1, 
                type: 'real', allowBlank: 0,
                shortcut: ['0.0', '2.0', '4.0', '8.0', '16.0'],
                bubbleHelp:
                    'Initial dynamic level shift (eV).'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 1, margin:1
                ],
            Checkbox :
                [
                name: 'freq', text: 'Frequency',
                bubbleHelp:
                    'Perform frequency calculation to determine ligand\n'
                    'entropy in score function.  Warning: may increase\n'
                    'CPU cost of the calculation.'
                ]
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        extendH: 1,
        name: 'analbox',
        Checkbox :
            [
            name: 'analpwd', text: 'PWD', title: 'Generate:',
            bubbleHelp:
                'Generate pair-wise decomposition data\n'
                'after the QMScore calculations.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 1, margin:1
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1]
    ];

	//  Local Functions

/****************************************************************************
 *                          LoadDB
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
local function LoadDB [dbpath]

    local [dbkey, receptor, ligand, status, coreopts, c, mess] = 
        qb_LoadCoreScoreDB [dbpath, 'qmscore'];
    if dbkey === 0 and status === [] and coreopts === [] then
        Warning mess;
        exit [];
    endif

    local qmsopts = qb_GetEnvApp [dbkey];
    qmsopts = tagcat [qmsopts, tag tr QMSCORE_OPT_DEFAULTS];

    return [dbkey, receptor, ligand, status, coreopts, qmsopts];
endfunction

function qb_GetQMSEnv;
function qb_SaveQMScore;

/****************************************************************************
 *                          RunCalc
 *
 *  Run the One-to-One scoring from the MOE Window.
 *
 *  WARNING:  breaking into core
 *
 ****************************************************************************/
local function RunCalc [dbkey]
    local msgkey = Message [0, 'QMScore is running ...'];
    sleep -1;    // Allow parent to close input window.

    local rowkey = first db_Entries [dbkey];
    local [receptor, ligand, status, coreopts, qmsopts] = qb_GetQMSEnv [dbkey];

    local dbpath = fabsname db_Filename dbkey;
    local perpath = fpath dbpath;
    local pertail = fbase ftail dbpath;
    local perfile = twrite ['{}/{}.h5', perpath, pertail];

    local workdir;
    if coreopts.cwd === 1 then
        workdir = getenv 'PWD';
    else
        workdir = fabsname coreopts.workdir;
    endif

    coreopts.workdir = workdir;
    write ['Persistent File:  {}\n', perfile];
    write ['Work Dir:  {}\n', workdir];

    local start = clock [];
    local [results, errmess] = qb_QMScore [receptor, ligand, perfile, 
        coreopts, qmsopts, status.notforced];
    local finish = clock [];
    local secs = round (finish - start);
    local hours = floor (secs / 3600);
    secs = secs - (hours * 3600);
    local minutes = floor (secs / 60);
    secs = secs - (minutes * 60);

    if results === [] then
        if errmess === [] or errmess === '' then
            qb_SaveDivConStatus [dbkey, rowkey, "Error:  Unknown error!\n"];
            write ['QMScore Error:  Unknown error!\n'];
        else
            qb_SaveDivConStatus [dbkey, rowkey, 
                swrite ['Error:  {}\n', errmess]];
            write ['QMScore Error:  {}\n', errmess];
        endif
    else
        qb_SaveQMScore [dbkey, rowkey, results];
        local sucmess = "Success";
        if not isnull errmess then
            sucmess = cat [sucmess, "-warnings!\n", errmess];
        else
            sucmess = cat [sucmess, "\n"];
        endif

        qb_SaveDivConStatus [dbkey, rowkey, sucmess];
    endif

    local timemess = twrite ['QMScore is done.\nTotal clock time {}:{}:{}.', 
        hours, minutes, secs];
    write ['{}\n', timemess];
    Message [msgkey, timemess];
    sleep 3;
    Message [msgkey, []];

    return;
endfunction

function qb_GetPoseFields;

/****************************************************************************
 *                          RunOneToManyCalc
 *
 *  Execute QMScore for each row of the scoring database.
 *
 *  WARNING:  breaking into core
 *
 ****************************************************************************/
local function RunOneToManyCalc [oldkey]

    if MOE_BATCH then exit ['Should only be run from MOE.']; endif

    if oldkey === 0 then
        Warning 'The QMScore database hasn\'t been created.';
        return;
    endif

    local dblist = dbv_KeyList [];
    if not isnull dblist and not isnull indexof [oldkey, dblist] then
        Warning 'The QMScore database is still open.';
        return;
    endif

    //  Extract molecules and run options from the database environment
    local dbkey = db_Open [oldkey, 'read-write'];
    local [recmols, l, status, coreopts, qmsopts] = qb_GetQMSEnv [dbkey];

    local msgkey = 0;

    local dbpath = fabsname db_Filename dbkey;
    local perpath = fpath dbpath;
    local pertail = fbase ftail dbpath;
    local perfile = twrite ['{}/{}.h5', perpath, pertail];

    local workdir;
    if coreopts.cwd === 1 then
        workdir = getenv 'PWD';
    else
        workdir = fabsname coreopts.workdir;
    endif

    coreopts.workdir = workdir;
    write ['Persistent File:  {}\n', perfile];
    write ['Work Dir:  {}\n', workdir];

    //  For each ligand pose in the database, calculate QM score.
    local nrows = db_nEntries dbkey;
    local rowkey = 0, rowcnt = 0;
    local poseflds = qb_GetPoseFields [dbkey];
    
    // process the fields in the QMScore mdb file and strip out the stuff we added
//    local QMStokens = totok cat [qb_GetCoreFields[], qb_GetQMS_dbFields[]];
    local [fields, field_types] = db_Fields dbkey;  
    local nonQBfields = fields | (field_types <> 'molecule');
    nonQBfields = diff [nonQBfields,totok cat [qb_GetCoreFields[], qb_GetQMS_dbFields[]] ];

    while rowkey = db_NextEntry [dbkey, rowkey] loop
        rowcnt = rowcnt + 1;
        msgkey = Message [msgkey, twrite ['Scoring pose {} of {}\n', rowcnt,
            nrows]];

        coreopts.task = rowcnt;
        local [posemol, posechg] = db_ReadFields [dbkey, rowkey, poseflds];
        local nonQBtagged = tag [nonQBfields, db_ReadFields [dbkey,rowkey,nonQBfields]];
        coreopts.ligchg = posechg;
        local [results, errmess] = qb_QMScore [recmols, posemol, perfile,
            coreopts, qmsopts, status.notforced, nonQBtagged];

        if results === [] then
            if errmess === [] or errmess === '' then
                errmess = "Unknown error!";
            endif
            qb_SaveDivConStatus [dbkey, rowkey,
                swrite ['Error:  {}\n', errmess]];
            write ['QMScore Error on pose {}:\n    {}\n', rowcnt, errmess];
            msgkey = Message [msgkey, 
                twrite ['QMScore Error on pose {}:\n    {}\n', rowcnt,
                    errmess]];
            sleep 3;
        else
            qb_SaveQMScore [dbkey, rowkey, results];
            local sucmess = "Success";
            if not isnull errmess then
                sucmess = cat [sucmess, "-warnings!\n", errmess];
            else
                sucmess = cat [sucmess, "\n"];
            endif
            qb_SaveDivConStatus [dbkey, rowkey, sucmess];
        endif
    endloop

    Message [msgkey, []];
    db_Close dbkey;

endfunction


	//  Global Functions

global function qb_GetQMS_dbFields []
	return QMS_NUM_FIELDS;
endfunction

/****************************************************************************
 *                          qb_GetQMSEnv
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
global function qb_GetQMSEnv [dbkey]

    local [receptor, ligand, status, coreopts, c] = qb_GetCoreEnv [dbkey];
    local qmsopts = qb_GetEnvApp [dbkey];
    qmsopts = tagcat [qmsopts, tag tr QMSCORE_OPT_DEFAULTS];

    return [receptor, ligand, status, coreopts, qmsopts];
endfunction

/****************************************************************************
 *                          qb_SaveQMScore
 *
 *  Save just the score data in the QMScore database.
 *
 ****************************************************************************/
global function qb_SaveQMScore [mdbkey, rowkey, scoredata]

    if alltrue (QMS_DATA_TAGS === app first scoredata) then
        return db_Write [mdbkey, rowkey, tag [QMS_NUM_FIELDS, 
            dropfirst app second scoredata]];
    endif

    return 0;
endfunction

/****************************************************************************
 *                          qb_CreateQMScoreDB
 *
 *  Create the QMScore DB as required and return the dbkey.
 *
 *  SVL API Purpose: to wrap the creation process with QMS_NUM_FIELDS et al so
 *      that other functions can create this DB (even if called from outside
 *      qmspanel.svl file).
 *
 * lmw TODO: need to call this function instead of qb_SetUpScoreDB 
 *      directly in qb_QMScoreSetupPanel;
 *
 ****************************************************************************/
global function qb_CreateQMScoreDB [status,coreopts,qmsopts]
    return qb_SetUpScoreDB [status, coreopts, qmsopts,
        [], QMS_NUM_FIELDS, 'qmscore', status.notforced];
endfunction

/****************************************************************************
 *                          qb_TagQMSVals
 *
 *  Tag values for QMScore options from the panel window.
 *
 *  SVI API Purpose: to wrap the creation process with QMSCORE_OPT_DEFAULTS et al so
 *      that other functions can process these options.
 *
 * lmw TODO: need to call this function instead of tag et al 
 *      directly in qb_QMScoreSetupPanel;
 *
 ****************************************************************************/
global function qb_TagQMSVals [vals]
    local qmsopts = tag [first tr QMSCORE_OPT_DEFAULTS, [
                        vals.freq, vals.opt, vals.shift,
                        vals.analpwd]];
    return tagcat [qmsopts,tag tr QMSCORE_OPT_DEFAULTS];
endfunction

/****************************************************************************
 *
 *                          qb_QMScoreSetupPanel
 *
 ****************************************************************************/
global function qb_QMScoreSetupPanel []

    static status;                     //  Shared with child tasks.
    static origligmol;                 //  Probably not necessary for QMScore
    static ligatoms;

    if MOE_BATCH then exit ['Should only be run from MOE.']; endif
    if WindowShow ['QMScorePanel', 1] then return; endif

    local coreopts = [], qmsopts = [], browsetasks = [], dbkey = 0;
    status = qb_GetDefaultsStatus [];
    status = qb_SetAppStatus [status, 'qms'];
    local coredflts = qb_GetDefaultsCore [];
    local appdflts = tag tr QMSCORE_OPT_DEFAULTS;
    coredflts = tagpoke [coredflts, 'scoredb', 'qmscore.mdb'];

    local wkey = WindowCreate cat [HEADER, qb_GetCorePanel [], PANEL];
    status = qb_InitCorePanel [wkey, status, coredflts];
    WindowSetData [wkey, appdflts];
    WindowShow [wkey, 1];

    loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'panel' then
            if vals.panel === 'Close' then 
                break;

            elseif vals.panel === 'Load' then 

                if second task_fork [master: 'parent',
                        statics:'share'] === 'child' then
                    task_prio 0;

                    local dbpath = first FilePrompt [title: 'Load Database', 
                        filter: '*.mdb', allowEmptyList: 0];
                    if not isnull dbpath then
                        if neL [ftype dbpath, 'file']
                                or neL [fext dbpath, 'mdb'] then
                            Warning 'The QMScore database doesn\'t exist.';
                            exit [];
                        endif

                        local [ldkey, ldrecs, ldligs, ldsts, ldcoreopts,
                            ldqmsopts] = LoadDB [dbpath];
                            
    	                Close [force:1];
                        local idx = 1;
                        if length ldrecs >= 1 then
                            local ldrec = ldrecs(idx);
                            local ldlig = ldligs(idx);
                            if neL [ldrec, []] and neL [ldlig, []] then
                                origligmol = ldlig;
                                local chainsList = mol_Create ldrec;
                                pro_Join chainsList;
                                ligatoms = cat oAtoms mol_Create origligmol;
                                oSetCollection ['QB_LIGAND', ligatoms];
                                aSetNucleusLook [ligatoms, 'small-sphere'];
                                aSetBondLook [ligatoms, 'cylinder'];
                            endif
                        endif
                        View [];
                        dbv_Open db_Filename ldkey;
                        db_Close ldkey;
                        status = qb_UpdateCorePanel [wkey, ldsts, ldcoreopts];
                        WindowSetData [wkey, ldqmsopts];
                    endif

                    exit [];
                endif

            elseif vals.panel === 'Run' then

                if qb_IsShowingAllPoses [vals] then
                    [vals, ligatoms] = qb_ResetLigand [wkey, vals];
                endif

                if second task_fork [statics:'share'] === 'child' then
                    task_prio 3;
                    task_settitle [-1, 'MOEDivCon QMScore Run'];

                    status = qb_VerifyDivConComplex [0, status, vals];
                    if not status.verified then exit []; endif

                    coreopts = qb_TagCoreVals [vals];
					qmsopts = qb_TagQMSVals[vals];
                    dbkey = qb_SetUpScoreDB [status, coreopts, qmsopts, 
                        [], QMS_NUM_FIELDS, 'qmscore', status.notforced];

                    if qb_IsModeOneToOne [coreopts] then
                        RunCalc [dbkey];
                    else
                        RunOneToManyCalc [dbkey];
                    endif

                    dbv_Open db_Filename dbkey;
                    db_Close dbkey;
                    exit [];
                else
                    break;
                endif

            elseif vals.panel === 'Create' then

                if qb_IsShowingAllPoses [vals] then
                    [vals, ligatoms] = qb_ResetLigand [wkey, vals];
                endif

                if second task_fork [statics:'share'] === 'child' then
                    task_prio 0;

                    status = qb_VerifyDivConComplex [wkey, status, vals];
                    if not status.verified then exit []; endif

                    coreopts = qb_TagCoreVals [vals];
                    qmsopts = tag [first tr QMSCORE_OPT_DEFAULTS,
                        [vals.freq, vals.opt, vals.shift,
                        vals.analpwd]];

                    dbkey = qb_SetUpScoreDB [status, coreopts, qmsopts,
                        [], QMS_NUM_FIELDS, 'qmscore', status.notforced];
                    dbv_Open db_Filename dbkey;
                    db_Close dbkey;
                    exit [];
                endif

            elseif vals.panel === 'Update' then

                if second task_fork [statics:'share'] === 'child' then
                    task_prio 0;

                    coreopts = qb_TagCoreVals [vals];
                    qmsopts = tag [first tr QMSCORE_OPT_DEFAULTS, [
                        vals.freq, vals.opt, vals.shift,
                        vals.analpwd]];

                    qb_SaveOptions [coreopts, qmsopts];

                    Message [0, 'MOEDivCon QMScore update is done.'];
                    sleep 2;
                    exit [];
                endif
            endif

        else
           [status, ligatoms, browsetasks] = qb_CoreHandler [wkey, trig, 
                status, vals, browsetasks];
        endif
    endloop

    task_kill browsetasks;
    WindowDestroy wkey;

endfunction

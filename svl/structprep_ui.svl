#svl
//	structprep_ui.svl	user interface for automatic structure prep.
//
//	08-feb-2013 (cc) Fix aname of heavy or H only if non-uniq name
//	06-feb-2013 (cc) return all types
//	05-nov-2012 (cc) Bh updates
//	25-oct-2012 (cc) Fixed move to calculated Chiral flag in private system.
//	22-oct-2012 (cc) Fixed build loop minimization.
//	09-oct-2012 (cc) Verbose set to 0 for protonate3d.
//	05-oct-2012 (cc) Set Hidden and inert state depending on parent
//	04-oct-2012 (cc) Charge now applies to entire system only.
//	04-oct-2012 (cc) Added GetRC Rotamer Library
//	30-sep-2012 (cc) Added _StructurePreparationGUI, chain keys as params
//	28-sep-2012 (cc) Added charge diagnosis
//	10-sep-2012 (cc) Used pro_SmartMutate instead of pro_Mutate
//	07-sep-2012 (cc) Used baseRed and label sensitive for summary
//	05-sep-2012 (cc) Uses canvasBackground for 2D depictions
//	04-sep-2012 (cc) Move SystemNonrender state for diagnosing system.
//	04-sep-2012 (cc) Add Message in list box when initializing
//	04-sep-2012 (cc) Add back in title for correcting sub tasks.
//	28-aug-2012 (cc) Delete empty chain when fixing DNA
//	25-aug-2012 (mk) add gr_icon recolor parameter
//	23-aug-2012 (cc) Set black to none for summary table.
//	30-apr-2012 (al) set task master:'parent', remove task titles
//	19-apr-2012 (al) show window immediately
//	18-apr-2012 (al) removed Undo and added UndoSnapshot
//	01-feb-2012 (kk) fixed SystemPop usage
//	15-jan-2012 (cc) remove private chains, fix diagnose bug upon startup
//	15-nov-2011 (cc) Full path for icons is no longer needed
//	14-nov-2011 (cc) Removed set rotation center when isolating.
//	11-nov-2011 (cc) Disconnected metal only applied to metal alone in res
//      10-nov-2011 (cc) Warning appears for correct similiar (specific cases)
//	10-nov-2011 (cc) panel buttons senstitive when running P3D
//	06-nov-2011 (cc) minor bug fixes
//	04-nov-2011 (cc) When no Seq match, Library will report 3D only
//	31-oct-2011 (cc) minor bugs and changes in txt
//	26-oct-2011 (cc) driver function return unique var to define a uniq prob
//	25-oct-2011 (cc) minor bug fixes.
//	21-oct-2011 (cc) minor bug fixes and types now disables instead of hide.
//	17-oct-2011 (cc) minor bug fixes
//	10-jan-2011 (cc) created
//
// COPYRIGHT (C) 2011-2013 CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
//
// PERMISSION TO USE, COPY, MODIFY AND DISTRIBUTE THIS SOFTWARE IS HEREBY
// GRANTED PROVIDED THAT: (1) UNMODIFIED OR FUNCTIONALLY EQUIVALENT CODE
// DERIVED FROM THIS SOFTWARE MUST CONTAIN THIS NOTICE; (2) ALL CODE DERIVED
// FROM THIS SOFTWARE MUST ACKNOWLEDGE THE AUTHOR(S) AND INSTITUTION(S); (3)
// THE NAMES OF THE AUTHOR(S) AND INSTITUTION(S) NOT BE USED IN ADVERTISING
// OR PUBLICITY PERTAINING TO THE DISTRIBUTIN OF THE SOFTWARE WITHOUT
// SPECIFIC, WRITTEN PRIOR PERMISSION; (4) ALL CODE DERIVED FROM THIS SOFTWARE
// BE EXECUTED WITH THE MOLECULAR OPERATING ENVIRONMENT (MOE) LICENSED FROM
// CHEMICAL COMPUTING GROUP INC.
//
// CHEMICAL COMPUTING GROUP INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
// AND IN NO EVENT SHALL CHEMICAL COMPUTING GROUP INC. BE LIABLE FOR ANY
// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
// RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
// CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
// CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

#set title	'Structure Preparation User Interface'
#set version	'2013.02'
#set class	'MOE:interactive'
#set main 	'StructurePreparationGUI'

function Protonate3D;
function _Atoms;
function amber_ResidueLibrary;
function amber_ResidueLookup;
function pro_Acetylate;
function pro_Amidate;
function PartialCharge;

const DEBUG = 0;

//======================== Utilities, Extension, Brevity ======================

local function tfork opt = task_fork tagcat [opt, [master:'parent']];

// Return 1 is all atoms of the residue are inert otherwise return 0.

local function rAllAtomsInert rkeys
    if not isflat rkeys then return app rAllAtomsInert rkeys; endif;
    return app andE aInert oChildren rkeys and oChildCount rkeys;
endfunction

local function oValidSerial [keys, serial]
    local m = oValid keys;
    return unpack [oSerialNumber (keys|m) == (serial|m), 0, m];
endfunction

local function rIsBonded [r1, r2]
    return app anytrue (r2 == oParent app aBonds oChildren r1);
endfunction

local function rDisplayUID res
    return tok_cat [
	totok rUID res,
	select ['', totok rINS res, isspace rINS res]
    ];
endfunction

local function rDisplayName res
    local rn = rName res;
    local m = rn == Seq_CharToName rLetter res;
    return unpack [tofupper (rn|m), rn|not m, m];
endfunction

#ifnbif oAddToCollection
local function oAddToCollection [setname, keys]
    keys = uniq cat [keys, oGetCollection setname];
    oSetCollection [setname,keys];
endfunction
#endif

local function _aSetLabelName [atoms, flag]
    aSetLabelName [atoms | oValid atoms,flag | oValid atoms];
endfunction

// FUNCTION:	Get public chains along with removing ones containing only
//		dummy atoms with '' as a chain name (such as dummies create
//		by site finder
// INPUT:	NULL
// RETURN:	Chain keys.

local function noPrivateChains []
    local ch = Chains [];
    ch = ch | not m_findmatch ['[[]PRIVATE]*', cName ch];
    ch = ch | not (
	    cName ch == ''
	and (app alltrue ((aElement cAtoms ch) == 'LP'))
    );
    return ch;
endfunction

// ===== Constants & Statics ================================================

const STD_RES_LIB = '$MOE/lib/amber10.mdb';

// ===== STRUCTURE PREP Defaults ===== //

const WINDOW_NAME = 'Structure Preparation';
const LOADING_PAGE = 4;
const STARTING_PAGE = 1;
const LIST_BY_ERR_HEADER = 'P{r}\tChain{-~r}\tRes\tUID{r}\tType\tDetails';
const P3D_PROTECT_SET = 'Protonate3d_Protect';

const SPREP_DEF_MOEGUI = [
    cmd			: 'interactive',    // if interative panel pops up
    reportName		: '',
    autoIsolate		: 1,		    // 1 if single click isolates
					    // in listbox.
    batch_protonate3d	: 1,		    // run Protonate3D after fixing
					    // errors in batch mode.
    disableTypes		: 'HName'
];

const SPREP_DEF_MOEBATCH = [
    cmd			: 'cli',    // if interative panel pops up
    reportName		: '',
    autoIsolate		: 1,		    // 1 if single click isolates
					    // in listbox.
    batch_protonate3d	: 1,		    // run Protonate3D after fixing
					    // errors in batch mode.
    disableTypes		: 'HName'
];

// ===== SMART MATCHES ===== //

const PRO_BB_MATCH = '[CX3](~[OX1!-])~[CX4H1,H2]~[N]';
const PRO_BB_WEAKMATCH = '[C](~[OX1,OX2H1])~[CH1,H2]~[N]';
const PRO_CA_MASK = [0,0,1,0];
const PRO_N_MASK = [0,0,0,1];
const COO_MATCH = '[#6X3](~[#8])(~[#8])~[#6]~[#7]';
const DNA_BB_MATCH =
    '[OX2]~[CX4H1r5](~[CX4r5](~[CX4H1r5]))~[CX4H1r5](~[OX2r5])~[CX4H2]~[OX2]';
const CTERMINUS_MATCH = '[CX3](~[O])(~[O])~[CX4]~[N]';
const NTERMINUS_MATCH = '[CX3](~[O])~[CX4]~[N+]';

// ===== ERROR NAMES & TYPES ===== //

const ALL_ERR = 0;
const ERRTYPE = [
    issues	: 1,
    prot	: 2,
    warning	: 3
];

const ERRNAMES = [
    names: ['Issues','Protonation','Warnings'],
    help : [
	'List of issues and possible solutions.',
	'List of residues where protonation/tautomer\n'
	'states can change.',
	'List of issues for manual inspection.'
    ]
];

// ===== CNTXT STATICS ===== //

static CNTXT_rkeys;	// Residues keys of importance;

// CNTXT_libmatch definition
// exact match 	= If residue if found in library using strongmatch criteria
// 0 = not found at all in library.
// 1 = One exact match found in library with exact rName Match.
// 2 = Multiple exact matches found in library
// 3 = inconsistant rName match.
// 4 = Sigma only match is found in library
// 5 = rName only match is found in library
// 6 = residue with no atoms.
// 7 = residues with lone pairs.
// 8 = Carbon alpha structure

const LIBMATCH_NOTINLIB		= 0;
const LIBMATCH_EXACT		= 1;
const LIBMATCH_MULTI		= 2;
const LIBMATCH_DIFFRNAME	= 3;
const LIBMATCH_WEAK		= 4;
const LIBMATCH_RNAME		= 5;
const LIBMATCH_NOATOMS		= 6;
const LIBMATCH_LPATOMS		= 7;
const LIBMATCH_CASTRUCT		= 8;

static CNTXT_libmatch;		// mask of length CNTXT_rkeys. 
static CNTXT_serial;		// serial numbers of residues in CNTXT_rkeys.

static CNTXT_strongmatch_xres;	// residue library index
static CNTXT_strongmatch_xatoms;// atom match index from residue library.

static CNTXT_weakmatch_xres;	// residue library index
static CNTXT_weakmatch_xatoms;	// atom match index from residue library.

static CNTXT_rnamematch_xres;	// residue library index

// ===== LISTBOX STATICS ===== //

static SPREP_Listbox_xprob;	// residue index of error
static SPREP_Listbox_selmask;	// selection mask
static SPREP_Listbox_typemask;	// mask of ptypes shown in listbox.
static SPREP_Listbox_active;	// nest vector where each one is length of
				// contxt(1). 1 indicates the specific error
				// that residue is active.
				// NOT CURRENTLY USED. MAY BE USED IN LATER VER.

// ===== PROBLEM STATICS ===== //

static SPREP_prob;		// nested vector of problems. This will be
				// created by calling the diagnose plug-in
				// functions. For more information 
				// see proprep_XXX function below.
static SPREP_disabled;		// Types that are disabled. Save them so that
				// When using the types box there is no
				// need to rediagnose the system.
static SPREP_fcn;		// Statics dealing with structure prep driver
				// functions
static SPREP_RLIB;		// amber10 residue library
static SPREP_wkey;		// Window keys for structure prep panel
static SPREP_chains;		// Used to pass chains to fix only.
static SPREP_graphics;		// Static contains call back to remove
				// graphics (whether they are grobs or
				// labels).

const SPREP_RKEYS	= 1;	// RKEYS  index into SPREP_prob
const SPREP_XTYPE	= 2;	// TYPE	  index into SPREP_prob
const SPREP_TXT		= 3;	// TXT	  index into SPREP_prob
const SPREP_DATA	= 4;	// DATA	  index into SPREP_prob
const SPREP_FIX		= 5;	// FIX	  index into SPREP_prob
const SPREP_SERIAL	= 6;	// SERIAL index into SPREP_prob

// ===== MONITOR STATICS ===== //

static SPREP_updatestate;	// Has there already been an update trigger
static SPREP_renderstate;	// Current render state
static SPREP_setstate;		// Current keys in sets
static SPREP_ctagstate;		// current chain tags in the system
static SPREP_cselstate;		// Current chain selection
static SPREP_ffstate;		// serial number of current forcefield
static SPREP_brickstate;	// Is the panel bricked
static SPREP_panelsensitivity;	// mask of length panel buttons indicating
				// the sensitivity of the buttons.

// ===== SPREP_Listbox accessor functions

local function get_SPREP_Listbox_values error_type
    if error_type <> ALL_ERR then
	return [
	    SPREP_Listbox_xprob(error_type),
	    SPREP_Listbox_selmask(error_type),
	    SPREP_Listbox_active(error_type)
	];
    else
	return [
	    SPREP_Listbox_xprob,
	    SPREP_Listbox_selmask,
	    SPREP_Listbox_active
	];
    endif
endfunction

local function get_SPREP_Listbox_selmask error_type
    if error_type <> ALL_ERR then
	return SPREP_Listbox_selmask(error_type);
    else
	return SPREP_Listbox_selmask;
    endif
endfunction

local function set_SPREP_Listbox_values [xprob,selmask,active,error_type]
    if error_type <> ALL_ERR then
	SPREP_Listbox_xprob(error_type) = xprob;
	SPREP_Listbox_selmask(error_type) = selmask;
	SPREP_Listbox_active(error_type) = active;
    else
	SPREP_Listbox_xprob = xprob;
	SPREP_Listbox_selmask = selmask;
	SPREP_Listbox_active = active;
    endif
endfunction

local function set_SPREP_selmask_from_mask [selmask,error_type]
    if error_type <> ALL_ERR then
	SPREP_Listbox_selmask(error_type) = selmask;
    else
	SPREP_Listbox_selmask = selmask;
    endif
endfunction

// FUNCTION:	Generates a rmask of CNTXT_rkeys from the currently selected
//		errors in the listbox. 
// INPUT:	error_type
// RETURN:	residue mask of length CNTXT_rkeys

local function SPREP_rmask_from_selmask error_type; 
    local rmask = zero CNTXT_rkeys;
    local [xprob,selmask,active] = get_SPREP_Listbox_values error_type;
    local rkeys = uniq (first SPREP_prob)[xprob|selmask];
    rmask[indexof[rkeys,CNTXT_rkeys]] = 1;
    return rmask;
endfunction

// FUNCTION:	Create a mask of length xprob identifying the current problems
//		shown in the listbox.
// INPUT:	xprob, active
// RETURN:	mask of length xprob

local function get_Listbox_line_mask [xprob,active]
    local xmask;
    local prob = apt get [SPREP_prob,[xprob]];
    local type_idx = indexof [second prob, SPREP_fcn.ptype];
    xmask = active and SPREP_Listbox_typemask[type_idx];
    return xmask;
endfunction

// FUNCTION:	Set the listbox selection mask by indifying a line in the
//		listbox
// INPUT:	Line selection, error type
// RETURN:	NULL

local function set_SPREP_selmask_from_linenumber [sel, error_type]
    local [xprob,selmask,active] = get_SPREP_Listbox_values error_type;
    local xid = x_pack get_Listbox_line_mask [xprob,active];
    selmask = zero selmask;
    selmask[xid[sel]]=1;

    local type_idx = indexof [
	(second SPREP_prob)[xprob],
	SPREP_fcn.ptype
    ];

    SPREP_Listbox_selmask(error_type) = selmask
	and active
	and SPREP_Listbox_typemask[type_idx];

endfunction

// FUNCTION:	Set the selection mask to what is currently selection in the
//		listbox
// INPUT:	window values
// RETURN:	[]

local function set_SPREP_selmask_from_window wval
    local sel = wval.major_list(1);
    set_SPREP_selmask_from_linenumber [sel,ERRTYPE.issues];
    sel = wval.minor_list(1);
    set_SPREP_selmask_from_linenumber [sel,ERRTYPE.prot];

    sel = wval.warning_list(1);
    set_SPREP_selmask_from_linenumber [sel,ERRTYPE.warning];
endfunction

// FUNCTION:	return a mask of the errors on a listbox
//		(identified by error_type)
// INPUT:	error_type, problem types
// RETURN:	mask of length ptypes

local function m_errtype [error_type,ptypes]
    if isnull ptypes then ptypes = second SPREP_prob; endif
    return m_join [
	ptypes,
	SPREP_fcn.ptype | SPREP_fcn.error_type == error_type
    ];
endfunction

// FUNCTION:	return ids of the errors on a listbox
//		(identified by error_type)
// INPUT:	error_type, problem types
// RETURN:	ids of ptypes of listbox error_type

local function x_errtype [error_type,ptypes]
    if isnull ptypes then ptypes = second SPREP_prob; endif
    return x_join [
	ptypes,
	SPREP_fcn.ptype | SPREP_fcn.error_type == error_type
    ];
endfunction

// ===== SENSITIVITY ===== //

local function _panel_Sensitive val
    local xprob,selmask,active;
    [xprob,selmask,active] = get_SPREP_Listbox_values val.radio_error_type;

	// If nothing is selected check to see if there is something in the
	// listbox which can be corrected. Is something is selected can it
	// be correct.

    local rkeys = CNTXT_rkeys | oValid CNTXT_rkeys;

    local correct_flag = SPREP_prob(SPREP_FIX);
    if allfalse selmask and length rkeys then
	correct_flag = orE correct_flag[xprob];
    else
	correct_flag = orE correct_flag[xprob|selmask];
    endif

    local p3d_flag = length cat oAtoms rkeys;
    WindowSetAttr [SPREP_wkey, [panel: [sensitive: [correct_flag,p3d_flag,1]]]];
endfunction

// ===== Initialize driver functions ===== //

// FUNCTION:	Get fcn names, ids and actions for Structure Prep
// INPUT:	options
// RETURN:	[];

local function proprep_charge;
local function proprep_forcefield;
local function proprep_missH;
local function proprep_library;
local function proprep_atomname;
local function proprep_topology;
local function proprep_metal;
local function proprep_se;
local function proprep_cb;

local function initialize_SPREP_fcn opt 
    local prio = task_prio 0;
    local pfcn = sym_find_f 'proprep_*';
    local u_var = tok_drop [pfcn,8];

    pfcn = cat [
	pfcn,
	#proprep_forcefield,
	#proprep_library,
	#proprep_atomname,
	#proprep_topology,
	#proprep_metal,
	#proprep_se,
	#proprep_missH,
	#proprep_cb,
	#proprep_charge
    ];

    u_var = cat [u_var,
	'forcefield',
	'library',
	'atomname',
	'topology',
	'metal',
	'se',
	'missH',
	'cb',
	'charge'
    ];

	// Get currently loaded types. If no type returned exit.

    local types = rep [[], length pfcn];
    local ntypes = zero pfcn;
    local i;
    for i=1, length pfcn loop

	types(i) = call [pfcn(i), 'type'];
	if isnull types(i) then
	    exit
		'Driver function returned no type. Type has\n'
		'the following format:\n'
		'[Type, Priority, Summary Help, Summary Group]'
	    ;
	endif
	ntypes(i) = length first types(i);
	types(i) = apt resize [ types(i), l_length types(i)];
    endloop

	// For debuging purposes.

    local [ptype,pprio,phelp,psumgroup] = apt cat types;
    if length uniq cat ptype <> length uniq cat ptype then
	exit 'Number of unique abbreviations and names do not match';
    endif

	// Since driver functions can return multiple types stretch
	// pfcn to number of returned types.

    pfcn = stretch [pfcn,ntypes];
    u_var = stretch [u_var,ntypes];
    [pfcn,u_var,ptype,phelp,pprio,psumgroup] = apt get [
	[pfcn,u_var,ptype,phelp,pprio,psumgroup],
	[x_sort pprio]
    ];

    SPREP_fcn.pfcn		= pfcn;
    SPREP_fcn.u_var		= u_var;
    SPREP_fcn.xpfcn		= indexof [pfcn, uniq SPREP_fcn.pfcn];
    SPREP_fcn.prio		= pprio;
    SPREP_fcn.priomask		= SPREP_fcn.prio < ERRTYPE.prot;
    SPREP_fcn.phelp		= phelp;
    SPREP_fcn.ptype		= ptype;
    SPREP_fcn.psumgroup		= psumgroup;

	// Do all abbr come from same driver.

    local [name,fcn] = apt get [[ptype,SPREP_fcn.pfcn],[x_sort ptype]];
    fcn = split [fcn,mtoc m_uniq name];
    local thesame = app eqL fcn;
    if anyfalse thesame then
	local txt = apt twrite [
	    '{t:} returned by {}\n',
	    (uniq name) | not thesame,
	    app uniq (fcn | not thesame)
	];
	exit twrite [
	    'Multiple driver functions return same problem types:\n{t:}', txt
	];
    endif

	// Account for cases where the prio is less then 1 or greate then 3.

    local error_type = floor SPREP_fcn.prio;
    error_type | error_type < ERRTYPE.issues = ERRTYPE.issues;
    error_type | error_type > ERRTYPE.warning = ERRTYPE.warning;
    SPREP_fcn.error_type = error_type;

	// Assemble groups for summary page in panel. Remove cases that we
	// want to hide.

    error_type = error_type | m_uniq psumgroup and psumgroup <> '';
    SPREP_fcn.u_group_error_type = error_type;
    psumgroup = psumgroup | psumgroup <> '';
    SPREP_fcn.u_psumgroup = uniq psumgroup;

	// Initialize statics

    SPREP_Listbox_typemask = m_diff [SPREP_fcn.ptype, opt.disableTypes];
    SPREP_Listbox_xprob = rep [[], length ERRTYPE];
    SPREP_Listbox_selmask = rep [[], length ERRTYPE];
    SPREP_Listbox_active = rep [[], length ERRTYPE];
    SPREP_updatestate =0;

    task_prio prio;
endfunction

// ===== CNTXT and LIB FUNCTIONS ===========================================

// SPREP_rlib_term
// 0 = Polymer
// 1 = c terminus
// 2 = n terminus

static SPREP_rlib_term;
static SPREP_rlib_rname;
static SPREP_rlib_rclass;

local function _amber_ResidueLibrary lib;
    local rlib = amber_ResidueLibrary lib;

    local std_rname = apt tagpeek [rlib, 'rName'];
    local resmol = apt tagpeek [rlib,'mol'];
    local rtype = apt get [cat apt get [resmol,3],MOL_RES_TYPE];
    local x_amino = x_pack (rtype == 'amino');
    local x_xna = x_pack m_join [rtype, ['rna','dna']];
    local bb;

	// ==== ENTER PRIVATE SYSTEM ===== //

    local osys = SystemPush [];

	// Create amino acids.

    local ch = app mol_Create resmol[x_amino];
    local res = Residues [];

	// Which are c termini.

    bb = app cat apt sm_MatchAtoms [CTERMINUS_MATCH, rAtoms res];
    local x_cterm = x_amino | app length bb;

	// Which are n termini.

    bb = app cat apt sm_MatchAtoms [NTERMINUS_MATCH, rAtoms res];
    local x_nterm = x_amino | app length bb;

    SystemPop osys;

    SPREP_rlib_term = zero std_rname;
    SPREP_rlib_term[x_cterm] = 1;
    SPREP_rlib_term[x_nterm] = 2;

    SPREP_rlib_rname = std_rname;
    SPREP_rlib_rclass = apt tagpeek [rlib, 'rClass'];

    return rlib;
endfunction

// RESIDUE TRIAGE

// CNTXT_libmatch definiation
// exact match 	= If residue if found in library using strongmatch criteria
//		  (aNamePriority : 0, aHeavy : 0)
// 0 = not found at all in library.
// 1 = One exact match found in library with exact rName Match.
// 2 = Multiple exact matches found in library
// 3 = inconsistant rName match.
// 4 = Sigma only match is found in library
// 5 = rName only match is found in library
// 6 = residue with no atoms.
// 7 = Residues with lone pair atoms.
// 8 = Carbon alpha structure

const STRONGMATCH_OPT = [
    level : 2,
    stereo :2
];

const WEAKMATCH_OPT = [
    level : 0,
    stereo :1
];

// FUNCTION:	get entries in amber10.mdb which have the same name as rkeys(i)
//		Remove/keep termini from name match
// INPUT:	rkeys,has bond to residue on left, has bond to residue on right
// RETURN:	idx into amber10.mdb for rName match.

local function get_ResidueNameMatch [rkeys, m_ct, m_nt]
    local std_rname = SPREP_rlib_rname;
    local idx = indicesof [rName rkeys,std_rname];
    local m_amino = rIsAmino rkeys;

    local i;
    local x_ct = x_pack (SPREP_rlib_term == 1);
    local x_nt = x_pack (SPREP_rlib_term == 2);
    for i = 1, length rkeys loop
	if
		m_amino(i)
	    and not m_ct(i)
	    and not m_nt(i)
	    and rAtomCount rkeys(i)
	then	// Both N and C
	    idx(i) = join [idx(i),cat [x_ct, x_nt]];
	elseif m_amino(i) and m_ct(i) and not m_nt(i) then	// N term
	    idx(i) = join [idx(i),x_nt];
	elseif m_amino(i) and m_nt(i) and not m_ct(i) then	// C term
	    idx(i) = join [idx(i),x_ct];
	elseif m_amino(i) and m_ct(i) and m_nt(i) then		// Polymer
	    idx(i) = diff [idx(i),cat [x_ct, x_nt]];
	endif
    endloop
    return idx;
endfunction

// FUNCTION:	Get Backbone atoms of rkeys
// INPUT:	rkey
// RETURN:	backbone atoms

local function get_BackboneAtoms rkey
    local atoms = cat rAtoms rkey;
    local bb = sm_MatchAll [PRO_BB_WEAKMATCH,atoms];
    if isnull cat bb then return []; endif

    local i;
    if length bb > 1 then
	local O = app second bb;
	if orE (aName O == 'O')   then bb = bb | aName O == 'O'  ; endif
	if orE (aName O == 'OXT') then bb = bb | aName O == 'OXT'; endif
	if length bb > 1 then bb = first bb; endif
    endif

    bb = cat bb;

	// is is a wierd case where it is a or Ser THR with missing O.

    const BACKBONE = [
	1, '[C](~O)(~[C])~[N]',
	1, '[CX3H1](~[O])(~[C])',
	1, '[CX4H2](~[O])(~[C])'
    ];

    if sm_Match [BACKBONE, first bb] then
	return bb;
    else
	return [];
    endif
endfunction

// FUNCTION:	Compare chirality of rkeys(i) to entry xres(i) in amber10.mdb
// INPUT:	rkeys, ids into amber10.mdb
// RETURN:	mask of length rkeys 1 = match.

local function compareCAChirality [rkeys, xres]
    if isnull xres then return []; endif

    local bb = get_BackboneAtoms rkeys;

	// Acounts for cases where there is an issue with the backbone.

    if isnull bb then return one xres; endif

    local [c,o,ca,n] = bb;
    local cb = cat aBonds ca;
    cb = diff [cb, bb];

	// Is it glycine?

    if andE ((aElement cb) == 'H') then
	return one xres;
    endif

	// Is it some modified AA?

    if andE ((aElement cb) <> 'H') and length cb <> 1 then
	return one xres;
    endif

    cb = cb | (aElement cb <> 'H');

	// If more then 1 heavy atoms return 1;

    if length cb <> 1 then return one xres; endif

    local rsign = aDihedralCWDeg [n,cb,ca,c] > 0;


	// =====Enter private system ===== //

    local osys = SystemPush [];

	// Create atoms of matching mol to get RS chirality for CA.

    local mol = apt tagpeek [SPREP_RLIB[xres],'mol'];
    local rclass = apt tagpeek [SPREP_RLIB[xres],'rClass'];
    local ch = app mol_Create mol;

    bb = apt sm_MatchAll [PRO_BB_MATCH, cAtoms ch];
    local i;
    if orE ((app length bb) > 1) then
	for i=1, length bb loop
	    local O = app second bb(i);
	    bb(i) = bb(i) | aName O == 'O';
	    if length bb(i) > 1 then bb(i) = app first bb(i); endif
	endloop
    endif
    bb = app cat bb;

    local msign = zero xres;

    for i=1, length bb loop
	[c,o,ca,n] = bb(i);
	cb = cat aBonds ca;
	cb = diff [cb, bb(i)];

	    // Is it glycine?

	if andE ((aElement cb) == 'H') then
	    msign(i) = rep [rsign, length xres];
	    continue;
	endif

	    // Is it some modified AA?

	if andE ((aElement cb) <> 'H') then
	    msign(i) = rep [rsign, length xres];
	    continue;
	endif

	cb = cb | (aElement cb <> 'H');

	msign(i) = aDihedralCWDeg [n,cb,ca,c] > 0;

    endloop

    SystemPop osys;

	// ===== Exit private system ===== //

    return (rsign == msign);
endfunction

// FUNCTION:	Enhancement to amber_ResidueLookup
//		- If more then match is found, keep only the one with the
//		  exact rName match otherwise keep all.
// 		- If it is a weak match compare CA chirality, remove ones
//		  where it does not match.
// INPUT:	same as amber_ResidueLoop, library, residue keys, options
// RETURN:	idx into amber10.mdb, atoms which match mol of idx in mdb

local function _amber_ResidueLookup [rlib,rkeys,opt]

    local [xres,xatoms]= amber_ResidueLookup [rlib,rkeys,opt];

	// Acount for ambiguous residues (any residue which matches more then
	// one template. This will be handled in nstdres functions.

    local x_gt1 = x_pack (app length xres > 1);
    local i;
    local samename;
    for i=1, length x_gt1 loop

	    // length xres(i) > 2 key check for backbone chirality

	if
		opt.stereo > 0
	    and rIsAmino rkeys(x_gt1(i))
	    and length xres(x_gt1(i)) > 1
	then

	    local sameChirality = compareCAChirality [
		rkeys(x_gt1(i)),
		xres(x_gt1(i))
	    ];

	    if isnull sameChirality then continue; endif

	    xres  (x_gt1(i)) = xres  (x_gt1(i)) | sameChirality;
	    xatoms(x_gt1(i)) = xatoms(x_gt1(i)) | sameChirality;
	endif

	    // Prioritize rName agreement.

	samename = (rName rkeys(x_gt1(i)) == SPREP_rlib_rname[xres(x_gt1(i))]);
	samename | not app length samename = 0;
	if orE samename then
	    xres  (x_gt1(i)) = xres  (x_gt1(i)) | samename;
	    xatoms(x_gt1(i)) = xatoms(x_gt1(i)) | samename;
	elseif opt.level == 0 and allfalse samename then
	    xres  (x_gt1(i)) = [];
	    xatoms(x_gt1(i)) = [];
	endif

	   // Prioritize rClass agreement.

	samename = (rName rkeys(x_gt1(i)) == SPREP_rlib_rclass[xres(x_gt1(i))]);
	samename | not app length samename = 0;
	if orE samename then
	    xres  (x_gt1(i)) = xres  (x_gt1(i)) | samename;
	    xatoms(x_gt1(i)) = xatoms(x_gt1(i)) | samename;
	elseif opt.level == 0 and allfalse samename then
	    xres  (x_gt1(i)) = [];
	    xatoms(x_gt1(i)) = [];
	endif

    endloop

    return [xres,xatoms];
endfunction

// FUNCTION:	groups residues into classes as defined by CNTXT_libmatch
// INPUT:	rkeys
// RETURN:	NULL but initialize CNTXT_xxx staticss

local function triageResidues rkeys
    local [xres,xatoms]= _amber_ResidueLookup [
	SPREP_RLIB,
	rkeys,
	STRONGMATCH_OPT
    ];

    CNTXT_strongmatch_xres = xres;
    CNTXT_strongmatch_xatoms = xatoms;

    local match = app length xres;

	// If there are multiple matches mark match = 2;

    match | (app length xres > 1) = LIBMATCH_MULTI;

	// Check rName agreement
	// When there is only one match in library ensure rName agreement
	// otherwise mark match as 2.

    local x_exact = x_pack (match == LIBMATCH_EXACT);
    local i, librname, librclass, m;
    for i=1, length x_exact loop
	librname = SPREP_RLIB(xres(x_exact(i))).rName;
	librclass = SPREP_RLIB(xres(x_exact(i))).rClass;
	m =   ( ( rName rkeys( x_exact(i) ) ) <> librname )
		and ( ( rName rkeys( x_exact(i) ) ) <> librclass )
	;
	if m then match(x_exact(i)) = LIBMATCH_DIFFRNAME; endif
    endloop

	// Do Weak match

    [xres,xatoms]= _amber_ResidueLookup [SPREP_RLIB,rkeys,WEAKMATCH_OPT];
    CNTXT_weakmatch_xres = xres;
    CNTXT_weakmatch_xatoms = xatoms;
    match | (app length xres) and (not match) = LIBMATCH_WEAK;

	// If there are multiple matches mark match = 2;

    match | (app length xres > 1) and (match == LIBMATCH_WEAK) = LIBMATCH_MULTI;

	// Check rName agreement
	// When there is only one match in library ensure rName agreement
	// otherwise mark match as 2.

    x_exact = x_pack (match == LIBMATCH_WEAK);
    for i=1, length x_exact loop
	librname = SPREP_RLIB(xres(x_exact(i))).rName;
	librclass = SPREP_RLIB(xres(x_exact(i))).rClass;
	m =   ( ( rName rkeys( x_exact(i) ) ) <> librname )
		and ( ( rName rkeys( x_exact(i) ) ) <> librclass )
	;
	if m then match(x_exact(i)) = LIBMATCH_NOTINLIB; endif
    endloop

	// If it is a polymer (amino,rna,dna) remove boundary cases
	// (Chain breaks and termini) since we can not trust the goldplated
	// status of the residue.

    local m_amino = m_join [rType rkeys, ['amino','rna','dna']];
    local break_test = split [rkeys, mtoc m_uniq oParent rkeys];
    local lhs = cat apt rIsBonded [break_test, app rotr break_test];
    local rhs = cat apt rIsBonded [break_test, app rotl break_test];

    CNTXT_rnamematch_xres = get_ResidueNameMatch [rkeys, rhs, lhs];
    match | (app length CNTXT_rnamematch_xres) and (not match) = LIBMATCH_RNAME;
    match | rAtomCount rkeys == 0 = LIBMATCH_NOATOMS;

	// Is there a residue containing a dummy atom.

    match | app orE (
	    aElement rAtoms rkeys == 'LP'
	and aBondCount rAtoms rkeys == 0
    ) = LIBMATCH_LPATOMS;

	// Carbon alpha only residues

    local atoms = rAtoms rkeys;
    atoms = atoms || not aIsLight atoms;

    match |
	    (app andE (aName atoms == 'CA'))	// Atoms have CA as atomname
	and rIsAmino rkeys			// Is amino acid
	and app length atoms == 1		// Only 1 atom/residue
    = LIBMATCH_CASTRUCT;

    match |
	    (app andE (aName atoms == 'P'))	// Atoms have P as atomname
	and rIsNucleic rkeys			// Is dna or rna
	and app length atoms == 1		// Only 1 atom/residue
    = LIBMATCH_CASTRUCT;

    CNTXT_libmatch = match;
    CNTXT_serial = oSerialNumber rkeys;
endfunction

const SYSDEF_OPTIONS = [
    'All Chains',
    'Selected Chains',
    'Unselected Chains'
];

// FUNCTION:	Get residue keys as defined by the system_defn pager
// INPUT:	NULL
// RETURN:	residue keys

local function get_cntxt []
    local rkeys;
    local val = WindowGetData [SPREP_wkey,'system_defn'];
    local ch = noPrivateChains [];
    if length diff [val.system_defn, SYSDEF_OPTIONS] then // Chain Tag
	ch = ch | (cTag ch == val.system_defn);
	rkeys = cat oChildren ch;
    elseif val.system_defn == SYSDEF_OPTIONS(1) then	// All Chains 
	rkeys = cat cResidues ch;
    elseif val.system_defn == SYSDEF_OPTIONS(2) then	// Sel Chains
	rkeys = cat oChildren SelectedChains [];
    elseif val.system_defn == SYSDEF_OPTIONS(3) then	// Unselected Chains
	rkeys = cat oChildren diff [ch, SelectedChains []];
    endif

	// remove dummy

    return rkeys;
endfunction

// FUNCTION:	Initialize all CNTXT variables.
// INPUT:	NULL
// RETURN:	NULL

local function initialize_cntxt [] 

	// rkeys will be all active residue keys in system. To be considered
	// inactive all atoms of a residue must have aInert == 1.

    local newrkeys;

	// If wkey exist then we are in interactive mode, otherwise in cli.

    if length SPREP_wkey then
	newrkeys = get_cntxt [];
    elseif length SPREP_chains then
	SPREP_chains = SPREP_chains | oValid SPREP_chains;
	newrkeys = cat cResidues SPREP_chains;
    else
	newrkeys = Residues [];
    endif

	// I need to sort residues from n to c terminus

    newrkeys = newrkeys[x_sort indexof[newrkeys, Residues []]];

    CNTXT_rkeys = newrkeys;

    triageResidues newrkeys;
endfunction

// ===== SELECTION FUNCTIONS =================================================

// FUNCTION:	Get keys to be isolated
// INPUT:	Error type
// RETURN:	residue keys to be isolated

local function get_isolate_keys error_type
    local [xprob,selmask,active] = get_SPREP_Listbox_values error_type;
    local problems = apt get [SPREP_prob, [xprob|selmask]];
    local allxpfcn = indexof[
	second problems,
	SPREP_fcn.ptype
    ];
    local xfcn,keys;
    for xfcn in (uniq allxpfcn) loop

	local [result, code] = task_call [
	    SPREP_fcn.pfcn(xfcn),
	    ['isolate', [CNTXT_rkeys,problems || [allxpfcn == xfcn]]],
	    [master: 'parent', errmsg : 'ignore']
	];

	if code <> '' and DEBUG then
	    exit result;
	elseif code <> '' then
	    WindowTrigger [SPREP_wkey, [update_system:1]];
	    return [];
	else
	    keys = cat [keys, result];
	endif
    endloop
    return keys;
endfunction

// FUNCTION:	Isolate selected residue in listbox defined by error type
// INPUT:	window values
// RETURN:	NULL

local function isolate_selected val;
    if not val.autoIsolate then return; endif
    local keys = get_isolate_keys val.radio_error_type;
    if length keys then
	local atoms = cat oChildren CNTXT_rkeys;
	local mask = m_join [atoms, cat oAtoms keys];
	local selatoms = atoms | mask;
	Isolate [selatoms, atoms | not mask];
    endif
endfunction

// FUNCTION:	Set or briefly flash atoms and residue selection in MOE
//		according to list list selection.
// INPUT:	keys to be selectws, keep = 1 to set selection, 0 to flash.
// RETURN:	NULL

local function show_selection [keys, keep]
    local allatoms = Atoms[];
    local atoms = uniq cat oAtoms keys;
    local oldasel = aSelected allatoms;
    local allres = Residues[];
    local res = uniq cat oResidues keys;
    local oldrsel = rSelected allres;

    if keep then
	aSetSelected [allatoms, indexof [allatoms, atoms]];
	rSetSelected [allres, indexof [allres, res]];
    else

	aSetSelected [allatoms, 0];
	rSetSelected [allres, 0];
	sleep 0.2;
	aSetSelected [allatoms, indexof [allatoms, atoms]];
	rSetSelected [allres, indexof [allres, res]];
	sleep 0.5;
	aSetSelected [allatoms, oldasel];
	rSetSelected [allres, oldrsel];
    endif
endfunction

// FUNCTION:	Get pocket atoms
// INPUT:	atoms of what you consider your universe
// RETURN:	atoms close to the pocket

local function get_pocket_atoms atoms
    const PACKET = 50;
    local sel_atoms = join [atoms, _Atoms '$$ligand'];

    local r = max [0, 4.5];
    local mask = zero atoms;

    local x;
    for x in split [x_id atoms, PACKET] loop
	local key = prox_open [r, aPos atoms[x], r/2];
	local idx = uniq second prox_find [ key, aPos sel_atoms, r/2 ];
	prox_close key;
	mask = put [mask, x[idx], 1];
    endloop

    return atoms | mask;
endfunction


const SELECT_OPT = [
    'Select',
    'Receptor',
    'Ligand',
    'Solvent',
    'Selected Atoms',
    'Selected Residues',
    'Select in MOE'
];

const SELECT_WARNINGS = [
    'There is no receptor in the system.',
    'There is no ligand in the system.',
    'There are no solvent molecules in the system.',
    'No atoms are currently selected.',
    'No residues are currently selected.',
    'No items in the list currently selected.'
];

// FUNCTION:	Set list box selection according to window select options
// INPUT:	window values.
// RETURN :	[]

local function set_Listbox_selection val

    local error_type = val.radio_error_type;
    local actns = val.set_listbox_sel;

    local rmask,xres,isolate_rmask;

    local mask,idx;
    local pnlFcn,pnlIdx;

    local rkeys = CNTXT_rkeys;

    function set_SPREP_Listbox_selmask_from_res [selected_res,error_type]
	local [xprob,selmask,active] = get_SPREP_Listbox_values error_type;
	local res = (first SPREP_prob) | m_errtype [error_type];
	selmask = m_join [res,selected_res];
	selmask = selmask and active;
	set_SPREP_Listbox_values [xprob,selmask,active,error_type];
    endfunction

    local xprob,selmask,active,warning_txt;

	// Get Receptor residues

    if actns == indexof ['Receptor',SELECT_OPT] then
	rkeys = uniq oResidues _Atoms '$$receptor';

	// Get solvent residues

    elseif actns == indexof ['Solvent',SELECT_OPT] then
	rkeys = uniq oResidues _Atoms '$$solvent';

	// Get Ligand residues

    elseif actns == indexof ['Ligand',SELECT_OPT] then
	rkeys = uniq oResidues _Atoms '$$ligand';

	// Get residues of selected atoms

    elseif actns == indexof ['Selected Atoms',SELECT_OPT] then
	rkeys = uniq aResidue SelectedAtoms [];

	// Get selected residues

    elseif actns == indexof ['Selected Residues',SELECT_OPT] then
	rkeys = SelectedResidues [];

	// Get residue with protected atoms

    elseif actns == indexof ['Protected',SELECT_OPT] then
	rkeys = uniq oResidues oGetCollection P3D_PROTECT_SET;

	// Get residue with unprotected atoms

    elseif actns == indexof ['Unprotected',SELECT_OPT] then
	rkeys = uniq oResidues oGetCollection P3D_PROTECT_SET;
	rkeys = diff [CNTXT_rkeys, rkeys];

	// Get which residue correspond to the list selection and select them
	// in MOE & the SEQ.

    elseif actns == indexof ['Select in MOE', SELECT_OPT] then
	rkeys = get_isolate_keys error_type;
	show_selection [rkeys,1];
    endif


	// Set list selection or warn if nothing was selected.

    if length rkeys and actns <> indexof ['Select in MOE', SELECT_OPT] then
	set_SPREP_Listbox_selmask_from_res [rkeys,error_type];
    elseif isnull rkeys then
	Warning SELECT_WARNINGS(actns-1);
    endif

    isolate_selected val;
endfunction

// ===== LISTBOX FUNCTIONS ====================================================

// FUNCTION: 	Get text for list box defined by error type.
// INPUT: 	error_type
// RETURN: 	error txt;

local function get_errlistbox_txt error_type 

	// Get current problems and remove one that we do not want to show.

    local [xprob,selmask,active] = get_SPREP_Listbox_values error_type;
    local res = (first SPREP_prob)[xprob];
    local ptype = (second SPREP_prob)[xprob];
    local etxt = (third SPREP_prob)[xprob];

	// Keep only valid residues which are active and whose type is
	// enabled

    local [lres,letxt,lptype,lactive] = [res,etxt,ptype,active] || [oValid res];
    [lres,letxt,lptype] = [lres,letxt,lptype] || [lactive];
    [lres,letxt,lptype] = [lres,letxt,lptype] || [
	m_join [lptype, SPREP_fcn.ptype | SPREP_Listbox_typemask]
    ];

	// Make sure to keep same selection

    //local lidx;
    local m  = m_join [
	tr [res,etxt],
	tr [lres,letxt]
    ];
    local tm = zero selmask;
    tm | m = (selmask | m);
    set_SPREP_selmask_from_mask [tm and active,error_type];

	// Find pocket residues

    local rkeys = CNTXT_rkeys | oValid CNTXT_rkeys;
    local pocket_res = uniq aResidue get_pocket_atoms cat rAtoms rkeys;
    local pocket_txt = rep [' ', length lres];
    pocket_txt | m_join [lres,pocket_res] = 'P';

    local format = cat ['{}\t{t:}\t{}\t{t:}\t{t:}\t{}\t{t:}\t{t:}\t{t:}'];

    local cname = rep ['', length lres];
    cname | lres = cName oParent (lres | lres);
    cname | not lres = '****';

    local cproxy = zero lres;
    cproxy | lres = cNumber oParent (lres|lres);


	// Acount for case where nothing but HCount is wrong.

    local N = cNumber oParent (lres|lres);
    if isnull N then N = 1; endif
    local chnameformat = twrite ['{{n:{t:}}:',inc floor log10 max N];
    chnameformat = tok_cat [chnameformat, '\t {t:}'];
    local cproxname = cproxy;
    cproxname | not cproxname = '*';
    cname = apt twrite [chnameformat, cproxname, cname];

    local rname = rep ['', length lres];
    rname | lres = rDisplayName (lres | lres);
    rname | not lres = '***';

    local ruid = rep ['', length lres];
    ruid | lres = rDisplayUID (lres | lres);
    ruid | not lres = ' ';
    local ruidproxy = ruid;
    ruidproxy | not lres = 0;

    return apt twrite [
	format,
	pocket_txt <> 'P',
	pocket_txt,
	cproxy,
	cname,
	rname,
	ruidproxy,
	ruid,
	lptype,
	letxt
    ];
endfunction

// FUNCTION: 	Update text in listbox of structure prep panel.
// INPUT:	NULL
// RETURN:	NULL, Set panel text.

local function update_listbox_txt []
    local major_txt,minor_txt,warning_txt;

	// Get list text

    major_txt = get_errlistbox_txt ERRTYPE.issues;
    minor_txt = get_errlistbox_txt ERRTYPE.prot;
    warning_txt = get_errlistbox_txt ERRTYPE.warning;

    local txt = [
	major_list   : [text : major_txt  , header : LIST_BY_ERR_HEADER],
	minor_list   : [text : minor_txt  , header : LIST_BY_ERR_HEADER],
	warning_list : [text : warning_txt, header : LIST_BY_ERR_HEADER]
    ];

	// !!! Window resizes due to presence of proxy even thought
	// it does not need. When proxy remove no resize occurs.

    __WindowSuspendResize SPREP_wkey;
    WindowSetAttr [SPREP_wkey, txt];
endfunction

// ===== NUMBER OF ERROR FUNCTIONS ===========================================

// FUNCTION:	Get number of errors
// INPUT:	NULL
// RETURN:	number of errors per summary group

local function get_number_err []

	// If no problems return 0, otherwise calculate the number of errors
	// for each uniq summary group.

    if isnull SPREP_prob then return zero SPREP_fcn.u_psumgroup; endif;
    local groups = pack indexof[
	second SPREP_prob,
	SPREP_fcn.ptype
    ];
    groups = SPREP_fcn.psumgroup[join [groups, x_pack SPREP_Listbox_typemask]];
    local nErr = freq [SPREP_fcn.u_psumgroup, groups];
    return nErr;
endfunction

// FUNCTION:	Create labels for summary widget on left of panel
// INPUT:	NULL
// RETURN:	Summary labels

const MAX_NTYPES_PER_GROUP = 10;
local function create_number_error_labels [] 

	// Create legend for summary page.

    local [types,groups,phelp] = [
	SPREP_fcn.ptype,
	SPREP_fcn.psumgroup,
	SPREP_fcn.phelp
    ] || [SPREP_fcn.psumgroup <> ''];

    [types,groups,phelp] = apt get [[types,groups,phelp], [x_sort groups]];
    [types,phelp] = apt split [[types,phelp], [mtoc m_uniq groups]];
    groups = uniq groups;
    [types,groups,phelp] = apt get [[types,groups,phelp], [
	x_sort indexof[groups,uniq SPREP_fcn.psumgroup]
    ]];

    local m = app length types > MAX_NTYPES_PER_GROUP;
    types | m = [[]];
    phelp | m = '';
    local x = x_pack (app length types > 1);
    local i;
    for i=1, length x loop
	phelp(x(i)) = apt twrite ['{t:}, {t:}\n', types(x(i)), phelp(x(i))];
	phelp(x(i)) = tok_drop [ tok_cat phelp(x(i)), -1];
    endloop

    local names = SPREP_fcn.u_psumgroup;
    local nNames = length names;

    local lblOpt = rep [
	[
	    'name',
	    'text',
	    'font',
	    'foreground',
	    'extendH',
	    'bubbleHelp'
	],
	nNames
    ];

    local lblValues = apt twrite ['{t:}',names];
    local col = rep ['none', length names];

	// if all types of a group are diable gray it out.

    col | m_diff [
	SPREP_fcn.u_psumgroup,
	uniq (SPREP_fcn.psumgroup | SPREP_Listbox_typemask)
    ] = 'gray';

    lblValues = tr [
	tok_cat ['lbl_', totok names],	// [kk] Hack: must revisit
	lblValues,
	rep ['medium',nNames],
	col,
	one names,
	phelp
    ];
    local labels = tag ['Label',apt tag [lblOpt, lblValues]];
    return labels;
endfunction

// FUNCTION: 	Update summary panel labels
// INPUT:	NULL
// RETURN:	return update label tags and their associate values.

local function update_number_err []
    local nErr = get_number_err [];
    local names = SPREP_fcn.u_psumgroup;
    local nNames = length names;

    local lblOpt = rep [
	['name','text','font','foreground','extendH', 'sensitive'],
	length nNames
    ];

    local lblValues = apt twrite ['{n:4}', nErr];
    local col;
    col = rep ['baseRed',length nErr];
    col | m_diff [SPREP_fcn.u_group_error_type,ERRTYPE.issues] = 'none';
    col | nErr == 0 = 'none';

	// if all types of a group are diable gray it out.

    local sens = m_join [
	SPREP_fcn.u_psumgroup,
	uniq (SPREP_fcn.psumgroup | SPREP_Listbox_typemask)
    ];

    local font = rep ['mediumBold', length nErr];
    font | nErr == 0 = 'medium';

    lblValues = tr [
	tok_cat ['nErr', names],
	lblValues,
	font,
	col,
	one names,
	sens
    ];
    return [lblOpt,lblValues];
endfunction

// FUNCTION: 	returns values for selection state of proprep panel.
// INPUT :	error_type
// RETURN:	[
//		    window data corresponding to lisbox selection
//		    window attr corresponding to button sensitivity
//		    panel number
//		]

local function update_panel_state error_type
    local esel,rsel,rsens,panelNum;
    local nextsens,prevsens;
    local data,attr,fcnidx;
    local activesens = [0,0];
    local moesens = 0;
    local nlines_selected_txt = '';

	// If context is null, all selection buttons are be disabled.

    if isnull CNTXT_rkeys then
	data = [major_list : [], minor_list : [],warning_list : []];
	attr =  [
	    epnl_pgr		: [page : 1],
	    prev		: [sensitive : 0],
	    next		: [sensitive : 0],
	    nlines_selected	: [text : nlines_selected_txt ]
	];
	fcnidx = 0;
	return [data,attr,fcnidx];
    endif

    local [xprob,selmask,active] = get_SPREP_Listbox_values ALL_ERR;
    local xfcn = 0;

	// Nothing is selected

    if allfalse selmask then
	nextsens = 0;
	prevsens = 0;
	esel = [];
	panelNum=1;
	xfcn = 0;
    else

	    // Get driver functions of selected items in list. If there is more
	    // Then one set as 0 (in other words no driver selected)

	xfcn = uniq indexof [
	    (second SPREP_prob)[xprob(error_type)|selmask(error_type)],
	    SPREP_fcn.ptype
	];
	if (length uniq SPREP_fcn.xpfcn[xfcn]) <> 1 then
	   xfcn =0;
	endif

	    // identify which line(s) in the listbox are selected.

	local lines = apt get_Listbox_line_mask [xprob,active];
	local x_esel = app x_pack lines;
	local x_selmask = app x_pack selmask;
	esel = app x_pack apt m_join [x_esel,x_selmask];

	if length esel(error_type) == 1 then
	    nlines_selected_txt = twrite [
		'{t:} issue selected',
		length esel(error_type)
	    ];
	else
	    nlines_selected_txt = twrite [
		'{t:} issues selected',
		length esel(error_type)
	    ];
	endif

	    // If at the begining of the list then desensitize previous.
	    // If at the end of the list then desensitize next.

	prevsens = alltrue (esel(error_type) <> 1);
	nextsens = alltrue (esel(error_type) <> length pack lines(error_type));

    endif

    data = [
	major_list : [esel(ERRTYPE.issues)],
	minor_list : [esel(ERRTYPE.prot)],
	warning_list : [esel(ERRTYPE.warning)]
    ];

	// If the panel is not bricked then set previous and next sensitivities.

    if not SPREP_brickstate then
	attr =  [
	    prev		: [sensitive : prevsens],
	    next		: [sensitive : nextsens],
	    nlines_selected	: [text : nlines_selected_txt ]
	];
    endif

    return [data,attr,xfcn];
endfunction

const DEF_REFUSAL = '';

// FUNCTION:	Update structure prep panel (sensitivities, txt)
// INPUT:	NULL
// RETURN:	NULL

local function update_sprep_panel []

    local val = WindowValues SPREP_wkey;
    local error_type = val.radio_error_type;

	// Update panel sensitivities.

    local [data,attr,xfcn] = update_panel_state error_type;

	// If something is selected allow driver function to preform an action.
	// If nothing is selection (or multiple driver functions) then set
	// default page.

    local [xprob,selmask,active] = get_SPREP_Listbox_values error_type;
    if alltrue xfcn <> 0 then
	xprob = xprob | selmask;
	local evnt_parms = [
	    CNTXT_rkeys,
	    apt get [SPREP_prob,[xprob]],
	    SPREP_wkey,
	    val
	];

	local panelNum = 0;
	if not SPREP_brickstate then
	    panelNum= uniq SPREP_fcn.xpfcn[xfcn];
	endif

	local refuse, code;
	if DEBUG == 2 then
	    refuse = token call [
		SPREP_fcn.pfcn(first xfcn),
		['panel_update',evnt_parms]
	    ];
	else
	    [refuse, code] = task_call [
		SPREP_fcn.pfcn(first xfcn),
		['panel_update',evnt_parms],
		[master: 'parent', errmsg: 'ignore']
	    ];

	    if code <> '' and DEBUG then
		exit token refuse;
	    elseif code <> '' then
		WindowTrigger [SPREP_wkey, [update_system:1]];
		return [];
	    else
		refuse = token refuse;
	    endif
	endif

	SPREP_graphics = cat second untag WindowGetData [
	    SPREP_wkey,
	    'sysprep_grobs'
	];

	if refuse == '' then
	    attr = tagcat [[epnl_pgr: [page : panelNum+1]],attr];
	elseif refuse <> '' then
	    attr = tagcat [
		[refusal_page : [text : refuse], epnl_pgr: [page : 1]],
		attr
	    ];
	endif
    else
	attr = tagcat [
	    [refusal_page : [text : DEF_REFUSAL], epnl_pgr: [page : 1]],
	    attr
	];
    endif

	// Update total number of errors on summary page

    function format_labels [lopt,lval]
	local [lname] = tr lval;
	local labels =  apt tag [apt drop [lopt,1],apt drop [lval,1]];
	labels = tag [
	    lname,
	    labels
	];
	return labels;
    endfunction;

    local [lopt,lval] = update_number_err [];

    local lnamesens = m_join [
	SPREP_fcn.u_psumgroup,
	uniq (SPREP_fcn.psumgroup | SPREP_Listbox_typemask)
    ];
    lnamesens = app nest tag ['sensitive',lnamesens];

    local ch = noPrivateChains [];

    attr = tagcat [attr,
	format_labels [lopt,lval],
	[system_defn : [text : cat [SYSDEF_OPTIONS, uniq cTag ch]]],
	tag [tok_cat ['lbl_', totok SPREP_fcn.u_psumgroup],lnamesens]
    ];

    WindowSetData [SPREP_wkey, data];
    WindowSetAttr [SPREP_wkey, attr];

endfunction

// ===== UPDATE SYSTEM =====================================================

// FUNCTION:	Update listbox values with new problems
// INPUT:	the old cntxt, serial and problems
// NULL: 	NULL

local function update_SPREP_Listbox_values [ocntxt_rkeys, ocntxt_serial, oprob]

	// Get old listbox values.

    local [oxprob,oselmask,oactive] = get_SPREP_Listbox_values ALL_ERR;

    local xprob = [[],length ERRTYPE];
    xprob(ERRTYPE.issues) = x_errtype [ERRTYPE.issues];
    xprob(ERRTYPE.prot) = x_errtype [ERRTYPE.prot];
    xprob(ERRTYPE.warning) = x_errtype [ERRTYPE.warning];

	// If a problem exists and was previously selected, select again.
	// Old problems, old xprob, new xprob, old mask and initialize value
	// Two problems are to classified as the same if the problem
	// types are the same.
	// !!! NOTE: this will fail when a a driver returns 2 problems for a
	// residue with the same type.
	// POSSIBLE FIX: create a uniq hash tag return by driver.

    function update_SPREP_mask [oprob,oxp,nxp,omask,initmask]

	    // Get previous serial

	local serial = last oprob;
	local oserial = apt get [[serial],oxp];

	    // Get new serial

	serial = last SPREP_prob;
	local nserial = apt get [[serial],nxp];

	    // If the previous selected key still exists and has the 
	    // same problems then reselect.

	local mask;

	if initmask then mask = one nxp; else mask = zero nxp; endif

	local thesame, oldsame;
	if length cat oserial then
	    local err_type;
	    local n_ser, n_maski;
	    local o_ser, o_maski;

		// Cycle through all error type and see if same errors exist.

	    for err_type in [ERRTYPE.issues,ERRTYPE.prot,ERRTYPE.warning] loop

		    // Need to account for nested xfcn.

		n_maski = mask(err_type);
		n_ser = nserial(err_type);

		o_maski = omask(err_type);
		o_ser = oserial(err_type);

		thesame = m_join [
		    o_ser,
		    n_ser
		];

		n_maski[indexof [
		    o_ser | thesame,
		    n_ser
		]] = o_maski | thesame;

		mask(err_type) = n_maski;
	    endloop
	endif
	return mask;
    endfunction

	// update ErrList selection mask.

    local active = update_SPREP_mask [oprob,oxprob,xprob,oactive,1];
    local selmask = update_SPREP_mask [oprob,oxprob,xprob,oselmask,0];
    selmask = selmask and active;
    set_SPREP_Listbox_values [xprob,selmask,active,ALL_ERR];
endfunction

// FUNCTION:	Gets current state of the system and updates cntxt, problems
//		listbox statics.
// INPUT:	[]
// RETURN:	[]

local function update_system [] 
    local pfcn = uniq SPREP_fcn.pfcn;

    local ocntxt_rkeys = CNTXT_rkeys;
    local ocntxt_serial = CNTXT_serial;
    local oprob = SPREP_prob;

	// Initialize newcntxt and re-diagnose problems.

    local time0 = clock [];
    initialize_cntxt [];
    if DEBUG == 2 then
	write [
	    '{n:.3f} {n:.9g} {n:.3f}\n',
	    clock [] -time0,
	    'Initialize CNTXT'
	];
    endif

    local prob = rep [[], length pfcn];
    local i;
    local fname;
    local prevState = SystemNonrenderState [];
    for i=1, length pfcn loop
	time0 = clock [];

	if DEBUG == 2 then
	    prob(i) = call [
		pfcn(i),
		['diagnose', CNTXT_rkeys]
	    ];
	else
	    local [result,code] = task_call [
		pfcn(i),
		['diagnose', CNTXT_rkeys],
		[master: 'parent', errmsg: 'ignore']
	    ];

		// If there is a crash and DEBUG == 1 then exit

	    if code <> '' and DEBUG then
		exit result;

		// Accounting for cases where the user cause a change in the
		// system causing the diagnose function to crash. A user
		// initiated is defined by a change in the
		// SystemNonRenderState.

	    elseif
		(code <> '')
		and (prevState <> SystemNonrenderState [])
	    then
		if length SPREP_wkey then
		    WindowTrigger [SPREP_wkey, [update_system:1]];
		endif
		return [];

		// If there has been no change in the render state then there
		// is a bug in the diganose function.

	    elseif code <> '' then
		task_kill task_keylist [];
		exit result;
	    else
		prob(i) = result;
	    endif
	endif
	if DEBUG == 2 then
	    if pfcn(i) == #proprep_forcefield then
		fname = 'proprep_forcefield';
	    elseif pfcn(i) == #proprep_atomname then
		fname = 'proprep_atomname';
	    elseif pfcn(i) == #proprep_library then
		fname = 'proprep_library';
	    elseif pfcn(i) == #proprep_topology then
		fname = 'proprep_topology';
	    elseif pfcn(i) == #proprep_metal then
		fname = 'proprep_metal';
	    elseif pfcn(i) == #proprep_se then
		fname = 'proprep_se';
	    elseif pfcn(i) == #proprep_missH then
		fname = 'proprep_missH';
	    elseif pfcn(i) == #proprep_cb then
		fname = 'proprep_cb';
	    elseif pfcn(i) == #proprep_charge then
		fname = 'proprep_charge';
	    elseif DEBUG then
		fname = pfcn(i);
	    endif
	    write ['{n:.3f} {n:.9g} {n:.3f}\n', clock [] -time0, fname];
	endif
	if isnull prob(i) then prob(i) = [[],[],[],[],[],[]]; endif
	prob(i) = apt resize [ prob(i), l_length prob(i)];
    endloop
    SPREP_prob = apt cat prob;

    if neL app length SPREP_prob then
	exit 'There is a bug in your driver function, fix it and try again';
    endif

    local xres = indexof [first SPREP_prob,CNTXT_rkeys];
    SPREP_prob = apt get [SPREP_prob,[x_sort xres]];

	// Remove disabled ptypes.

    local ptypes = second SPREP_prob;
    SPREP_disabled = SPREP_prob || [m_join [
	ptypes,
	SPREP_fcn.ptype | not SPREP_Listbox_typemask
    ]];

    SPREP_prob = SPREP_prob || [m_join [
	ptypes,
	SPREP_fcn.ptype | SPREP_Listbox_typemask
    ]];

	// Update listbox values

    update_SPREP_Listbox_values [ocntxt_rkeys, ocntxt_serial, oprob];

	// Update system states

    SPREP_renderstate = SystemNonrenderState [];
    SPREP_setstate = app oGetCollection oCollections [];
    SPREP_ctagstate = uniq cTag noPrivateChains [];
    SPREP_cselstate = SelectedChains [];
    SPREP_ffstate = (pot_Info []).serial;

	// Update text of panel. If txt is removed or shift in list
	// update selection.

	// If wkey exist then we are in interactive mode and we need to
	// update panel txt.

    if length SPREP_wkey then
	update_listbox_txt [];
	update_sprep_panel [];
    endif
endfunction

// ===== FIX ERRORS ==========================

// FUNCTION:	Return the unique problems of merged prob1 and prob2
// INPUT:	problems 1, problems 2
// RETURN:	unique set of problems

local function u_problems [prob1, prob2]
    if orE not app length prob1 then return prob2; endif
    if orE not app length prob2 then return prob1; endif
    local u_prob = cat [tr prob1,tr prob2];
    u_prob = tr uniq u_prob;
    return u_prob;
endfunction

// FUNCTION:	If a problem in prob2 exists in prob2 then remove it from prob1.
// INPUT:	problems 1, problems 2.
// RETURN:	problems 1 with one from problem 2 removed.

local function strip_problems [prob1, prob2]
    if orE not app length prob1 then return prob1; endif
    if orE not app length prob2 then return prob1; endif

    prob1 = tr diff [tr prob1,tr prob2];
    return prob1;
endfunction


//FUNCTION:	Fix errors as defined in problems
//INPUT:	error type
//RETURN:	NULL

local function fix_errors error_type
    local i=[];

	// Do a check to see if there are no problems. If click done then
	// prob = [] and therefore return [].

    if isnull SPREP_prob then return []; endif
    if error_type == ERRTYPE.warning then return []; endif

	// If errors exist then continue to prefrom checks. if n fcn tries
	// do not fix protein exit.

    local [xprob,selmask,active] = get_SPREP_Listbox_values error_type;
    local errExist;
    if error_type == 0 then
	xprob = cat xprob;
	selmask = one xprob;
    endif
    local nInt=0;

    local problems = apt get [SPREP_prob, [xprob | selmask]];
    problems = problems || [problems(SPREP_FIX) <> 0];

    local pfcn = SPREP_fcn.pfcn | SPREP_fcn.priomask;
    local notfixable = rep [[], length SPREP_prob];
    local m_fixable, msg_key = 0;

    for nInt=1, length pfcn
    while length first problems
    loop
	for i=1, length pfcn loop

		// Focus on one type of problem

	    local tmask = (second problems) == SPREP_fcn.ptype(i);
	    if allfalse tmask then continue; endif

		// If we are in interactive mode update panel refusal page
		// updating which error we are correcting.

	    local msg_txt = twrite [
		'Correcting {t:} {t:} {t:}',
		add tmask,
		SPREP_fcn.ptype(i),
		select ['issue', 'issues', (add tmask) == 1]
	    ];
	    msg_key = Message [
		msg_key,
		tok_cat ['Structure Preparation: ', msg_txt]
	    ];
	    if length SPREP_wkey then
		WindowSetAttr [SPREP_wkey, [ refusal_page: [ text :[msg_txt]]]];
	    endif

	    problems = problems || [tmask];

		// Fix problems and update system
		// !!! Protect with task_call

	    if DEBUG == 2 then
		m_fixable = call [ pfcn(i),
		    ['fix',	[CNTXT_rkeys,problems]]
		];
	    else
		local title;
		if length SPREP_wkey then
		    title = twrite [
			'Structure Preperation: {}',
			SPREP_fcn.ptype(i)
		    ];
		else
		    title = '';
		endif
		local [result, code] = task_call [ pfcn(i),
		    ['fix',	[CNTXT_rkeys,problems]],
		    [master:'parent', errmsg:'ignore', title:title]
		];

		if code <> '' and (DEBUG or isnull SPREP_wkey) then
		    exit result;
		elseif code <> '' then
		    update_system [];
		    return [];
		endif
		m_fixable = result;
	    endif
	    update_system [];

		// Get uniq problems which are not fixable.

	    if isnull m_fixable then m_fixable = zero (first problems); endif

	    notfixable = u_problems [notfixable, problems || [not m_fixable]];

		// Get new problems

	    [xprob,selmask,active] = get_SPREP_Listbox_values error_type;
	    if error_type == 0 then
		xprob = cat drop [xprob,-2];
		selmask = one cat drop [selmask,-2];
	    endif
	    problems = apt get [SPREP_prob, [xprob | selmask]];
	    problems = problems || [problems(SPREP_FIX) <> 0];
	    problems = strip_problems [problems, notfixable];
	endloop

	[xprob,selmask,active] = get_SPREP_Listbox_values error_type;
	if error_type == 0 then
	    xprob = cat xprob;
	    selmask = one xprob;
	endif
	problems = apt get [SPREP_prob, [xprob | selmask]];
	problems = problems || [problems(SPREP_FIX) <> 0];

	   // Remove problems which are not fixable.

	problems = strip_problems [problems, notfixable];
    endloop
    Message [msg_key, []];
endfunction

// ===== PANEL FUNCTIONS ====================================================

// FUNCTION:	Generate re/Cport detail of problems found in system.
// INPUT:	file name
// RETURN:	NULL

local function write_report file
    if isnull SPREP_prob then return []; endif;

    local pfcn = SPREP_fcn.pfcn;

    local fh = fopenw file;
    fwrite [fh,
	'STRUCTURE PREPARATION SUMMARY\n{}\n'
	'\n'
	'The issues identified are summarized below for '
	'the following system(s):\n',
	token asctime[]
    ];

    apt fwrite [fh, '{t:}\n', uniq cTag oParent CNTXT_rkeys];

    local nErr  = get_number_err [];
    local ndots = 35 - tok_length SPREP_fcn.u_psumgroup;
    local dots  = app token apt rep [".", ndots];
    local names = tok_cat [SPREP_fcn.u_psumgroup, dots];
    local dline = tok_cat rep ['-', 80];

    function hline txt
	return tok_cat rep ['=', tok_length txt];
    endfunction

    fwrite [fh,
	'\nSummary\n{t:}\n\n'
	'{t:}\n{t:-35} | {t:}\n{t:}\n',
	hline 'Summary',
	dline,
	'Problems',
	'Total',
	dline
    ];

    apt fwrite [fh, '{t:-35}   {t:}\n', names, nErr];
    fwrite [ fh, dline];

    local major_txt, minor_txt, warning_txt;

    major_txt = get_errlistbox_txt ERRTYPE.issues;
    minor_txt = get_errlistbox_txt ERRTYPE.prot;
    warning_txt = get_errlistbox_txt ERRTYPE.warning;

    function write_section [sectionname, format, header, txt]
	fwrite [
	    fh,
	    '\n\n{t:}\n{t:}\n\n',
	    sectionname,
	    hline sectionname
	];
	fwrite [fh,format,header(1),header(2),header(3),header(4),header(5)];
	fwrite [fh, '{t:}\n', dline];
	if isnull txt then
	    fwrite [fh,'NONE'];
	else
	    apt fwrite [fh, format, txt(1), txt(2), txt(3), txt(4), txt(5)];
	endif
    endfunction

    local txt = cat [major_txt, minor_txt, warning_txt];
    local m = cat [
	rep [1, length major_txt],
	rep [2, length minor_txt],
	rep [3, length warning_txt]
    ];
    txt = apt wordsplit [app string txt, "\t"];
    txt = apt drop [txt, 3];	// Drop pocket info;
    local cname = apt cat [app first txt, app second txt];
    txt = apt drop [txt, 2];	// Drop chain proxy;
    txt | app length txt == 4 = apt cat [txt | app length txt == 4, " "];
    txt = txt || [[1,0,1,1,1]];	// Drop RUID proxy;
    local i;
    for i=1, length txt loop
	txt(i) = cat [[cname(i)], txt(i)];
    endloop

    local header = wordsplit [string LIST_BY_ERR_HEADER, "\t"];
    header = drop [header, 1];
    header(1) = drop [header(1),-5];
    header(3) = drop [header(3),-3];

	// Need to account for cases where txt is ''.


    txt = tr txt;
    local ltxt = zero txt;
    for i = 1, length txt loop
	ltxt(i) = max app length txt(i);
	txt(i) = app token txt(i);
    endloop
    ltxt = ltxt + 1;
    ltxt = maxE [ltxt, app length header + 1];
    header = app token header;

    local format = twrite [
	'{{t:{t:}-}{{t:{t:}-}{{t:{t:}-} {{t:{t:}-} {{t:{t:}-}\n',
	ltxt(1), ltxt(2), ltxt(3), ltxt(4), ltxt(5)
    ];

    write_section ['Issues',	 format, header, txt || [m == 1]];
    write_section ['Protonation States',format, header, txt || [m == 2]];
    write_section ['Warnings', format, header, txt || [m == 3]];

    for i = 1, length pfcn loop
	local problems = SPREP_prob || [
	    (second SPREP_prob == SPREP_fcn.ptype(i))
	];

	    // !!! Protect with task_call

	local [result, code] = task_call [pfcn(i),
	    ['report', [CNTXT_rkeys, problems]],
	    [master: 'parent', errmsg : 'ignore']

	];

	if code <> '' then
	    Warning 'Could not generate report.';
	    WindowTrigger [SPREP_wkey, [update_system : 1]];
	    return [];
	endif
	if length result then
	    apt fwrite [fh, '{c:}\n',txt];
	endif
    endloop


	// This only occurs when the user presses the report button
	// in the GUI.

    if file == '' then
	fseek [fh, 0];
	ted_SetData [ted_Open[], freadb [fh, 'char', INT_MAX]];
    endif

    fclose fh;
endfunction

// FUNCTION:	ProPrep panel pager
// INPUT:	NULL
// RETURN:	ProPrep Panels.

local function err_panels []
    local i;
    local pfcn = uniq SPREP_fcn.pfcn;
    local panels = apt call [pfcn, 'panel'];

    panels = prepend [ panels, [
	Label : [
	    name : 'refusal_page',
	    text : '',
	    font : 'mediumBold',
	    extendH : 1
	]
    ]];
    return [ Pager : cat [
	[name : 'epnl_pgr', extendH : 1, flushLeft : 1],
	tag [ 'Vbox', panels ]
    ]];
endfunction

// FUNCTION:	Popup panel to database fields to show in result list.
// INPUT:	NULL
// RETURN:	NULL

local function field_popup_panel location
    local priomask = SPREP_fcn.priomask;
    local listIdx,fieldnames,sens;
    local fmask;

    local error_type = (untag WindowGetData [SPREP_wkey,'radio_error_type'])(2);
    local active_problems = SPREP_fcn.error_type == error_type;
    fieldnames = SPREP_fcn.ptype | active_problems;


    local x_field = x_id fieldnames;

	// If first characted is a dash remove it for sorting.

    local m_dash = m_findmatch ['-*', fieldnames];
    local t_fieldnames = fieldnames;
    t_fieldnames | m_dash = tok_drop [fieldnames | m_dash, 1];

    [fieldnames, x_field] = apt get [
	[fieldnames, x_field],
	[x_sort t_fieldnames]
    ];

    fmask = SPREP_Listbox_typemask | active_problems;
    fmask=fmask[x_field];
    local ncol = 1+ floor ((length fieldnames) / 15);

    if second task_wfork [] <> 'child' then
	WindowSetAttr [SPREP_wkey, [displayfields : [sensitive : 1 ]]];
	return;
    endif

    local tval = tr [fieldnames, fieldnames, 'return'];
    local tags = [['name', 'text', 'onTrigger']];
    local cbdata  = apt tag [tags, tval];

    local txt;

    local panel = [
	name: 'show_list_fields',
	Vbox: [
	    extendH: 1,
	    extendV: 1,
	    Button: [
		extendH: 1,
		name: 'showall',
		text: 'All Types',
		onTrigger: 'return'
	    ],
	    Button: [
		extendH: 1,
		name: 'invert',
		text: 'Invert Types',
		onTrigger: 'return'
	    ],
	    Mbox : cat [
		[columns : ncol, uniformCols : 1, columnMajor : 1],
		tag ['Checkbox', cbdata]
	    ]
	]
    ];

    if length location then
	panel.location = location;
	panel.mode ='popup';
    else
	return;
    endif

    local wkey = WindowCreate panel;
    WindowSetData [wkey, tag [fieldnames, fmask]];
    WindowShow wkey;

    SPREP_Listbox_typemask | active_problems = fmask[x_sort x_field];
    WindowTrigger [SPREP_wkey, [update_listbox:1]];

    loop
	local [val,trig] = WindowWait wkey;

	local idx = indexof [trig, fieldnames];
	if idx then
	    fmask(idx) = val.(trig);
	elseif trig === 'showall' then
	    WindowSetData [wkey, tag [fieldnames, fmask = one fmask]];
	elseif trig === 'invert' then
	    WindowSetData [wkey, tag [fieldnames, fmask = not fmask]];
	endif

	SPREP_Listbox_typemask | active_problems = fmask[x_sort x_field];

	WindowTrigger [SPREP_wkey, [update_listbox:1]];
	WindowSetAttr [wkey, [show_list_fields: [mouseoutUnmap: 1]]];

    endloop
    WindowDestroy wkey;
endfunction

// FUNCTION:	Densitize/Sensitize ALL buttons of panel
// INPUT:	val = 1 to densensitize, val = 0 to enable all buttons.
// RETURN:	NULL

local function brick_panel val
    SPREP_brickstate = val;
    val = not val;
    if val then
	WindowSetAttr [SPREP_wkey, [
	    panel		: [sensitive : val],
	    system_defn		: [sensitive : val],
	    show_system_defn	: [sensitive : val],
	    autoIsolate		: [sensitive : val],
	    radio_error_type	: [sensitive : val],
	    set_listbox_sel	: [sensitive : val],
	    displayfields	: [sensitive : val],
	    prev		: [sensitive : val],
	    next		: [sensitive : val],
	    major_list		: [sensitive : val],
	    minor_list		: [sensitive : val],
	    warning_list	: [sensitive : val],
	    report		: [sensitive : val]
	]];
    else
	WindowSetAttr [SPREP_wkey, [
	    panel		: [sensitive : val],
	    system_defn		: [sensitive : val],
	    show_system_defn	: [sensitive : val],
	    autoIsolate		: [sensitive : val],
	    radio_error_type	: [sensitive : val],
	    set_listbox_sel	: [sensitive : val],
	    displayfields	: [sensitive : val],
	    prev		: [sensitive : val],
	    next		: [sensitive : val],
	    major_list		: [sensitive : val],
	    minor_list		: [sensitive : val],
	    warning_list	: [sensitive : val],
	    report		: [sensitive : val]
	]];
    endif
endfunction

// FUNCTION: 	return panel for Protein Preparation
// INPUT:	opt	-> options
// RETURN:	Panel.

const N_LIST_LINES = 15;
const MIN_WIDTH = 42;

local function create_sprep_panel opt
    SPREP_brickstate = 0;

	// Create table of errors, total # of errors, # of selected errors.

    local labels = create_number_error_labels [];
    local labelbox = cat [
	[ spacing : 'none'],
	labels | SPREP_fcn.u_group_error_type == ERRTYPE.issues,
	[Separator : []],
	labels | SPREP_fcn.u_group_error_type == ERRTYPE.prot,
	[Separator : []],
	labels | SPREP_fcn.u_group_error_type == ERRTYPE.warning
    ];

    local nerrValues = update_number_err [];
    local nErr = tag ['Label',apt tag nerrValues];
    local nErrbox = cat [
	[ spacing : 'none'],
	nErr | SPREP_fcn.u_group_error_type == ERRTYPE.issues,
	[Separator : []],
	nErr | SPREP_fcn.u_group_error_type == ERRTYPE.prot,
	[Separator : []],
	nErr | SPREP_fcn.u_group_error_type == ERRTYPE.warning
    ];

    local listhelp =
		'P: Pocket Residues; Chain: Chain Name; Res: Residue Name\n'
		'UID: Residue number and insertion code.  Double-clicking\n'
		'selects the atoms briefly in the MOE Window.';

	// ===== START PANEL DEFINITION ===== //

    return [

	    // ===== Panel Buttons ===== // 
	name : 'panel', title : WINDOW_NAME, windowName : WINDOW_NAME,
	text : [ 'Correct', 'Protonate3D...', 'Close' ],
	sensitive : [0,0,1],
	bubbleHelp : [
	    'Correct all or selected issues, if any.',
	    'Launch Protonate3D panel, while disabling the\n'
	    'Structure Preparation panel. Once Protonate3D\n'
	    'finished the Structure Preparation panel will\n'
	    'be enabled again.',
	    ''
	],

	    // Top box of panel

	Hbox : [
	    extendH : 1,
	    Option : [
		name : 'system_defn', sensitive: 0,
		text : cat [
		    SYSDEF_OPTIONS,
		    uniq cTag noPrivateChains []
		],
		title : 'Chains:',
		bubbleHelp : 'Select chain to examine for errors.',
		onTrigger : 'return'
	    ],
	    Button : [
		name : 'show_system_defn', sensitive: 0,
		text : '?',
		font : 'mediumBold',
		bubbleHelp :
		    'Briefly select in the MOE Window the atoms of the '
			'Chains,\n'
		    'and, in the Sequence Editor, their corresponding residues.'
	    ],
	    Label : [extendH:1],
	    Data : [ name : 'sysprep_grobs'],
	    Radio : [
		text : ERRNAMES.names, sensitive: 0,
		font : 'mediumBold',
		name : 'radio_error_type',
		onTrigger : 'return',
		type : 'int',
		bubbleHelp : ERRNAMES.help
	    ]
	],

	Separator : [flushLeft : 1],

	Hbox : [
	    extendH : 1,
	    extendV : 1,
	    flushLeft : 1,
	    spacing : 'none',

		// Summary Page

	    Vbox : [
		extendV:1,
		Hbox : [
		    Vbox : labelbox,
		    Pager : [
			Vbox : nErrbox,
			Label: [text: '10000']	// to prevent resize
		    ]
		],
		Vbox : [extendV:1],
		Button : [ sensitive: 0,
		    extendH : 1,
		    centerH : 1,
		    name : 'report',
		    font : 'mediumBold',
		    text : 'Report...',
		    bubbleHelp :
			'Generate a text report of issues found\n'
			'with current structure.'
		]
	    ],

	    Separator : [vertical : 1, margin : 0],

	    Vbox : [
		extendH : 1,
		extendV : 1,

		    // Box above list box

		Hbox : [
		    extendH:1,
		    flushLeft : 1,
		    Option : [
			name : 'set_listbox_sel', sensitive: 0,
			text : SELECT_OPT,
			font : 'mediumBold',
			type : 'int',
			onTrigger : 'return',
			bubbleHelp : 'Select defined atoms in the list.'
		    ],
		    Label : [
			name : 'nlines_selected',
			text : '',
			extendH:1
		    ],
		    Checkbox : [
			name : 'autoIsolate', sensitive: 0,
			onTrigger : 'return',
			text : 'Auto Isolate',
			font : 'mediumBold',
			bubbleHelp :
			    'If on, atoms corresponding to the selected\n'
			    'list items will be isolated and highlighted\n'
			    'in the MOE Window.',
			type : 'int'
		    ],
		    Button : [
			name : 'displayfields', sensitive: 0,
			text : 'Types...',
			onTrigger : 'return',
			bubbleHelp:
			    'Specify which issue types will be displayed.'
		    ],
		    Button: [
			name: 'prev', text: '    ', sensitive: 0,
			graphics: gr_icon [
			    'arrow_left',
			    8,
			    'foreground'
			],

			grPosition: 'overlay',
			onTrigger: 'return',
			sensitive : 0,
			bubbleHelp:
			    'Previous in list.'
		    ],
		    Button: [
			name: 'next', text: '    ', sensitive: 0,
			graphics: gr_icon [
			    'arrow_right',
			    8,
			    'foreground'
			],
			grPosition: 'overlay',
			onTrigger: 'return',
			sensitive : 0,
			bubbleHelp:
			    'Next in list.'
		    ]
		],

		    // List boxes

		Pager : [
		    name : 'sprep_listboxes',
		    extendH : 1,
		    extendV : 1,
		    flushLeft : 1,
		    Listbox : [
			name : 'major_list', sensitive: 0,
			len : N_LIST_LINES,
			width : MIN_WIDTH,
			font : 'medium',
			extendH : 1,
			extendV : 1,
			sortEnable : 1,
			flushLeft : 1,
			type : 'modint',
			multiSelect : 2,
			onTrigger : 'return',
			headerBubbleHelp : listhelp
		    ],
		    Listbox : [
			name : 'minor_list',
			len : N_LIST_LINES,
			width : MIN_WIDTH,
			font : 'medium',
			extendH : 1,
			extendV : 1,
			sortEnable : 1,
			flushLeft : 1,
			type : 'modint',
			multiSelect : 2,
			onTrigger : 'return',
			headerBubbleHelp : listhelp
		    ],
		    Listbox : [
			name : 'warning_list',
			len : N_LIST_LINES,
			width : MIN_WIDTH,
			font : 'medium',
			extendH : 1,
			extendV : 1,
			sortEnable : 1,
			flushLeft : 1,
			type : 'modint',
			multiSelect : 2,
			onTrigger : 'return',
			headerBubbleHelp : listhelp
		    ]
		],

		    // Driver panels

		Group : err_panels []
	    ]
	]
    ];
endfunction

// FUNCTION:	Run protonate 3d and fix problems which it creates (mostly
//		aName and rName)
// INPUT:	NULL
// RETURN:	NULL

local function _protonate3d_ui []
    local serial = oSerialNumber Atoms [];
    task_run [
	'protonate3d_ui.svl',
	[],
	[creator : 'blockEOK',title: 'Protonate3D'],
	'Protonate3D_Panel'
    ];
    local rkeys = uniq aResidue (Atoms [] | m_diff [
	oSerialNumber Atoms [],
	serial
    ]);

	// Automatically assign H name for cases where
	// there is an exact name match and only for added Hs.

    local [xres,xatoms] = _amber_ResidueLookup [
	SPREP_RLIB,
	rkeys,
	STRONGMATCH_OPT
    ];
    [rkeys,xres,xatoms] = [rkeys,xres,xatoms] || [app length xres == 1];
    xatoms = app cat xatoms;

    local x_exist = app x_pack xatoms;
    xatoms = app pack xatoms;

    local stdmol = apt tagpeek [SPREP_RLIB[xres],'mol'];

    local stdaname = cat apt get [cat apt get [stdmol,4],MOL_ATOM_NAME];
    stdaname = apt get [stdaname,x_exist];

    local isSTDname = stdaname == aName xatoms and aElement xatoms == 'H';
    xatoms = cat (xatoms || not isSTDname);
    stdaname = cat (stdaname || not isSTDname);
    aSetName [xatoms,stdaname];
endfunction

// FUNCTION: 	MAIN panel for protein prep.
// INPUT: 	options
// RETURN: 	[]

local function sprep_panel opt

    local arg;
    local lopt,lval;
    local lname,labels;
    static val;

    if second task_fork [statics: 'share'] <> 'child' then return; endif
    task_settitle [-1, ''];

	// Start a parent task to hide and wait for child to
	// end; the parent will do the clean up.

    if 'child' <> second task_wfork [master:'none'] then
	call SPREP_graphics;
	exit [];
    endif

	// Get current problems

    local oldprio = task_prio 0;
    task_prio oldprio;

	// create and initialize the panel

    task_settitle [-1, WINDOW_NAME];
    SPREP_wkey = WindowCreate create_sprep_panel opt;

	// If there is only one active cTag on start up use it
	// by default.

    local act_ch = Atoms [];
    act_ch = act_ch | not aInert act_ch;
    act_ch = uniq cTag uniq aChain act_ch;
    local defn = SYSDEF_OPTIONS(1);
    if length act_ch == 1 then
	defn = act_ch;
    endif

    WindowSetData [SPREP_wkey, [
	autoIsolate : opt.autoIsolate,
	system_defn : defn
    ]];
    WindowSetAttr [SPREP_wkey, [
	major_list : [header : 'Analyzing Structure ...'],
	minor_list : [header : 'Analyzing Structure ...'],
	warning_list : [header : 'Analyzing Structure ...']
    ]];

    WindowShow SPREP_wkey;

    update_system [];
    brick_panel 0;		// sensitize panel

	// ===== ENTER MONITOR ===== //

    local [mtid,mtcode] = task_fork [
	statics : 'share', master : 'parent', idle : 1,	prio : 0
    ];
    if mtcode == 'child' then
	loop
	    sleep 0.15;

		// Has something changed? If not then go to next loop

	    if SPREP_updatestate then	// window trigger will cause update
		continue;
	    endif

		// Only used when Selected/Unselected chains is used.
		// If there is a change in the selection state of a chain
		// update the panel.

	    local renderState = SystemNonrenderState [];
	    local ffState = (pot_Info []).serial;
	    local setState = app oGetCollection oCollections [];
	    local ctagState = uniq cTag noPrivateChains [];
	    local cselState = SelectedChains [];

	    if  neL [cselState, SPREP_cselstate]
		and m_diff [val.system_defn, cat [SYSDEF_OPTIONS(1), ctagState]]
	    then
		if DEBUG then print 'cSel MONITOR'; endif
		SPREP_updatestate = 1;
		WindowTrigger [SPREP_wkey, [update_system : 1]];
		continue;
	    endif

		// If there there is a new chain tag update system definitions

	    if  neL [ctagState, SPREP_ctagstate]
		and m_diff [val.system_defn, ctagState]
	    then
		if DEBUG then print 'cTag MONITOR'; endif
		SPREP_updatestate = 1;
		WindowSetData [SPREP_wkey, [system_defn : SYSDEF_OPTIONS(1)]];
		WindowTrigger [SPREP_wkey, [update_system : 1]];
		continue;
	    endif

	    if neL [
		[renderState,ffState,setState],
		[SPREP_renderstate,SPREP_ffstate,SPREP_setstate]
	    ] then
		if DEBUG then print 'MONITOR'; endif
		SPREP_updatestate = 1;
		WindowTrigger [SPREP_wkey, [update_system : 1]];
		continue;
	    endif
	endloop
	exit [];

    endif

	// ===== START OF MAIN PANEL EVENT LOOP ===== //

    local idx,xprob,selmask;
    local error_type;
    local evnt_parms;
    local isolate=opt.autoIsolate;
    local curSel,mod,s_order;
    local dsplMask,dsplVal;
    local active;
    local data,attr;

    function get_window_list_data [val,error_type]
	if error_type == ERRTYPE.issues then
	    return val.major_list;
	elseif error_type == ERRTYPE.prot then
	    return val.minor_list;
	elseif error_type == ERRTYPE.warning then
	    return val.warning_list;
	endif
    endfunction

    val = WindowValues SPREP_wkey;

    task_prio 0;
    loop
	_panel_Sensitive val;
	local trig;
	[val, trig] = WindowWait SPREP_wkey;
	if length SPREP_graphics then
	    task_call append [SPREP_graphics,[master:'parent',errmsg:'ignore']];
	endif

	local sprep_panelF = 0;
	local listboxF = 0;

	if trig == 'panel' then

		// !!! Should I miminimize structure with contraints to remove
		// some steric clashes.

	    if val.panel == 'Protonate3D...' then
		brick_panel 1;
		WindowSetAttr [SPREP_wkey, [
		    epnl_pgr : [page : 1]
		]];

		UndoSnapshot [];
		_protonate3d_ui [];
		update_system [];
		SPREP_updatestate = 0;
		listboxF = 1;

	    elseif val.panel == 'Close' then
		SPREP_prob = [];
		break;

		// Correct selected or all errors.

	    elseif val.panel == 'Correct' then
		brick_panel 1;
		SPREP_updatestate = 1;

		local errtype = val.radio_error_type;
		[xprob,selmask,active] = get_SPREP_Listbox_values errtype;

		if allfalse selmask and errtype == ERRTYPE.issues then
		    errtype = ALL_ERR;
		endif

		UndoSnapshot [];
		WindowSetAttr [SPREP_wkey, [
		    epnl_pgr : [page : 1]
		]];
		task_call [ #fix_errors, errtype, [
		    errmsg : 'ignore',
		    master : 'parent'
		]];

		SPREP_updatestate = 0;
		listboxF = 1;
	    endif

	elseif trig == 'report' then
	    write_report '';

	elseif trig == 'update_system' or trig == 'system_defn' then
	    SPREP_updatestate = 1;
	    update_system [];
	    SPREP_updatestate = 0;

	elseif trig == 'show_system_defn' then
	    show_selection [CNTXT_rkeys,0];

	elseif trig == 'update_listbox' then
	    listboxF = 1;

	    // Select and isolate previous in list.

	elseif trig == 'prev' then
	    error_type = val.radio_error_type;
	    [curSel,mod,s_order] = get_window_list_data [val,error_type];

		// If nothing is selected, select first in list. If already at
		// first in list stay there.

	    if alltrue (s_order[curSel] > 1) then
		curSel = s_order[curSel]-1;
		curSel = indexof [curSel,s_order];
	    endif

		// Update selection values, and isolate.

	    set_SPREP_selmask_from_linenumber [curSel,error_type];

	    isolate_selected val;
	    sprep_panelF = 1;

	    // Select next in list.

	elseif trig == 'next' then
	    error_type = val.radio_error_type;
	    [curSel,mod,s_order] = get_window_list_data [val,error_type];

	    if alltrue (s_order[curSel] < length s_order) then
		curSel = s_order[curSel]+1;
		curSel = indexof [curSel,s_order];
	    endif
	    set_SPREP_selmask_from_linenumber [curSel,error_type];

	    isolate_selected val;
	    sprep_panelF = 1;

	    // Get selection from MOE for residue list.

	elseif trig == 'set_listbox_sel' then
	    set_Listbox_selection val;
	    WindowSetData [SPREP_wkey, [set_listbox_sel : 1]];
	    sprep_panelF = 1;

	elseif trig == 'autoIsolate' then
	    isolate_selected val;

	    // Update listbox maps and isolate residues in MOE window.

	elseif length findmatch ['*_list', trig] then
	    error_type = val.radio_error_type;

		// If the selection has not changed no need to update panel.

	    set_SPREP_selmask_from_window val;

	    [curSel,mod,s_order] = get_window_list_data [val,error_type];
	    if bitand [mod,WMOD_DBL] then
		show_selection [get_isolate_keys error_type ,0];
	    else
		isolate_selected val;
	    endif
	    sprep_panelF = 1;

	    // Change page of Proprep panel

	elseif trig == 'radio_error_type' then
	    error_type = val.radio_error_type;

	    isolate_selected val;
	    WindowSetAttr [SPREP_wkey, [sprep_listboxes : [page : error_type]]];
	    sprep_panelF = 1;

	    // Hide some types in listbox.

	elseif trig === 'displayfields' then

	    WindowSetAttr [SPREP_wkey, [displayfields: [sensitive: 0]]];
	    if 'child' == second tfork [] then

		    // Merge diabled types with problems so that when enable
		    // diabling the number of problems will show up in summary
		    // page. Once the popup closes removed the newly diabled
		    // types and update listbox.

		local oprob = SPREP_prob;
		SPREP_prob = apt cat [SPREP_prob, SPREP_disabled];
		local xres = indexof [first SPREP_prob,CNTXT_rkeys];
		SPREP_prob = apt get [SPREP_prob,[x_sort xres]];
		update_SPREP_Listbox_values [CNTXT_rkeys, CNTXT_serial, oprob];

		field_popup_panel [WINDOW_NAME, trig, 71];
		oprob = SPREP_prob;
		local ptypes = second SPREP_prob;
		SPREP_disabled = SPREP_prob || [m_join [
		    ptypes,
		    SPREP_fcn.ptype | not SPREP_Listbox_typemask
		]];

		SPREP_prob = SPREP_prob || [m_join [
		    ptypes,
		    SPREP_fcn.ptype | SPREP_Listbox_typemask
		]];

		update_SPREP_Listbox_values [CNTXT_rkeys, CNTXT_serial, oprob];

		exit [];
	    endif

	    // epanel Events

	elseif
	    length x_findmatch [tok_cat [SPREP_fcn.u_var,'*'],trig]
	then

		// Since an epanel can only be triggered by only one driver
		// we do not need to loop of xfcn since the driver should
		// handle that stuff.

		// Get function id.

	    error_type = val.radio_error_type;
	    [xprob,selmask,active] = get_SPREP_Listbox_values error_type;
	    local problems = apt get [SPREP_prob, [xprob|selmask]];
	    evnt_parms = [
		CNTXT_rkeys,
		problems,
		SPREP_wkey,
		val,
		trig
	    ];

	    local xfcn = x_join [SPREP_fcn.ptype, uniq second problems];

		// If correction brick panel.

	    local correction = 0;
	    if length findmatch [tok_cat [SPREP_fcn.u_var,'_cor*'],trig] then
		brick_panel 1;
		SPREP_updatestate = 1;

		WindowSetAttr [SPREP_wkey, [
			refusal_page : [ text : [ twrite [
			    'Correcting issues of type: {t:|,}',
			    SPREP_fcn.ptype[xfcn]
			]]],
			epnl_pgr : [page : 1]
		]];

		correction = 1;
	    endif

	    UndoSnapshot [];

	    local result, code = '';
	    if DEBUG == 2 then
		call [
		    SPREP_fcn.pfcn(first xfcn),
		    ['panel_event',evnt_parms],
		    [errmsg : 'ignore']
		];
	    else
		[result,code] = task_call [
		    SPREP_fcn.pfcn(first xfcn),
		    ['panel_event',evnt_parms],
		    [
			master: 'parent',
			errmsg: 'ignore',
			title : SPREP_fcn.ptype(first xfcn)
		    ]
		];
	    endif

		// If driver function create any graphic objects/labels
		// then save in static.

	    SPREP_graphics = cat second untag WindowGetData [
		SPREP_wkey,
		'sysprep_grobs'
	    ];

	    if code <> '' and DEBUG then
		exit result;
	    elseif code <> '' or correction then
		update_system [];
		SPREP_updatestate = 0;
		listboxF = 1;
	    endif
	endif

	if SPREP_brickstate then
	    brick_panel 0;
	endif

	if listboxF then
	    update_listbox_txt [];
	endif

	if sprep_panelF or listboxF then
	    update_sprep_panel [];
	endif
    endloop

	// ===== END OF MAIN PANEL EVENT LOOP ===== //

    task_kill mtid;
    call SPREP_graphics;
    WindowDestroy SPREP_wkey;
    exit [];
endfunction

// ===== ProPrep entry point ==================================================

// FUNCTION: 	Prepares proteins and fixes problems in
//		protein-ligand complexes.
// INPUT:	options
// RETURN:	NONE

global function StructurePreparationGUI opt;

    if MOE_BATCH then
	opt = tagcat [opt,SPREP_DEF_MOEBATCH];

	    // If in MOE BATCH and using interactive give wanring that it is
	    // not possible

	if opt.cmd == 'interactive' then
	   write
		'There is no interactive mode for MOE batch. Please use\n'
		'ProPrep [keys,[cmd:\'cli\']]. This will automatically fix\n'
		'all errors in the loaded system. If you want to use the\n'
		'interactive mode please use the MOE GUI\n';
	    return;
	endif
    else

	    // Show window if it already exists. Prevents two protein
	    // prep panels from being open.

	if WindowShow [WINDOW_NAME, 1] then
	    return;
	endif
	opt = tagcat [opt,SPREP_DEF_MOEGUI];
    endif

	// Read amber library and initialize SPREP functions.

    local lib_file = GetRC ['RotamerLibrary', STD_RES_LIB];
    SPREP_RLIB = _amber_ResidueLibrary lib_file;
    initialize_SPREP_fcn opt;

    local nErr;

	// Open up interactive GUI for Protein Preparation

    if opt.cmd == 'interactive' then

	sprep_panel opt;

	// Run command line for for Protein Preparation. In this option
	// all suggested fixes are applied followed by running Protonate3D.

    elseif opt.cmd == 'cli' then

	    // Fix Errors

	update_system [];
	fix_errors 0;

	if opt.batch_protonate3d then
	    local protectAtms = oGetCollection P3D_PROTECT_SET;
	    local atms = cat oAtoms CNTXT_rkeys;
	    Add_H atms;
	    Protonate3D [atms,atms,atms,protectAtms,[],[verbose:0]];
	endif

	    // Fix errors caused by protonate 3D.

	update_system [];
	fix_errors 0;

	if opt.reportName <> '' then
	    write_report opt.reportName;
	endif

	update_system [];
	nErr = get_number_err [];
	return tag [SPREP_fcn.u_psumgroup,nErr];

    elseif opt.cmd == 'summary' then
	update_system [];
	nErr = get_number_err [];
	return tag [SPREP_fcn.u_psumgroup,nErr];

    elseif opt.cmd == 'items' then
	update_system [];
	return keep [SPREP_prob,3];
    elseif opt.cmd == '_items' then
	update_system [];
	return SPREP_prob;
    elseif opt.cmd == '_types' then
	return SPREP_fcn.ptype;
    endif
endfunction

global function _StructurePreparationGUI [chains, opt]
    SPREP_chains = chains;
    return StructurePreparationGUI opt;
endfunction

// ----------------------- BUILT IN FUNCTIONS -------------------------------

// SPREP_TYPE is to be used to easily change the group or priority of an
// error function. By using a same group name for multiple errors, these errors
// will be merged and displayed as one column in the listbox on the summary
// page.
//
// ERROR PRIOITIES
//
// Each error will be assigned a number (a float value) as a priority. These
// priorities are the order by which the errors will be automatically fixed.
// A lower number means that errors will be processes before one with a higher
// number. If the priority is >= 3 then it will be classified as a warning.
// A warning is to be used for residues where a user may want to manually
// inspect or of change a property (such as HIS protonation states and flips),
// or for errors that there are no fixes for such as forcefield errors.

// Summary group is used to merge multiple problem types in the summary page.
// If Summary group is '' then it will not be shown on the summary page.

const SPREP_TYPE = [
//  Error tag	: [Problem type,Prority, Summary help, Summary group]

    cb		: [
	['Break','Termini'],
	1.2,
	['Chain Breaks','Chain Termini'],
	['Termini','Termini']
    ],
    missH	: ['HCount',	1.30,'Incorrect Number of Hs'	, 'HCount'],
    se		: ['Selenium',	1.41, 'Residue containing Se'	, 'Library'],
    metal	: ['Metal',	1.42, 'Metal Coordination'	, 'Library'],
    library	: ['Library',	1.43, 'Library Mismatch'	, 'Library'],
    topology	: ['Topology',	1.44, 'Topology Mismatch'	, 'Library'],
    charge	: ['Charge',	1.99, 'Partial Charges'		, 'Charge'],
    atomname	: [
	['AName','HName'],
	1.50, 
	['Non-standard Atom Name','Hydrogen naming'],
	['AName','AName']
    ],
    ff		: ['FF',	3.99,'Forcefield Parameters'	, 'FF']
];

// ===== Utility functions ====================================================

function pro_Mutate;
function Seq_NameToLetter;
function pro_SeqCreate;
function pro_HomologyModel;
function MM;
function pro_Polymerize;

// !!! Work around for pro_HomologyModel. Currently if you pass 
// empty tokens file are written out.

local function __pro_HomologyModel [chains, opt]
    local prefix = fnametemp [];
    local moefile = tok_cat [prefix,'.moe'];
    local mdbfile = tok_cat [prefix,'.mdb'];
    local i =1;
    opt = tagcat [[moe_file : moefile, db_file : mdbfile] , opt];
    pro_HomologyModel [chains,opt];

    fdelete [moefile,mdbfile];
endfunction

function Seq_NameToLetter;
function pro_SeqCreate;
function pro_HomologyModel;
function MM;
function pro_Polymerize;
function pro_Acetylate;
function pro_Amidate;

const STD_RESNAME = [
    'ALA','ARG','ASN','ASP','CYS','GLN','GLU','GLY','HID','HIE','HIP','HIS',
    'ILE','LEU','LYS','MET','PHE','PRO','SER','THR','TRP','TYR','VAL'
];

static ALLOWED_MUTATIONS;

// FUNCTION: 	Return a mask of whether the residue has a standard name.
// INPUT:	residue keys
// RETURN:	mask of length rkeys.

local function rIsStdRes res
    local stdname = SPREP_rlib_rname | m_join [SPREP_rlib_rclass, STD_RESNAME];
    return m_join [rName res, cat [STD_RESNAME, stdname]];
endfunction

// FUNCTION:	Assign standard residue name to non-standard residue.
// INPUT:	residue keys.
// RETURN:	NULL

local function create_stdresidues res

	// Set non-stand residues to ala.

    rSetName [res | not rIsStdRes res, 'ALA'];

	// Set standard AA to rclass name.
	// !!! NOTE this function is only called with amino acids which
	// do have a rclass.

    local ridx = indexof [rName res, SPREP_rlib_rname];
    rSetName [res | ridx, SPREP_rlib_rclass[pack ridx]];
endfunction

local function ResID res = tok_cat totok [cNumber oParent res, '_', rUID res];

// res == the universe; loopres are to be modeled by pro_HomologyModel.
// At present, the first and last residues each loop are anchor residues,
// passed in by the Correction archictecture. This is convenient for
// for pro_Polymerize.

function pro_AtomCheck;
local function buildLoop [res, loopres, title]
    if isnull loopres then return []; endif;

	// If residue is not a standard res name as defined by the homology
	// modeller change the rName.

    local original_rnames = rName loopres;
    app create_stdresidues loopres;

    local rmode = app first app uniq rRibbonMode
	(loopres || 0 <> oChildCount loopres)
    ;
    local emptyres = cat (loopres || 0 == oChildCount loopres);
    local [psys, new_sys, new_res] = SystemPush cat [res, emptyres];

	// Set the UIDs to rNumber - this allows us to pick up the
	// the modelres at the end, as HomologyModel preserves UID's -
	// thank the Lord for small mercies.

    rSetUID [Residues[], rNumber Residues[]];

    local Rmodel     = keep [new_res, - length emptyres];
    local Rmodel_idx = ResID Rmodel;	    // to pick up model res after

    local Cmodel = uniq oParent Rmodel;	    // models for HomologyModel

    local R = cat oChildren Cmodel;
    rSetPos [R, 0];
    R = diff [R, Rmodel];

	// This unfortunately necessary until pro_HomologyModel is
	// persuaded to simply copy atoms from template to model when
	// the residue is unknown - at present, it does fine until
	// the Rotamer placement function is called ...

    local okF = pro_AtomCheck R;
    rSetName [R | not okF, 'ALA'];
    oDestroy (R | (not oChildCount R));

    R = R | oValid R;
    local newChain = oCreate 0;
    oReparent [R | (not rIsAmino R), newChain];

    local Ctemplate = mol_Create mol_Extract Cmodel;	// templates
    R = cat oChildren Ctemplate;
    rSetPos [R, rNumber R];
    oDestroy (R | 0 == oChildCount R);

	// pro_HomologyModel insists on empty residues.

    oDestroy cat oAtoms Cmodel;

	// Select all the atoms for environment. Fix atoms in case
	// we ever allow HomologyModel to do some minimizing.

    aSetSelected [Atoms[], 1];
    aSetFixed [Atoms[], 1];

	// Create loops

    local opt = [
	model			: cNumber Cmodel,
	template		: cNumber Ctemplate,
	nMainModels		: 1,
	intermediate_refine	: 'None',
	final_refine		: 'None',
	protonate3D		: 0,
	env_atoms		: 1,
	verbose			: 0
    ];

    local [result, code] = task_call [
	#__pro_HomologyModel,
	[ Chains [], opt],
	[
	    errmsg : 'show',
	    master : 'parent'
	]
    ];

    if code <> '' then
	SystemPop [psys, new_sys];
	exit [];
    endif

	// The templates are after the model chains, so the model chain numbers
	// are the same after pro_HomologyModel as before, so we can use
	// ResIDs to pick up the modeled residues in the right order.

    local idx = indexof [Rmodel_idx, ResID Residues[]];

    Rmodel = get [Residues[], pack idx];
    local mol = mol_Extract Rmodel;

    SystemPop [psys, new_sys];

    Cmodel = mol_CreateHidden mol;
    local modelatoms = oChildren cat oChildren Cmodel;
    oReparent [modelatoms, emptyres | idx];
    oDestroy Cmodel;

	// Create polymer bonds for loop residues.

    local fixflag = app alltrue oChildCount loopres;
    app pro_Polymerize (loopres | fixflag);

	// Set original names.

    rSetName [loopres, original_rnames];

	// Set Inert and Hidden flag.

    local m_inert  = andE app andE aInert  app cat app rAtoms loopres;
    local m_hidden = andE app andE aHidden app cat app rAtoms loopres;

    modelatoms = cat modelatoms;
    aSetInert  [modelatoms, m_inert];
    aSetHidden [modelatoms, m_hidden];
    rSetRibbonMode [loopres, rmode];

    return [modelatoms, fixflag];
endfunction

// FUNCTION: 	Builds backbone atoms of residues
// INPUT:	[all residues, backbone residue keys.
// Return: 	nothing

function pro_BackboneAtoms;
local function buildBackbone [res, bbres]
    local i;
    if isnull bbres then return []; endif;
    local fixed = zero bbres;

	// Is there a topology problem.

    local bbatoms = app get_BackboneAtoms bbres;
    fixed = app length bbatoms;
    if anytrue fixed then
	bbatoms = bbatoms | app length bbatoms;
	apt aSetGeometry [bbatoms,[['sp2','sp2','sp2','sp2']]];
	aSetIon [bbatoms,0];
	Add_H bbatoms;
    endif

    local nfres = bbres | not fixed;

	// Is is just missing an O

    local [N,CA,C,O] = pro_BackboneAtoms nfres;
    local m_o_missing = N and CA and C and not O;
    if anytrue m_o_missing then
	C = C | m_o_missing;
	aSetGeometry [C,'sp2'];
	aSetIon [C,0];
	local h = aBonds C;		// If there are more then 2 hs we need
	oDestroy cat (h || aIsLight h); // to delete them.
	Add_H C;
	O = aBonds C;
	O = (O || aIsLight O);
	for i=1, length O loop
	    if length O(i) == 1 then
		aSetElement [O(i),'O'];
		aSetName [O(i),'O'];
		aSetGeometry [O(i),'sp2'];
		aSetIon [O(i),0];
		aSetDist [[C(i),O(i)],1.256];
	    else
		aSetElement [O(i),'O'];
		aSetName [O(i),['O','OXT']];
		aSetGeometry [O(i),['sp2','sp2']];
		aSetIon [O(i),[0,-1]];
		aSetDist [[C(i),O(i)],1.256];
	    endif
	endloop
	nfres = nfres | not m_o_missing;
    endif

	// Get residues on either side of backbone residue. Is there a residue
	// addjacent to the backbone residue.

    local xres = apt indexof [nfres, [res]];
    local m_add = m_join [xres,xres+1];
    local bbxkey = tr [xres-1, xres, xres+1+m_add];

	// If residue is on a boundary (terminus of chain) or is not a std res
	// remove it from the problem.

    local m_boundary = (
	  app orE (bbxkey == 0 or bbxkey > length res)
    ) and rIsStdRes nfres;
    [bbxkey, nfres] = [bbxkey, nfres] || [not m_boundary];
    local loopres = apt get [[res],bbxkey];

	// Is it at the end of a chain.

    local notendofchain = zero nfres;
    for i=1, length notendofchain loop
	notendofchain(i) = andE app length loopres(i);
    endloop
    [nfres,loopres] = [nfres,loopres] || [notendofchain];

	// Do all residues of atoms and are they of the same chain.

    local containsAtoms = zero nfres;
    for i=1, length containsAtoms loop
	containsAtoms(i) =
	    andE rAtomCount loopres(i)
	and andE m_join [oParent loopres(i), oParent nfres(i)];
    endloop
    [nfres,loopres,containsAtoms] = [nfres,loopres,containsAtoms] || [
	containsAtoms
    ];

	// For homology modeller to work delete atoms of nfres;

    aSetSelected [cat rAtoms (nfres|containsAtoms),1];
    oDestroy cat rAtoms (nfres|containsAtoms);

	// Call cb diagnosis since we may have adjacent residues missing
	// backbone atoms and therefore it becomes a loop problem.

    local prob = proprep_cb ['diagnose', res];
    local term = first prob;
    local m = m_join [term,app first loopres] and (second prob == 'Break');
    prob = prob || [m];
    proprep_cb ['fix',[res,prob]];

    return app get_BackboneAtoms bbres;
endfunction

// FUNCTION: 	Minimize a subset of atoms;
// INPUT:	Rkeys of what we consider the universe and the atoms we want to
//		minimize.
// RETURN : 	NULL

local function MinimizeAtomSubSet [rkeys,atms]
    local allatoms = cat rAtoms rkeys;
    local bidx = indexof [atms, allatoms];
    local osys = SystemPush allatoms;

    allatoms  = last osys;
    local patms  = allatoms[bidx];

    aSetInert [allatoms, m_join [allatoms, _Atoms '$$solvent']];
    aSetFixed [allatoms, m_diff [allatoms, patms]];

    MM [
	keep_chirality : '',
	gtest : 1.0,
	maxit : 500,
	verbose : 0
    ];

    local pos = aPos allatoms[indexof [patms, allatoms]];
    SystemPop osys;
    aSetPos [atms, pos];
endfunction

// FUNCTION:	Copy topology from mol to atoms.
// INPUT:	atoms to put new topology in, mol (molecule) to get
//		topology from, index of atoms in mol to copy topology from.
// RETURN:	NULL

local function copyMolTopology [atoms, mol, xidx]
    mol = apt peek [mol,4];

    aSetName     [atoms, apt get [apt peek [mol,MOL_ATOM_NAME    ], xidx]];
    aSetBackbone [atoms, apt get [apt peek [mol,MOL_ATOM_BACKBONE], xidx]];
    aSetIon      [atoms, apt get [apt peek [mol,MOL_ATOM_ION     ], xidx]];
    aSetGeometry [atoms, apt get [apt peek [mol,MOL_ATOM_GEOM    ], xidx]];
    aSetHintLP   [atoms, apt get [apt peek [mol,MOL_ATOM_HINTLP  ], xidx]];

	// Delete all inter-residue bonds

    local bonds;
    local i;

    for i=1, length atoms loop
	bonds = aBonds atoms(i);
	bonds = bonds || (oParent bonds == uniq oParent atoms(i));
	bonds = bonds || apt m_join [bonds, [atoms(i)]];
	Unbond [atoms(i), bonds];
    endloop


	// Catch cases where there is a sigma bond missing. Only seen with
	// Topology match from library. Ex: (PDB Code: 1dy5, Res B: Act 600).

    for i=1, length atoms loop
	bonds = get [mol(i)(MOL_ATOM_BONDS), xidx(i)];
	bonds = app pack apt indexof [bonds, [xidx(i)]];
	bonds = apt get [[atoms(i)],bonds];
	Bond [atoms(i), bonds];
    endloop
endfunction

const STRUCTPREP_NEWATOM_SET = 'STRUCTPREP_NEWATOMS';

// ===== USE FOLLOWING library PLUGIN AS TEMPLATE FOR STRUCTURE PREP ========= 
//----------------------------------------------------------------------------
//
// Each driver must have for each problem the following:
//
// [ 
//	residue key		-> residue of diagnosed problem
//	problem abbreviate	-> problem type of diagnosed problem
//	txt			-> text to show in panel
//	data			-> private data associated with diagnosed 
//				   problem
//	Fixable flag		-> 1 if it can be fix, 0 if now.
// ];
//
// Additionally all problems are assigned a priority and a problem type. 
//
// - The priority is used to sort the problems in the order that they should be
//   fixed. Eg. a problem with a priority of 1 will get fixed before a problem
//   with a priority of 2.
// - Priorities are also used to classify errors into error types (Major, Minor
//   and Warnings. Classes are defined as follows:
//	- Major -> Priority of >= 1 and < 2
//	- Minor -> Priority of >= 2 and < 3
//	- Warnings -> Priority of >= 3
// - Problem types are used to group problems together in the summary pannel.
// - proprep_epnl_XXX can be used to create a panel to allow option to 
//   fix a particular error.
// - If a button on proprep_epnl_XXX will trigger an event then the name
//   of the triger should start with ABBR_XXX with the action being 
//   defined in the proprep_XXX epnl_evnt command section.
// - If an action on a epnl should apply a correction then the event button
//   must start with ABBR_cor_XXX

// ===== LIBRARY PROBLEMS ============================================

const COV_MERGE = -1;
const COV_NOTFIX = -2;
const CHIRAL_MATCH = -3;
const DNAMATCH_RNAME = -4;
const EXTRA_PORTS = -5;
const MISSINGATOMS = -6;

const STRONG_LIB = 1;
const WEAK_LIB = 2;
const RNAME_LIB = 3;
const RNAME_CHIRAL = 4;

const SPREP_SEQVAR = '*Sequence Variants*';

// FUNCTION : 	return 1 (pass) or 0 if it passes secondardy triage.
// INPUT :	Residue with no library match.

local function secondaryTriage rkeys 

	// Only look at cases where there is no exact match found in lib.
	// Remove residues with no atoms and residue in altloc sets.

    local libmatch = CNTXT_libmatch;
    local atoms = cat rAtoms rkeys;
    local occ = split [
	aOccupancy atoms,
	mtoc m_uniq oParent atoms
    ];
    occ = app andE (occ == 1);
    occ = unpack [occ, 0, rAtomCount rkeys];

	// All residues which have an exact match, no atoms or have lone pairs
	// Remove from secondary triage check.

    local rmMatches = [
	LIBMATCH_EXACT,
	LIBMATCH_MULTI,
	LIBMATCH_DIFFRNAME,
	LIBMATCH_NOATOMS,
	LIBMATCH_LPATOMS
    ];

	// ===== OCCUPANCY TEST ===== //

    local mask =
	    m_diff [CNTXT_libmatch, rmMatches]
	and rAtomCount rkeys
	and occ
	and not m_findmatch [SPREP_SEQVAR, cHeader oParent rkeys]
    ;

    libmatch | (not occ) and m_diff [
	CNTXT_libmatch,
	[LIBMATCH_NOATOMS,LIBMATCH_LPATOMS]
    ] = 1;
    libmatch | m_findmatch [SPREP_SEQVAR, cHeader oParent rkeys] = 1;

	// ===== CAP TEST ===== //

	// Take residues and those contected to them and push into private
	// system. Cap and recheck for exact match.

    local bndAtoms = app cat app aBonds oChildren (rkeys | mask);
    local bndToRes = cat app uniq oParent bndAtoms;

    local osys = SystemPush uniq cat [(rkeys | mask), bndToRes];
    local res = keep [last osys, length (rkeys|mask)];

    local m_ace = zero res;
    local m_nme = zero res;
    local i;
    for i=1, length res loop
	if not rIsAmino res(i) then continue; endif

	    // Cap residue if needed. This is mainly for dealing with 
	    // chain breaks.

	local bbatms = cat sm_MatchAtoms [PRO_BB_MATCH,cat oChildren res(i)];
	if not length bbatms then continue; endif

	   // Check to see if it is capped already. This is done
	   // By seeing how many residues N and C are bound to.
	   // If only 1 (itself) then cap.

	if length (uniq cat oParent aBonds first bbatms) == 1 then
	    m_nme(i) = 1;
	endif

	if length (uniq cat oParent aBonds last bbatms) == 1 then
	    m_ace(i) = 1;
	endif
    endloop

    pro_Amidate (res | m_nme);
    pro_Acetylate (res | m_ace);

    local [xres,xatoms]= _amber_ResidueLookup [SPREP_RLIB,res,STRONGMATCH_OPT];
    local x = x_pack mask;

	// Remove all cases where capping fixes problems.

    libmatch[x | app length xres] = 1;

    mask[x] = not app length xres;

    SystemPop osys;

    osys = SystemPush rkeys;
    res = last osys;

	// ===== COVALENT TEST ===== //

    local y = x_pack oChildCount res;
    bndToRes = app uniq oParent app cat app aBonds oChildren res[y];

    // Normally if you do aBonds on the atoms of a polymer residue you would
    // get 3 different oParent keys. If you have more then that you
    // have a extra covalent bond. Similarly if you have more then 1 
    // oParent for a non-polymer residue it has a extra covalent bond.

    bndToRes = bndToRes || apt m_diff [
	oParent bndToRes,
	oParent res[y]
    ];
    [y, bndToRes] = [y,bndToRes] || [app length bndToRes];

    [y,bndToRes] = apt get [
	[y,bndToRes],
	[reverse x_sort app length bndToRes]
    ];

	// !!! Assumes if there are multiple bonds to other residues,
	// that residue does not have more then one extra covalent bond.
	// (ie. no covalent bond networkds.

    i = 0;
    local m_keep = one y;
    for i=1, length y loop
	local otherbonds = bndToRes(i);
	if
		m_diff [rType res(y(i)), ['amino','dna','rna']]
	    and orE m_join [rType otherbonds, ['amino','dna','rna']]
	    and length otherbonds == 1
	then
	    m_keep(i) = 0;
	else
	    local idx = indexof [otherbonds, res[y]];
	    m_keep[idx | idx > i] = 0;
	endif
    endloop

    [y, bndToRes] = [y,bndToRes] || [m_keep];
    local reparent = bndToRes;
    local ridx = apt indexof [reparent, [res]];
    local rmatch = apt get [[CNTXT_libmatch], ridx];

    [reparent,y] = [reparent,y] || [
	  CNTXT_libmatch[y] <> LIBMATCH_EXACT
	or app andE (rmatch  <> LIBMATCH_EXACT)
    ];

	// If more then one extra covalent bond then flag it as
	// a covalent residue that we can not fix.

    libmatch [y | app length reparent > 1] = COV_NOTFIX;
    [reparent,y] = [reparent,y] || [app length reparent == 1];


	// Reparent atoms of one residue to the other to see
	// if in fact it is fact two residues which should be one.

    apt oReparent [app oChildren reparent, res[y]];

    local [xres_cov,xatoms_cov]= _amber_ResidueLookup [
	SPREP_RLIB,
	res[y],
	STRONGMATCH_OPT
    ];
    local [wxres_cov,wxatoms_cov]= _amber_ResidueLookup [
	SPREP_RLIB,
	res[y],
	WEAKMATCH_OPT
    ];

	// If there is a match flag it as we should merge the residues,
	// otherwise flag as we can not fix it.

    libmatch[y] = COV_NOTFIX;
    if orE app length wxres_cov then
	local m_match = app length wxres_cov;
	libmatch[y | m_match] = COV_MERGE;
	xres_cov = apt cat [xres_cov | m_match,wxres_cov | m_match];
    else
	xres_cov = [];
	wxres_cov = [];
	xatoms_cov = [];
	wxatoms_cov = [];
    endif

    SystemPop osys;
    local m_cov = app m_uniq xres_cov;

	// If there is a covalent residue to be merge remove the residue
	// to be reparented from being checked futher.

    local mergekey = rkeys | m_join [libmatch,[COV_MERGE,COV_NOTFIX]];
    mergekey = diff [oParent cat aBonds cat rAtoms mergekey,mergekey];
    libmatch[indexof[mergekey,rkeys]]=1;

	// ===== EXTRA PORT TEST ===== //
	// Does the RNAME matches of the same number of exit ports.

    local m = m_join [libmatch, [LIBMATCH_RNAME, LIBMATCH_DIFFRNAME]];
    local rBonded, nports;
    x = x_pack m;
    for i=1, length x loop
	if isnull SPREP_RLIB[CNTXT_rnamematch_xres(x(i))]then continue; endif

	rBonded = aResidue cat aBonds cat rAtoms rkeys(x(i));
	rBonded = diff [rBonded, rkeys(x(i))];
	nports = apt tagpeek [
	    SPREP_RLIB[CNTXT_rnamematch_xres(x(i))],
	    'Qmol_Ak'
	];

	local notsameNPorts = andE (length rBonded > app length nports);
	if notsameNPorts then
	    libmatch(x(i)) = EXTRA_PORTS;
	endif
    endloop

	// ===== CHRIAL TEST ===== //
	// Check to make sure RNAME match have same CA Chirality

    m = m_join [libmatch, [LIBMATCH_RNAME, LIBMATCH_DIFFRNAME]];
    x = x_pack m;
    for i=1, length x loop
	if rIsAmino rkeys(x(i)) then

		// Compare CA chirality residue and fix to see if they are the
		// same.

	    local notsameChiralSM = andE not compareCAChirality [
		rkeys(x(i)),
		CNTXT_strongmatch_xres(x(i))
	    ];
	    local notsameChiralNM = andE not compareCAChirality [
		rkeys(x(i)),
		CNTXT_rnamematch_xres(x(i))
	    ];

		// Acount for cases where there is no Protein backbone 
		// or no strong match.

	    if isnull notsameChiralSM then notsameChiralSM = 1; endif
	    if isnull notsameChiralNM then notsameChiralNM = 1; endif

	    if (
		    (notsameChiralSM and length CNTXT_strongmatch_xres(x(i)))
		or (notsameChiralNM  and length CNTXT_rnamematch_xres(x(i)))
	    )
	    then
		libmatch(x(i)) = CHIRAL_MATCH;
		continue;
	    endif

	    // In cases where there is a strong match but the rname do not
	    // match prioritize 3d match over rName for DNA and RNA. Catches
	    // DA3 and DA5 cases.

	elseif
		m_join [rType rkeys(x(i)), ['rna','dna']]
	    and libmatch(x(i)) == LIBMATCH_DIFFRNAME
	then
	    libmatch(x(i)) = DNAMATCH_RNAME;
	    continue;
	endif

	local mol = apt tagpeek [
	    SPREP_RLIB[CNTXT_rnamematch_xres(x(i))],
	    'Qmol'
	];

	    // If mol is null then there is no sequence match only a structure
	    // match and thefore it is a library mismatch.

	if isnull mol then continue; endif

	local heavyatoms = cat rAtoms rkeys(x(i));

	    // Can not have lone pairs since res with LP will never be assigned
	    // this problem.

	heavyatoms = heavyatoms | aElement heavyatoms <> 'H';
	if andE (length heavyatoms < app mol_aCount mol) then
	    local m_miss = rep [0, length mol];
	    local j;
	    for j=1, length mol loop
		local aname = mol(j)(4)(MOL_ATOM_NAME);
		local x_exist = x_join [aname, aName heavyatoms];

		    // If there is a duplicate atom name there are other
		    // problems and all heavy atom name that present are
		    // found in the mol

		if
			length x_exist    == length uniq x_exist
		    and length heavyatoms == length x_exist
		then
		    local bonds = mol(4)(MOL_ATOM_BONDS)[x_exist];
		    bonds = app pack apt indexof [bonds, [x_exist]];
		    bonds = apt get [[heavyatoms],bonds];
		    local rbonds = aBonds heavyatoms;
		    rbonds = rbonds || aElement rbonds <> 'H';
		    rbonds = rbonds ||
			oParent rbonds == uniq oParent heavyatoms;
		    m_miss(j) = alltrue apt m_join [bonds, rbonds];
		else
		    m_miss(j) = 0;
		endif
	    endloop
	    if andE m_miss(j) then
		libmatch(x(i)) = MISSINGATOMS;
	    endif
	endif
    endloop

    return [libmatch,xres_cov || m_cov];
endfunction

// FUNCTION: 	Identifies missing atom errors
// INPUT:	context
// RETURN:	prob (with new tagged vector err contain errors alt loc errors.

local function proprep_diagnose_library res 

	// Do some secondary classification of errors.

    local [libmatch,xres_cov] = secondaryTriage res;

	// Are the residue part of the receptor.

    local isrec = m_join [res, uniq oParent _Atoms '$$receptor'];

	// Get the number of matches per residue.

    local nstrong = app length CNTXT_strongmatch_xres;
    local nweak = app length CNTXT_weakmatch_xres;
    local nrname = app length CNTXT_rnamematch_xres;

	// Get rName and rClass remove blank classes.

    local allrclass = SPREP_rlib_rclass;
    local allrname = SPREP_rlib_rname;
    allrname | allrclass <> '' = allrclass | allrclass <> '';

	// Not in lib
	// !!! If receptor residue not in library then we should offer to mutate
	// to Ala.

    local m = libmatch == LIBMATCH_NOTINLIB;
    local notinlib = res | m;
    local notinlib_xres = zero notinlib;
    local notinlib_xatoms = zero notinlib;
    local notinlib_txt = apt twrite [
	'{t:} residue not in library',
	select ['Receptor','Ligand',isrec | m]
    ];
    local notinlib_prio = zero notinlib;

	// Residues containing lone pairs.

    m = libmatch == LIBMATCH_LPATOMS;
    local lpatoms = res | m;
    local lpatoms_xres = zero lpatoms;
    local lpatoms_xatoms = zero lpatoms;
    local lpatoms_txt = rep ['Residue contains dummy atoms', length lpatoms];
    local lpatoms_prio = zero lpatoms;

	// Residues is CA Structure only

    m = libmatch == LIBMATCH_CASTRUCT;
    local castruct = res | m;
    local castruct_xres = zero castruct;
    local castruct_xatoms = zero castruct;
    local atoms = rAtoms castruct;
    atoms = atoms || aElement atoms <> 'H';
    local m_ca_or_p = aName atoms == 'CA';
    local castruct_txt = select [
	'CA structure only',
	'P structure only',
	m_ca_or_p
    ];
    local castruct_prio = zero castruct;

	// Chirality mis match.

    m = libmatch == CHIRAL_MATCH;
    local wrongchi = res | m;
    local wrongchi_xres = zero wrongchi;
    local wrongchi_xatoms = zero wrongchi;
    local wrongchi_prio = zero wrongchi;
    local wrongchi_txt = zero wrongchi;

    local i;
    local m_uxres;
    local x = x_pack m;
    for i=1, length x loop
	wrongchi_xres(i) = cat [
	    CNTXT_rnamematch_xres[x(i)],
	    CNTXT_strongmatch_xres[x(i)],
	    CNTXT_weakmatch_xres[x(i)]
	];
	wrongchi_xatoms(i) = cat cat [
	    zero CNTXT_rnamematch_xres[x(i)],
	    CNTXT_strongmatch_xatoms[x(i)],
	    CNTXT_weakmatch_xatoms[x(i)]
	];
	wrongchi_prio(i) = stretch [
	    [RNAME_CHIRAL,STRONG_LIB,WEAK_LIB],
	    app length wrongchi_xres(i)
	];
	wrongchi_xres(i) = cat wrongchi_xres(i);

	m_uxres = m_uniq wrongchi_xres(i);

	wrongchi_prio(i) = wrongchi_prio(i) | m_uxres;
	wrongchi_xres(i) = wrongchi_xres(i) | m_uxres;
	wrongchi_xatoms(i) = wrongchi_xatoms(i) | m_uxres;
	local wrongchi_seq = uniq get [
	    allrname,
	    wrongchi_xres(i) | wrongchi_prio(i) == RNAME_CHIRAL
	];
	local wrongchi_3d = token uniq get [
	    allrname,
	    wrongchi_xres(i) | wrongchi_prio(i) <> RNAME_CHIRAL
	];
	wrongchi_3d | wrongchi_3d == '' = 'No match';

	wrongchi_txt(i) = twrite [
	    'Incorrect CA chirality (Seq: {t:|,}, 3D: {t:|,})',
	    wrongchi_seq,
	    wrongchi_3d
	];
    endloop

	// Adress cases where there are multiple matches in the library.

    m = libmatch == LIBMATCH_MULTI;
    local amb = res | m;
    local amb_xres = zero amb;
    local amb_xatoms = zero amb;
    local amb_prio = zero amb;
    local amb_txt = zero amb;

    x = x_pack m;
    for i=1, length x loop
	if length cat CNTXT_strongmatch_xres[x(i)] then
	    amb_xres(i) = CNTXT_strongmatch_xres[x(i)];
	    amb_xatoms(i) = cat CNTXT_strongmatch_xatoms[x(i)];
	    amb_prio(i) = stretch [
		[STRONG_LIB],
		app length amb_xres(i)
	    ];
	else
	    amb_xres(i) = CNTXT_weakmatch_xres[x(i)];
	    amb_xatoms(i) = cat CNTXT_weakmatch_xatoms[x(i)];
	    amb_prio(i) = stretch [
		[WEAK_LIB],
		app length amb_xres(i)
	    ];
	endif
	amb_xres(i) = cat amb_xres(i);

	m_uxres = m_uniq amb_xres(i);

	amb_prio(i) = amb_prio(i) | m_uxres;
	amb_xres(i) = amb_xres(i) | m_uxres;
	amb_xatoms(i) = amb_xatoms(i) | m_uxres;

	amb_txt(i) = twrite [
	    'Ambiguous residue name ({t:|,})',
	    uniq get [allrname, amb_xres(i)]
	];

    endloop

	// rName match only.

    m = m_join [libmatch, [LIBMATCH_RNAME,LIBMATCH_DIFFRNAME,MISSINGATOMS]];
    local rname = res | m;
    local rname_xres = zero rname;
    local rname_xatoms = zero rname;
    local rname_prio = zero rname;
    local rname_txt = zero rname;
    x = x_pack m;
    for i=1, length x loop
	rname_xres(i) = cat [
	    CNTXT_rnamematch_xres[x(i)],
	    CNTXT_strongmatch_xres[x(i)],
	    CNTXT_weakmatch_xres[x(i)]
	];
	rname_xatoms(i) = cat cat [
	    zero CNTXT_rnamematch_xres[x(i)],
	    CNTXT_strongmatch_xatoms[x(i)],
	    CNTXT_weakmatch_xatoms[x(i)]
	];
	rname_prio(i) = stretch [
	    [RNAME_LIB,STRONG_LIB,WEAK_LIB],
	    app length rname_xres(i)
	];

	rname_xres(i) = cat rname_xres(i);

	m_uxres = m_uniq rname_xres(i);

	rname_prio(i) = rname_prio(i) | m_uxres;
	rname_xres(i) = rname_xres(i) | m_uxres;
	rname_xatoms(i) = rname_xatoms(i) | m_uxres;
	local rname_seq = uniq get [
	    allrname,
	    rname_xres(i) | rname_prio(i) == RNAME_LIB
	];
	local rname_3d = uniq get [
	    allrname,
	    rname_xres(i) | rname_prio(i) <> RNAME_LIB
	];

	    // If the vector is length 1 then app token will not work in case
	    // if it is null.

	if length rname_seq > 1 then
	    rname_seq = app token rname_seq;
	else
	    rname_seq = token rname_seq;
	endif

	if length rname_3d > 1 then
	    rname_3d = app token rname_3d;
	else
	    rname_3d = token rname_3d;
	endif

	if orE (rname_3d <> '') and orE (rname_seq <> '') then
	    rname_txt(i) = twrite [
		'{t:} (Seq: {t:|,}, 3D: {t:|,})',
		select [
		   'Missing atoms',
		   'Library mismatch',
		   libmatch(x(i)) == MISSINGATOMS
		],
		rname_seq,
		rname_3d
	    ];
	elseif orE (rname_seq == '') then
	    rname_txt(i) = twrite [
		'{t:} (3D: {t:|,})',
		select [
		   'Missing atoms',
		   'Library mismatch',
		   libmatch(x(i)) == MISSINGATOMS
		],
		rname_3d
	    ];
	elseif orE (rname_3d == '') then
	    rname_txt(i) = twrite [
		'{t:} (Seq: {t:|,})',
		select [
		   'Missing atoms',
		   'Library mismatch',
		   libmatch(x(i)) == MISSINGATOMS
		],
		rname_seq
	    ];
	endif
    endloop

	// Prioritize name match for DNA/RNA when there is a strong match but
	// different RNAME.

    m = libmatch == DNAMATCH_RNAME;
    local dna = res | m;
    local dna_xres =	zero dna;
    local dna_xatoms =	zero dna;
    local dna_prio =	zero dna;
    local dna_txt =	zero dna;
    x = x_pack m;
    for i=1, length x loop
	dna_xres(i) = cat [
	    CNTXT_strongmatch_xres[x(i)],
	    CNTXT_weakmatch_xres[x(i)],
	    CNTXT_rnamematch_xres[x(i)]
	];
	dna_xatoms(i) = cat cat [
	    CNTXT_strongmatch_xatoms[x(i)],
	    CNTXT_weakmatch_xatoms[x(i)],
	    zero CNTXT_rnamematch_xres[x(i)]
	];
	dna_prio(i) = stretch [
	    [STRONG_LIB,WEAK_LIB,RNAME_LIB],
	    app length dna_xres(i)
	];

	dna_xres(i) = cat dna_xres(i);

	m_uxres = m_uniq dna_xres(i);

	dna_prio(i) = dna_prio(i) | m_uxres;
	dna_xres(i) = dna_xres(i) | m_uxres;
	dna_xatoms(i) = dna_xatoms(i) | m_uxres;
	local dna_seq = uniq get [
	    allrname,
	    dna_xres(i) | dna_prio(i) == RNAME_LIB
	];
	local dna_3d = app token uniq get [
	    allrname,
	    dna_xres(i) | dna_prio(i) <> RNAME_LIB
	];
	dna_3d | dna_3d == '' = 'No match';

	dna_txt(i) = twrite [
	    'Incorrect residue name (Seq: {t:|,}, 3D: {t:|,})',
	    dna_seq,
	    dna_3d
	];
    endloop

	// Intra chain bonds

    m = m_join [libmatch, EXTRA_PORTS];
    local extraport = res | m;
    local extraport_xres = zero extraport;
    local extraport_xatoms = zero extraport;
    local extraport_prio = zero extraport;
    local extraport_txt = rep ['Extra intra-chain bond', length extraport];

	// Covalent residues

    m = m_join [libmatch, COV_NOTFIX];
    local cov_nf = res | m;
    local cov_nf_xres = zero cov_nf;
    local cov_nf_xatoms = zero cov_nf;
    local cov_nf_prio = zero cov_nf;
    local cov_nf_txt = [];
    local reparent;
    local r_txt;

    if orE m then
	reparent = app cat app aBonds oChildren cov_nf;
	reparent = app uniq oParent reparent;
	reparent = reparent || apt m_diff [
	    oParent reparent,
	    oParent cov_nf
	];
	r_txt = rep ['', length cov_nf];
	for i =1, length reparent loop
	    r_txt(i) = apt twrite [
		'{t:}: {t:}{t:}',
		cNumber oParent reparent(i),
		rDisplayName reparent(i),
		rDisplayUID reparent(i)
	    ];
	endloop
	cov_nf_txt = apt twrite ['Inter-chain bond ({t:|,})', r_txt];
    endif

	// Covalent residues which should be merge.

    m = m_join [libmatch, COV_MERGE];
    local cov = res | m;
    local cov_xres = xres_cov;
    local cov_xatoms = zero cov_xres;
    local cov_prio = zero cov;
    local cov_txt = [];
    reparent = [];
    if orE m then
	reparent = app cat app aBonds oChildren cov;
	reparent = app uniq oParent reparent;
	reparent = reparent || apt m_diff [oParent reparent, oParent cov];
	cov_txt = apt twrite [
	    'Inter-chain bond ({t:}: {t:}{t:}), looks like ({t:|,})',
	    cNumber oParent reparent,
	    rDisplayName reparent,
	    rDisplayUID reparent,
	    app uniq apt get [[allrname],cov_xres]
	];
    endif

	// Each problem we have a data entry consisting of
	//	data(1) = Matches in library.
	//	data(2) = Atoms which match in the library
	//	data(3)	= residue key of atoms to merge (only used in covalent)
	//	data(4) = Priority (Is it a name, strong or weak match).

    local data = tr [
	cat [
	    notinlib_xres,
	    lpatoms_xres,
	    castruct_xres,
	    wrongchi_xres,
	    amb_xres,
	    rname_xres,
	    dna_xres,
	    extraport_xres,
	    cov_nf_xres,
	    cov_xres
	],
	cat [
	    notinlib_xatoms,
	    lpatoms_xatoms,
	    castruct_xatoms,
	    wrongchi_xatoms,
	    amb_xatoms,
	    rname_xatoms,
	    dna_xatoms,
	    extraport_xatoms,
	    cov_nf_xatoms,
	    cov_xatoms
	],
	cat [
	    zero notinlib,
	    zero lpatoms,
	    zero castruct,
	    zero wrongchi,
	    zero amb,
	    zero rname,
	    zero dna,
	    zero extraport,
	    zero cov_nf,
	    reparent
	],
	cat [
	    notinlib_prio,
	    lpatoms_prio,
	    castruct_prio,
	    wrongchi_prio,
	    amb_prio,
	    rname_prio,
	    dna_prio,
	    extraport_prio,
	    cov_nf_prio,
	    cov_prio
	]
    ];

    local rkeys = cat [
	notinlib,
	lpatoms,
	castruct,
	wrongchi,
	amb,
	rname,
	dna,
	extraport,
	cov_nf,
	cov
    ];
    local txt = cat [
	notinlib_txt,
	lpatoms_txt,
	castruct_txt,
	wrongchi_txt,
	amb_txt,
	rname_txt,
	dna_txt,
	extraport_txt,
	cov_nf_txt,
	cov_txt
    ];

    local prio = cat [
	zero notinlib,
	zero lpatoms,
	zero castruct,
	one wrongchi,
	one amb,
	one rname,
	one dna,
	zero extraport,
	zero cov_nf,
	one cov
	];

    local serial = tr [SPREP_TYPE.library(1), oSerialNumber rkeys];
    if length rkeys then
	return [rkeys, SPREP_TYPE.library(1), txt, data, prio, serial];
    else
	return [];
    endif
endfunction

// FUNCTION:	After some fix is there now a match in the library. IF there is
//		Apply correct names and topology.
// INPUT:	residue keys to standardize.
// RETURN:	Whether it could standardize the residue or not.

local function standardize_residue rkeys

    Add_H cat rAtoms rkeys;

    local [xres,xatoms] = _amber_ResidueLookup [
	SPREP_RLIB,
	rkeys,
	STRONGMATCH_OPT
    ];

    local [wxres, wxatoms] = _amber_ResidueLookup [
	SPREP_RLIB,
	rkeys,
	WEAKMATCH_OPT
    ];

	// If no strong match found look for weak match and take first.

    xatoms | not app length xres = app first (wxatoms| not app length xres);
    xres | not app length xres = app first (wxres| not app length xres);
    local m_fixable = app length xres == 1;
    [rkeys,xres,xatoms] = [rkeys,xres,xatoms] || [app length xres == 1];
    xatoms = app cat xatoms;

	// Get the atoms which exist.

    local x_exist = app x_pack xatoms;
    xatoms = app pack xatoms;

    local stdmol = apt tagpeek [SPREP_RLIB[xres],'mol'];

	// Copy topology

    copyMolTopology [xatoms,stdmol,x_exist];
    Add_H cat rAtoms rkeys;

	// If atoms names are different fix them too.

    local stdaname = cat apt get [cat apt get [stdmol,4],MOL_ATOM_NAME];
    stdaname = apt get [stdaname,x_exist];

    local isSTDname = stdaname == aName xatoms;
    xatoms = cat (xatoms || not isSTDname);
    stdaname = cat (stdaname || not isSTDname);
    aSetName [xatoms,stdaname];

    aSetHidden [rAtoms rkeys, app andE aHidden rAtoms rkeys];
    return m_fixable;
endfunction

function Superpose;
function  EditDeleteConsequences;
function AutoConnect;
function pro_SmartMutate;

// FUNCTION:	Mutate residue (Handles non standard residues unlike pro_Mutate)
//		Very simply. !!! NOTE: it does not used a rotatmer library.
// INPUT:	residue keys, name to mutate the residue to, library entry
//		to mutate too.
// RETURN:	Whether i fixed it or not.

local function mut_residue [res,name,xres]
    local fixed = zero res;
    local resmol = SPREP_RLIB[xres];
    resmol = apt tagpeek [resmol,'mol'];
    local org_atoms = cat rAtoms res;

    local fix_type = apt get [cat apt get [resmol,3],MOL_RES_TYPE];
    local curr_type = rType res;

	// !!! Need to address other types, ligand.
	// !!! Need conformational search?

    local new_ch,o_res,o_bb,n_res,n_bb;

    local i;
    local msd,R,t;
    local n_atoms,bndToRes;

	// Mutate amino acids
	// !!! Need to do conformational search

    local m_amino = curr_type == 'amino' and fix_type == 'amino';
    if orE m_amino then
	o_res = res | m_amino;

	    // Get back bone atoms. If no backbone atoms see if I can fix
	    // by using homology modeller.

	o_bb = app first apt sm_MatchAll [PRO_BB_MATCH, rAtoms o_res];
	local bbatoms = buildBackbone [
	    CNTXT_rkeys,
	    o_res | not app length o_bb
	];
	o_bb | not app length o_bb = bbatoms;
	local m_missingbb = not app length o_bb;
	local x_missingbb = x_pack m_missingbb;
	fixed[x_missingbb] = 0;

	local x_bb = x_pack m_amino;
	curr_type[x_bb | not app length o_bb] = '';
	m_amino [x_bb | not app length o_bb] = 0;
	[o_res,o_bb] = [o_res,o_bb] || [app length o_bb];

	    // If residue and fix name is one of the 20 standard amino
	    // and is not a terminal residue
	    // !!! and is bound to only amino acids (only needed due to bug in
	    // pro_Mutate).
	    // acids use pro_Mutate.

	local bndRes = app cat app aBonds rAtoms (res|m_amino);
	bndRes = app uniq app aResidue bndRes;
	local m_stdres =
		apt m_join [name | m_amino, [STD_RESNAME]]
	    and app andE rIsAmino bndRes
	;
	local m = pro_SmartMutate [
	    o_res|m_stdres,
	    (name|m_amino) | m_stdres,
	    [alt_protomers : 0, soft_search : 0, verbose:0]
	];


	    // If SmartMutate did not work try simple mutation/

	m_stdres[x_pack m_stdres] = m;

	standardize_residue (o_res | m_stdres);
	[o_res,o_bb] = [o_res,o_bb] || [not m_stdres];

	   // Create atoms for fix. Find backbone atoms of fix.

	new_ch = app mol_CreateHidden resmol[indexof[o_res,res]];
	aSetHidden [rAtoms o_res, app andE aHidden rAtoms o_res];
	aSetInert  [rAtoms o_res, app andE aInert rAtoms o_res];
	n_res = cResidues new_ch;
	n_bb = app cat apt sm_MatchAtoms [PRO_BB_MATCH, rAtoms n_res];

	for i=1, length n_res loop

		// For each fix superimpose backbone atoms onto each other.

	    [msd,R,t] = Superpose [[aPos o_bb(i), aPos n_bb(i)]];
	    n_atoms = cat rAtoms n_res(i);
	    aSetPos [
		n_atoms,
		app add (R(2) * [(aPos n_atoms) - t(2)])+t(1)
	    ];

		// What atoms is the old residue bonded to.

	    bndToRes = cat aBonds o_bb(i);

		// Keep old backbone atoms. So detele side chain of 
		// old residue and backbone of new.

	    oDestroy cat [
		diff [cat rAtoms o_res(i),o_bb(i)],
		cat [n_bb(i), n_atoms | m_join [
		    aName n_atoms, ['HA','HA3','HA2','H']]]
	    ];
	    n_atoms = n_atoms | oValid n_atoms;

		// Reparent newatoms to old residue.

	    oReparent [n_atoms, o_res(i)];

	    rSetName [o_res(i), rName n_res(i)];
	    Bond [o_bb(i) | PRO_CA_MASK, n_atoms | aName n_atoms == 'CB'];
	    if orE (aName n_atoms == 'OXT') then
		Bond [first o_bb(i), n_atoms | aName n_atoms == 'OXT'];
	    endif
	    if orE m_join [['H1','H2','H3'], aName n_atoms] then
		Bond [
		    last o_bb(i),
		    n_atoms | m_join [aName n_atoms, ['H1','H2','H3']]
		];
	    endif

		// Account for residue with rings in backbone.

	    if orE m_join [rName o_res(i), ['PRO','DPR','HYP']] then
		Bond [o_bb(i) | PRO_N_MASK, n_atoms | aName n_atoms == 'CD'];
	    endif

		// No need to worry about what side chain looks like with GLY.
		// Otherwise minimize atoms so that they look respectable.

	    if rName o_res(i) <> 'GLY' then

		    // ===== Enter Private System ===== //

		local osys = SystemPush o_res(i);

		local atoms = Atoms [];
		aSetFixed [atoms | m_join [aName atoms,['N','CA','C','O']],1];

		    // Set the force chirality to the chirality of the atoms.

		aSetForceRS [Atoms [], aRSChirality Atoms []];
		MM [ verbose : 0];
		local apos = aPos atoms;

		    // ===== Exit Private System ===== //

		SystemPop osys;

		aSetPos [cat rAtoms o_res(i), apos];
	    endif

	endloop
	oDestroy EditDeleteConsequences new_ch;
	fixed | m_amino = 1;

	    // Account for cases where the homology modeller fixed it.

    endif

	// Mutate dna and rna
	// !!! Need to do conformational search

    local m_xna =
	       m_join [curr_type,['rna','dna']]
	   and m_join [fix_type, ['rna','dna']]
    ;
    const PO4MATCH = '[OX2]~[PX4](~[OX1])~[OX1]';

    if orE m_xna then

	    // Get Backbone atoms

	o_res = res | m_xna;
	o_bb = app first apt sm_MatchAll [DNA_BB_MATCH, rAtoms o_res];

	    // If no backbone present there is another problem.

	curr_type[(x_pack m_xna) | not app length o_bb] = '';
	m_xna[x_pack m_xna | not app length o_bb] = 0;
	[o_res,o_bb] = [o_res,o_bb] || [app length o_bb];

	    // Get library fix.

	new_ch = app mol_CreateHidden resmol[indexof[o_res,res]];
	aSetHidden [rAtoms o_res, app andE aHidden rAtoms o_res];
	aSetInert  [rAtoms o_res, app andE aInert rAtoms o_res];
	n_res = cResidues new_ch;
	n_bb = app cat apt sm_MatchAtoms [DNA_BB_MATCH, rAtoms n_res];

	local idx = x_pack m_xna;
	for i=1, length n_res loop

		// Superpose backbone of fix onto backbone of res.

	    [msd,R,t] = Superpose [[aPos o_bb(i), aPos n_bb(i)]];
	    n_atoms = cat rAtoms n_res(i);
	    aSetPos [
		n_atoms,
		app add (R(2) * [(aPos n_atoms) - t(2)])+t(1)
	    ];

		// If residue has terminal P keep position of P and Os.

	    local o_po = sm_MatchAll [PO4MATCH,cat rAtoms o_res(i)];
	    o_po = o_po | app length o_po;
	    o_po = cat (o_po | app andE (oParent o_po == o_res(i)));
	    local n_po = cat sm_MatchAtoms [PO4MATCH,cat rAtoms n_res(i)];

		// If you have the same number of new and old po4 atoms,
		// set the position of the new atoms to the old.

	    if length n_po == length o_po then
		aSetPos [n_po, aPos o_po];
	    else
		oDestroy n_res(i);
		fixed(idx(i)) = 0;
		continue;
	    endif

		// Delete atoms of old residue. Reparent atoms of fix residue.
		// Reconnect atoms.

	    bndToRes = cat aBonds cat rAtoms o_res(i);
	    oDestroy cat rAtoms o_res(i);
	    oReparent [n_atoms, o_res(i)];

		// Set residue name and reconnect atoms.

	    rSetName [o_res(i), rName n_res(i)];
	    AutoConnect cat [cat rAtoms o_res(i), bndToRes | oValid bndToRes];
	    fixed(idx(i)) = 1;
	endloop
    endif

    oDestroy EditDeleteConsequences new_ch;

	// !!! LIGANDS or where fix type <> curr type.

    local newatoms = diff [cat rAtoms res, org_atoms];
    oAddToCollection [STRUCTPREP_NEWATOM_SET, newatoms | not aIsLight newatoms];
    return fixed;
endfunction

// FUNCTION:	Fix library errors
// INPUT:	problems and which fix to use to correct.
// RETURN:	mask of app length prob whether I fixed the problem or not.

local function proprep_fix_library [prob,fixidx]
    local [rkeys,abbr,txt,data] = prob;
    local non_cntxt = cat oAtoms diff [Residues [], CNTXT_rkeys];
    local oinert = aInert non_cntxt ;
    aSetInert [non_cntxt, 1];

	// Prio is length xres
	// 1 is more strong match
	// 2 is for weak match
	// 3 is for rName match

    local [xres,xatoms,reparent,prio] = tr data;
    xres = apt get [xres, fixidx];
    prio = apt get [prio, fixidx];
    xatoms = apt get [xatoms,fixidx];

	// Remove keys that need to be merge due to inter chain bond.

    local fixed = zero rkeys;

	// ===== INTER-CHAIN BONDS ===== //

    local merge_rkeys = rkeys | reparent;
    if length merge_rkeys then
	apt oReparent [oChildren pack reparent, merge_rkeys];
	rSetName [merge_rkeys, SPREP_rlib_rname[xres|reparent]];
	oDestroy EditDeleteConsequences pack reparent;
	fixed | reparent = standardize_residue merge_rkeys;
    endif

    local fix_rname = SPREP_rlib_rname[xres];
    local samename = (rName rkeys == fix_rname);

	// ===== rName Problems ===== //
	// It is an rname problems if the fix is an strong library match
	// and lib res has a different name then the current res.

    local m_rname = (not samename) and (prio == STRONG_LIB) and not reparent;
    rSetName [rkeys | m_rname, fix_rname | m_rname];
    fixed | m_rname = standardize_residue (rkeys|m_rname);

	// ===== Chiral Problem ===== //

    local m_chiral = prio == RNAME_CHIRAL;
    if orE m_chiral then
	local bb = app get_BackboneAtoms (rkeys | m_chiral);
	aInvertChirality app third bb;
	fixed | m_chiral = 1;
    endif

	// ===== Structure Problem or Name match only ===== //
	// If there is a strong lib match and the fix == rName rkeys then
	// it is match an other residue (ie. a LYS matching ALA).
	// Also if no strong match is found and only rName res exists in lib
	// mutate. Lastly if there is a weak match but not an rName match
	// between fix and res mutate.

    local m_mut =
	    (samename and prio <> WEAK_LIB and not reparent)
	or ((not samename) and prio == WEAK_LIB and not reparent)
    ;
    m_mut = m_mut and RNAME_CHIRAL <> prio;

    if orE m_mut then
	fixed | m_mut = mut_residue [rkeys|m_mut, fix_rname|m_mut, xres|m_mut];
	standardize_residue (rkeys| (m_mut and fixed));
    endif

	// ===== Topology ? ===== //
	// If there is a weak match and name agreement.

    local m_weak = samename and prio == WEAK_LIB and not reparent;
    if orE m_weak then
	local atoms = cat (xatoms | m_weak);
	local mol = apt tagpeek [SPREP_RLIB[xres|m_weak],'mol'];
	local xidx = app x_pack atoms;
	atoms = app pack atoms;
	copyMolTopology [atoms,mol,xidx];
	Add_H atoms;
	fixed | m_weak = 1;
    endif

    aSetInert [non_cntxt, oinert];
    return fixed;
endfunction;

// FUNCTION:	Create a popup to display in 2D drawing the possible fixes
//		for the residue. 
//		!!! Will only be triggered when all the problems have the 
//		same possiblity of fixes or when only one item is selected.
// INPUT:	SPREP Window key, window trigger, window values, problems.
// RETURN:	NULL, But fixes problem using selection of user.

function DepictionCoordinates;
function Draw2DStructure;

local function SetState_Trigger [wkey,val,trig,xres]

    task_prio 0;
    local systemTopologyState = SystemTopologyState[];

    local mol = apt tagpeek [SPREP_RLIB[xres],'mol'];
    local i;

	// ===== Go into private system ==== //

    local osys = SystemPush [];

    local c = app mol_Create mol;

    local fix_type = apt get [cat apt get [mol,3],MOL_RES_TYPE];
    local bb1, bb2, n, n_atoms;
    local msd,R,t;

	// Superimpose all amino backbones onto each other to try to get all
	// images in same orientation.

	// Amino Acids

    local m_amino = m_join [fix_type, 'amino'];
    if add m_amino > 1 then
	n = x_pack m_amino;
	bb1 = cat sm_MatchAtoms [PRO_BB_MATCH, cat cAtoms c(n(1))];
	for i=2, length n loop
	    bb2 = cat sm_MatchAtoms [
		PRO_BB_MATCH,
		cat cAtoms c(n(i))
	    ];
	    if length bb1 and length bb2 then
		[msd,R,t] = Superpose [[aPos bb1, aPos bb2]];
		n_atoms = cat cAtoms c(n(i));
		aSetPos [
		    n_atoms,
		    app add (R(2) * [(aPos n_atoms) - t(2)])+t(1)
		];
	    endif
	endloop
    endif

	// DNA & RNA

    local m_xna = m_join [fix_type, ['dna','rna']];
    if add m_xna > 1 then
	n = x_pack m_xna;
	bb1 = cat sm_MatchAtoms [DNA_BB_MATCH, cat cAtoms c(n(1))];

	for i=2, length n loop
	    bb2 = cat sm_MatchAtoms [
		DNA_BB_MATCH,
		cat cAtoms c(n(i))
	    ];
	    if length bb1 and length bb2 then
		[msd,R,t] = Superpose [[aPos bb1, aPos bb2]];
		n_atoms = cat cAtoms c(n(i));
		aSetPos [
		    n_atoms,
		    app add (R(2) * [(aPos n_atoms) - t(2)])+t(1)
		];
	    endif
	 endloop
    endif

	// Create mol using new coor.

    mol = app mol_Extract cAtoms c;
    SystemPop osys;

	// ===== Exit private system ==== //

	// Pretty up for 2D picture.

    for i=1, length mol loop
	mol(i) = mol_aSetPos [mol(i), DepictionCoordinates [mol(i)]];
    endloop

	// Create graphics.

    const WIDTH = 150, HEIGHT = 150;
    const DROPT = [
	boundary: [WIDTH, HEIGHT, 'pt'],
	colorcode: 1,
	fontsize: 0.75
    ];
    local grkey = rep [0, length mol];
    for i = 1, length mol loop
	grkey(i) = first Draw2DStructure [mol(i), DROPT];
	local gk = gr_create gr_header grkey(i);
	if i==1 then
	    gr_box [ gk, [
		0, [1,1], [WIDTH-1,HEIGHT-1], 'canvasForeground', 1.0,-1
	    ]];
	else
	    gr_box [ gk, [
		0, [0,0], [WIDTH,HEIGHT], -1, 1.0,-1
	    ]];
	endif
	gr_draw [ gk, grkey(i) ];
	gr_destroy grkey(i);
	grkey(i) = gk;

	gr_text [ grkey(i), [
	    0, [WIDTH-5,5]
	,	mol(i)(3)(MOL_RES_NAME)
	,	'sf', 'canvasForeground', 12.0
	,   [position:'baselineright']
	]];
    endloop

	// Create the panel with the drawings

    local pkey = WindowCreate [
	location: [wkey, trig, 17],
	mode: 'popup',
	Button : [
	    name: 'tbutton', type: 'int',
	    columns: min [length grkey, 4],
	    uniformCols: 1,
	    graphics: grkey,
	    background : 'canvasBackground'
	]
    ];
    gr_destroy grkey;

    WindowShow pkey;				// prompt for the state
    [val,trig] = WindowWait pkey;
    WindowDestroy pkey;

    return val.tbutton;
    exit[];
endfunction

// FUNCTION: 	Panel for library problems 
// INPUT:	NULL
// RETURN:	panel

local function proprep_epnl_library []
    return [
	centerV : 1,
	extendH : 1,
	Hbox : [
	    extendH : 1,
	    uniformCols : 1,
	    Button : [
		extendH : 1,
		name : 'library_state',
		text : 'State'
	    ],
	    Button : [
		extendH : 1,
		name : 'library_cor',
		text : 'Correct Selected',
		bubbleHelp : 'Correct selected items.'
	    ],
	    Button : [
		extendH : 1,
		name : 'library_cor_all',
		text : 'Correct Similar',
		bubbleHelp : 'Correct all Library items.'
	    ]
	]
    ];
endfunction

// FUNCTION: 	Entry point for ProPrep for alternate location.
// INPUT: 	[command,arguments]
// RETURN:	Depends on the command

local function proprep_library [cmd,arg]
    local prob=[], res=[], idx=[];
    local val,trig,wkey;
    local override,err,fix,flag;
    local rkeys,abbr,txt,data,fixed;
    local xres,xatoms,reparent,prio;
    local mvalid;

	// Type of problem must return the following 4 values in a vector.
	// See SPREP_TYPE declaration for more information.
	// TYPE(1) = Problem Name
	// TYPE(2) = Priority
	// TYPE(3) = Summary page help (longer name with more information)
	// TYPE(4) = Assign to a group on summary page if needed (if '' then
	//	     it is not shown.
	// arg = []

    if cmd === 'type' then
	return SPREP_TYPE.library;

	// Returns problem classification. This is used to group
	// problems on the summary problem page.
	// arg = []

    elseif cmd === 'panel' then
	return proprep_epnl_library [];

	// Error panel event. Allows for a user intiated event to occur 
	// for an individual problem.
	// arg = [
	//	Context residue keys
	//	Problems,
	//	Window key,
	//	Window Values,
	//	window trigger
	// ]
	// returns []

    elseif cmd === 'panel_event' then
	[res,prob,wkey,val,trig] = arg;
	local m_fix;

	    // Correct selected library problems.

	if trig == 'library_cor' then
	    m_fix = proprep_fix_library [prob, 1];

	    // Fix all library problems.

	elseif trig == 'library_cor_all' then
	    prob = proprep_diagnose_library res;
	    prob = prob || [prob(SPREP_FIX)];
	    m_fix = proprep_fix_library [prob, 1];

	    // Fix selected library problems with a user specified fix.

	 elseif trig == 'library_state' then
	    [rkeys,abbr,txt,data] = prob;
	    [xres,xatoms,reparent,prio] = app first data;
	    local [result,code] = task_call [
		#SetState_Trigger
	    ,   [wkey,val,trig,xres]
	    ,	[master: 'parent', errmsg : 'ignore']
	    ];

	    if code == '' then
		proprep_fix_library [prob,result];
	    endif
	endif

	    // If we are in interactive mode warn the user that some errors
	    // could not be fixed.

	if (length SPREP_wkey) and not (andE m_fix) then
	    local wrkeys = (first prob) | not m_fix;
	    local wtxt = droplast cat apt swrite [
		'{t:}: {t:}{t:}\n',
		cNumber oParent wrkeys,
		rDisplayName wrkeys,
		rDisplayUID wrkeys
	    ];

	    Warning twrite [
		'Could not fix the following residues:\n {t:}.',
		token wtxt
	];
	endif
	return [];

	// Update attributes of panel if needed. Also allows the user to display
	// Something in MOE upon selection.
	// arg = [
	//	Contect residue keys
	//	Problems,
	//	Window key,
	//	Window Values,
	//	window trigger
	// ]
	// returns []

    elseif cmd == 'panel_update' then
	[res,prob,wkey,val,trig] = arg;
	[rkeys,abbr,txt,data,fixed] = prob;

	    // If selected problem can not be fixed densensitize buttons.

	if not andE fixed then
	    WindowSetAttr [wkey, [
		library_state : [sensitive : 0],
		library_cor : [sensitive : 0],
		library_cor_all : [sensitive : 0]
	    ]];

	    // If there multiple problems selected and they do not have
	    // the same fix then desenstize library state button.
	    // Otherwise all buttons are enabled.

	else
	    [xres] = tr data;
	    xres = uniq xres;
	    txt = [];
	    local opt_sens = 0;
	    if length xres == 1 then
		txt = SPREP_rlib_rname[cat xres];
		opt_sens = 1;
	    endif
	    WindowSetAttr [wkey, [
		library_state : [sensitive : opt_sens],
		library_cor : [sensitive : 1],
		library_cor_all : [sensitive : 1]
	    ]];
	endif
	return [];

	// Diagnose current problems in the context and suggest fixes for them.
	// arg = context rkeys

    elseif cmd === 'diagnose' then
	res = arg;
	prob = proprep_diagnose_library res;
	return prob;

	// Fix problems.
	// arg = [
	//	    context,
	//	    problems
	//	 ]

    elseif cmd === 'fix' then
	[res,prob] = arg;
	return proprep_fix_library [prob,1];

	// Return residue keys to isolate.
	// arg = prob

    elseif cmd === 'isolate' then
	prob = arg(2);
	return first prob;

	// Generate report for error.
	// arg = [context,problems]

    elseif cmd === 'report' then
	[res,prob] = arg;
	return "";

    else
	return [];
    endif
endfunction

// ===== Missing H===========================================================

// FUNCTION: 	Identifies residue with missing hydrogens
// INPUT:	context
// RETURN:	problems

local function proprep_diagnose_missH res 
    local atoms = rAtoms res;
    local prob,rkeys,serial;

    atoms = cat atoms;
    atoms = atoms | aHCount atoms <> aExplicitHCount atoms;
    serial = tr [
	'HCount',
	0
    ];

    if length atoms then
	prob = [
	    0,
	    'HCount',
	    'Incorrect number of hydrogens',
	    [atoms],
	    1,
	    serial
	];
    endif;
    return prob;
endfunction

// FUNCTION:	Fix missing hydrogen errors
// INPUT:	[res,prob]
// RETURN:	NULL, But also assigned correct H Name from library.

local function proprep_fix_missH [res,prob]
    local [rkeys,abbr,txt,addhatoms] = prob;
    addhatoms = cat addhatoms;

	// Add H to residues

    local oldatoms = cat rAtoms CNTXT_rkeys;
    Add_H addhatoms;
    local hatoms = diff [cat rAtoms CNTXT_rkeys, oldatoms];

	// Since sometimes we merge all H issues into 1 residues to show
	// one error get rkeys from addhatoms;

    rkeys = uniq aResidue addhatoms;

	// Automatically assign H name for cases where
	// there is an exact name match and only for added Hs.

    local [xres,xatoms] = _amber_ResidueLookup [
	SPREP_RLIB,
	rkeys,
	STRONGMATCH_OPT
    ];
    [rkeys,xres,xatoms] = [rkeys,xres,xatoms] || [app length xres == 1];
    xatoms = app cat xatoms;

	// Which atoms of the mol exist.

    local x_exist = app x_pack xatoms;
    xatoms = apt get [xatoms,x_exist];

	// Get atom names.

    local stdmol = apt tagpeek [SPREP_RLIB[xres],'mol'];
    local stdaname = cat apt get [cat apt get [stdmol,4],MOL_ATOM_NAME];
    stdaname = apt get [stdaname,x_exist];

    local isSTDname = stdaname == aName xatoms;
    xatoms = cat (xatoms || not isSTDname);
    stdaname = cat (stdaname || not isSTDname);

	// Set name of only Hs

    local isNewH = m_join [xatoms, hatoms];
    aSetName [xatoms | isNewH, stdaname | isNewH];
    return [];
endfunction;

// FUNCTION: 	Panel for atom names
// INPUT:	NULL
// RETURN:	Missing Hs panel

local function proprep_epnl_missH []
    return [
	centerV : 1,
	extendH : 1,
	Hbox : [
	    extendH : 1,
	    uniformCols : 1,
	    Hbox : [
		extendH : 1,
		Button : [
		    extendH : 1,
		    name : 'missH_cor',
		    text : 'Add Hydrogens',
		    bubbleHelp : 'Correct selected items.'
		],
		Button : [
		    name : 'missH_show',
		    text : '?',
		    bubbleHelp : 
			'Briefly select the atoms missing hydrogens\n'
			'in the MOE window.'
		]
	    ],
	    Label : [extendH:1],
	    Label : [extendH:1]
	]
    ];
endfunction

// FUNCTION: 	Entry point for ProPrep for missing Hs
// INPUT: 	[command,arguments]
// RETURN:	Depends on the command

local function proprep_missH [cmd,arg]

    local prob=[], res=[], idx=[];
    local val,trig,wkey;
    local override,err,fix,flag;
    local mvalid;

    if cmd === 'type' then
	return SPREP_TYPE.missH;

    elseif cmd === 'panel' then
	return proprep_epnl_missH [];

    elseif cmd === 'panel_event' then
	[res,prob,wkey,val,trig] = arg;
	if trig == 'missH_cor' then
	    proprep_fix_missH [res,prob];
	elseif trig== 'missH_show' then
	    local atoms = cat prob(4);
	    show_selection [atoms, 0];
	endif
	return [];

    elseif cmd == 'panel_update' then
	return [];

    elseif cmd === 'diagnose' then
	res = arg;
	prob = proprep_diagnose_missH res;
	return prob;

    elseif cmd === 'fix' then
	[res,prob] = arg;
	proprep_fix_missH [res,prob,1];
	return one first prob;

    elseif cmd === 'isolate' then
	prob = arg(2);
	return cat prob(4);

    elseif cmd === 'report' then
	[res,prob] = arg;
	return "";

    else
	return [];
    endif
endfunction

// ===== Bond Topology ============================================

// FUNCTION:	Fix topology of problems
// INPUT:	problems
// RETURN:	NULL

local function fix_bondtopologies prob
    local [rkeys,ptypes,eText,fix,fixable] = prob;
    local [atoms,xres,xidx] = tr (fix| fixable);
    local mol = apt tagpeek [SPREP_RLIB[xres],'mol'];
    copyMolTopology [atoms,mol,xidx];
    Add_H atoms;
    return fixable;
endfunction

// FUNCTION: 	Check topology of residue for exact matches only. If they do not
//	     	match return problems.
// INPUT:	Context residues
// RETURN:	Problems

local function check_bondtopologies res

	// Get keys of exact matches only.

    local [rkeys,xres,xatoms] =
	[res,CNTXT_strongmatch_xres,CNTXT_strongmatch_xatoms] || [
	    CNTXT_libmatch == LIBMATCH_EXACT
    ];
    xatoms = app cat xatoms;

    local i;
    local n = l_length [xres,xatoms];
    local ehintlp	= rep [0, n];
    local eion		= ehintlp;
    local egeom		= ehintlp;
    local ebb		= ehintlp;
    local echiral	= ehintlp;
    local esigma	= ehintlp;
    local ewchiral	= ehintlp;

    local chiral_flag = [];

    local fix = rep [[],n];

    const SP2ORSP3 = [
	1, '[#G7X1][i]',
	1, '[#G6-X1][i]'
    ];

    local mol, idx, atoms;
    local ct = 0;
    local aidx, patoms, osys;
    for i =1, l_length [xres,xatoms] loop

	mol = SPREP_RLIB(xres(i)).mol;
	idx = x_pack xatoms(i);
	atoms = xatoms(i)[idx];
	ebb(i) = not andE (
	       aBackbone atoms == mol(4)(MOL_ATOM_BACKBONE)[idx]
	    or aIsLight atoms
	);
	ehintlp(i) = not andE (
	    aHintLP atoms == mol(4)(MOL_ATOM_HINTLP)[idx]
	);
	egeom(i) = not andE (
		aGeometry atoms == mol(4)(MOL_ATOM_GEOM)[idx]
	    or (aIsLight atoms and orE eqE [[aGeometry atoms],['sp','sp3']])
	    or (    sm_Match [SP2ORSP3, atoms]
		and orE eqE [[aGeometry atoms],['sp2','sp3']]
	    )
	);
	eion(i) = not andE (
	    aIon atoms == mol(4)(MOL_ATOM_ION)[idx]
	);

	if anytrue aForceRS atoms and length chiral_flag then
	    aidx = indexof [atoms, cat rAtoms res];

	    echiral(i) = anytrue (
		    aGeometry atoms == 'sp3'
		and aForceRS atoms <> 0
		and (chiral_flag[aidx] <> aForceRS atoms)
	    );
	    SystemPop osys;
	elseif anytrue aForceRS atoms and isnull chiral_flag then
	    aidx = indexof [atoms, cat rAtoms res];
	    osys = SystemPush res;
	    patoms = cat rAtoms last osys;
	    chiral_flag = aRSChirality patoms;
	    patoms = patoms[aidx];

	    echiral(i) = anytrue (
		    aGeometry patoms == 'sp3'
		and aForceRS patoms <> 0
		and (chiral_flag[aidx] <> aForceRS patoms)
	    );
	    SystemPop osys;
	else
	    echiral(i) = 0;
	endif

	fix(i) = [atoms,xres(i),idx];
    endloop

    const TERM = [
	'Backbone',
	'Hybridization',
	'Hybridization',
	'Ion',
	'Chirality'
    ];
    local eidx = x_pack orE [ebb,ehintlp,egeom,eion,echiral];
    local eText = apt twrite [
	'Incorrect ({|,})',
	 apt mget [nest TERM, tr apt get [
	    [ebb,ehintlp,egeom,eion,echiral],
	    [eidx]
	 ]]
    ];
    local ekeys = rkeys[eidx];
    fix = fix[eidx];

	// Check for WEAK MATCHES

    [rkeys,xres,xatoms] =
	[res,CNTXT_weakmatch_xres,CNTXT_weakmatch_xatoms] || [
	    CNTXT_libmatch == LIBMATCH_WEAK
    ];
    xatoms = app cat xatoms;

    n = l_length [xres,xatoms];
    local eweakchiral = rep [0, n];
    local ehybrid = rep [0, n];
    local ewrongsigma = rep [0, n];

    local wfix = rep [[], n];
    for i =1, l_length [xres,xatoms] loop
	mol = SPREP_RLIB(xres(i)).'mol';
	idx = x_pack xatoms(i);
	atoms = get [xatoms(i),idx];

	    // Check to see if all the same bonds exist in the residue.
	    // Is there a sigma bond missing. Keep the cases where there
	    // is the same sigma skeleton.

	local bonds = mol(4)(MOL_ATOM_BONDS)[idx];
	bonds = app pack apt indexof [bonds, [idx]];
	bonds = apt get [[atoms],bonds];
	local rbonds = aBonds atoms;
	rbonds = rbonds || aElement rbonds <> 'H';
	rbonds = rbonds || oParent rbonds == uniq oParent atoms;

	    // If there is a match with no chiral but no strong match then
	    // there is a chiral issue.

	local [sxres,sxatoms] = _amber_ResidueLookup [
	    SPREP_RLIB,
	    rkeys(i),
	    [level:2, stereo:0]
	];

	ehybrid(i) = alltrue apt m_join [bonds, rbonds]
	    and alltrue apt m_join [rbonds,bonds]
	    and length xres
	;
	    // Compare CA chirality residue and fix to see if they are the
	    // same.

	if rIsAmino rkeys(i) and ehybrid(i) then
	    local chiral = compareCAChirality [
		rkeys(i),
		xres(i)
	    ];
	    if isnull chiral then
		eweakchiral(i) = 0;
	    else
		eweakchiral(i) = andE not chiral;
	    endif
	elseif not app length isnull sxres then
	    eweakchiral(i) = 1;
	else
	    eweakchiral(i) = 0;
	endif

	ewrongsigma(i) = not ehybrid(i) and not eweakchiral(i);

	wfix(i) = [atoms,xres(i),idx];
    endloop

	// Sigma mismatch is the case where there is a missing sigma bond or
	// if there is a different bonding patern but all the same atom names.
	// IE. If a PO4 group moves from 2' to 5' OH.	

    const WTERM = ['Chirality', 'Hybridization', 'Sigma Skeleton'];

    local weidx = x_pack orE [eweakchiral, ehybrid, ewrongsigma];
    local weText = apt twrite [
	'Incorrect {|,}',
	 apt mget [nest WTERM, tr apt get [
	    [eweakchiral, ehybrid, ewrongsigma],
	    [weidx]
	 ]]
    ];
    local wekeys = rkeys[weidx];
    wfix = wfix[weidx];

    local serial = tr ['Topology',oSerialNumber cat [ekeys,wekeys]];

    return [
	cat [ekeys,wekeys],
	'Topology',
	cat [eText,weText],
	cat [fix,wfix],
	cat [one ekeys, not ewrongsigma],
	serial
    ];

endfunction

// FUNCTION:	Topology panel
// INPUT:	NULL
// RETURN:	Panel

local function 	epanel_bondtopologies []
    return [
	centerV : 1,
	extendH : 1,
	Hbox : [
	    extendH : 1,
	    uniformCols : 1,
	    Button : [
		extendH : 1,
		name : 'topology_cor',
		text : 'Correct Selected',
		bubbleHelp : 'Correct selected items.'
	    ],
	    Button : [
		extendH : 1,
		name : 'topology_cor_all',
		text : 'Correct Similar',
		bubbleHelp : 'Correct all Topology items.'
	    ]
	]
    ];
endfunction

// FUNCTION: 	Entry point for ProPrep for topology problems
// INPUT: 	[command,arguments]
// RETURN:	Depends on the command

local function proprep_topology [cmd,arg]
    local prob=[], res=[], idx=[];
    local val,trig,wkey;
    local override,err,fix,flag;
    local mvalid;

    if cmd === 'type' then
	return SPREP_TYPE.topology;

    elseif cmd === 'panel' then
	return epanel_bondtopologies [];

    elseif cmd === 'panel_event' then
	[res,prob,wkey,val,trig] = arg;
	if trig == 'topology_cor' then
	    return fix_bondtopologies prob;
	elseif trig == 'topology_cor_all' then
	    prob = check_bondtopologies res;
	    return fix_bondtopologies prob;
	endif

    elseif cmd == 'panel_update' then
	[res,prob,wkey,val,trig] = arg;
	if orE not prob(SPREP_FIX) then
	    WindowSetAttr [ wkey, [
		topology_cor : [ sensitive : 0 ],
		topology_cor_all : [ sensitive : 0 ]
	    ]];
	else
	    WindowSetAttr [ wkey, [
		topology_cor : [ sensitive : 1 ],
		topology_cor_all : [ sensitive : 1 ]
	    ]];
	endif
	return [];

    elseif cmd === 'diagnose' then
	res = arg;
	prob = check_bondtopologies res;
	return prob;

    elseif cmd === 'fix' then
	[res,prob] = arg;
	return fix_bondtopologies prob;

    elseif cmd === 'isolate' then
	prob = arg(2);
	return first prob;

    elseif cmd === 'report' then
	[res,prob] = arg;
	return "";

    else
	return [];
    endif
endfunction

// ===== NON-STANDARD ATOM NAMES =============================================

// FUNCTION: 	Identifies atom name errors for exact matches only, and
//		non-unique atom names for residues not found in library
// INPUT:	context
// RETURN:	prob (with new tagged vector err contain errors alt loc errors.

local function proprep_diagnose_atomname res 
    local prob = [];

	// Get residue idx and atoms which corespond to RLIB exact match.

    local atoms = CNTXT_strongmatch_xatoms | CNTXT_libmatch == 1;
    local xres = CNTXT_strongmatch_xres | CNTXT_libmatch == 1;
    atoms = app cat atoms;

	// Even though residue is goldplated, xatoms == 0 for
	// H is they do nto exist. Therefore need to account for this.

    local x_exist = app x_pack atoms;
    atoms = apt get [atoms,x_exist];

	// Get mol atom names.

    local stdmol = apt tagpeek [SPREP_RLIB[xres],'mol'];
    local stdaname = cat apt get [cat apt get [stdmol,4],MOL_ATOM_NAME];
    stdaname = apt get [stdaname,x_exist];

    local isSTDname = stdaname == aName atoms;
    atoms = cat (atoms || not isSTDname);
    stdaname = cat (stdaname || not isSTDname);

    local [hatoms,hstdaname] = [atoms,stdaname] || [aElement atoms == 'H'];
    [atoms,stdaname] = [atoms,stdaname] || [aElement atoms <> 'H'];

    [atoms,stdaname] = apt split [
	[atoms,stdaname],
	[mtoc m_uniq oParent atoms]
    ];
    [hatoms,hstdaname] = apt split [
	[hatoms,hstdaname],
	[mtoc m_uniq oParent hatoms]
    ];

	// Non unique atom names in non-standard residues. that are not
	// amino acids, dna or rna.

    local r = (CNTXT_rkeys | not CNTXT_libmatch);
    local ratoms = cat rAtoms (r | m_diff [rType r, ['amino','dna','rna']]);
    ratoms = ratoms | aOccupancy ratoms == 1;
    ratoms = split [ratoms, mtoc m_uniq aResidue ratoms];
    ratoms = ratoms | app length ratoms;
    local anames = aName ratoms;
    local m_uatoms = app m_uniq anames;
    local isHonly = app andE aIsLight (ratoms || not m_uatoms);
    local isHeavyonly = app andE not aIsLight (ratoms || not m_uatoms);

    [ratoms,anames,m_uatoms] = [ratoms,anames,m_uatoms] || [
	not app andE m_uatoms
    ];

	// Assign atom name as aElement + x_id where heavy atoms are numbered
	// first followed by H atoms.

    local badatomnames = zero ratoms;
    local i;
    for i=1, length ratoms loop
	local a  = ratoms(i) | not aIsLight ratoms(i);
	local ha = ratoms(i) | aIsLight ratoms(i);
	anames = aName a;
	local hnames = aName ha;
	if isHonly(i) then
	    hnames = tok_cat [aElement ha, totok x_id ha];
	elseif isHeavyonly(i) then
	    anames = tok_cat [aElement a, totok x_id a];
	else
	    hnames = tok_cat [aElement ha, totok x_id ha];
	    anames = tok_cat [aElement a, totok x_id a];
	endif

	anames = cat [anames, hnames];
	a = cat [a, ha];

	local x = indexof[a, ratoms(i)];
	badatomnames(i) = anames[x_sort x];
    endloop;

    local txt = cat [
	apt twrite [
	    'Non-standard atom name ({t:|,})',
	    app sortuniq aName atoms
	],
	apt twrite [
	    'Non-unique name ({t:|,})',
	    app sortuniq (aName ratoms || not m_uatoms)
	],
	apt twrite [
	    'Non-standard hydrogen name ({t:|,})',
	    app sortuniq aName hatoms
	]
    ];

    local rkeys = cat [
	oParent app first atoms,
	oParent app first ratoms,
	oParent app first hatoms
    ];

    local data = tr [
	cat [atoms, ratoms, hatoms],
	cat [stdaname, badatomnames, hstdaname]
    ];
    local ptype = cat [
	rep ['AName', length atoms],
	rep ['AName', length ratoms],
	rep ['HName', length hatoms]
    ];

    local serial = tr [ptype, oSerialNumber rkeys];
    return [rkeys,ptype,txt,data,1,serial];
endfunction

// FUNCTION:	Fix atom name errors
// INPUT:	[res,prob]
// RETURN:	problems

local function proprep_fix_atomname [res,prob]
    local [rkeys,abbr,txt,data] = prob;
    local [atoms,fix] =  apt cat data;
    aSetName [atoms,fix];
    return [];
endfunction;

// FUNCTION: 	Panel for atom names
// INPUT:	NULL
// RETURN:	atom name panel

local function proprep_epnl_atomname res
    return [
	centerV : 1,
	extendH : 1,
	Hbox : [
	    extendH : 1,
	    uniformCols : 1,
	    Button : [
		extendH : 1,
		name : 'atomname_cor',
		text : 'Correct Selected',
		bubbleHelp : 'Correct selected items.'
	    ],
	    Button : [
		extendH : 1,
		name : 'atomname_cor_all',
		text : 'Correct Similar',
		bubbleHelp : 'Correct all AName items.'
	    ]
	]
    ];
endfunction

// FUNCTION:	Turn on atom name label for atoms with atom name problem
// INPUT:	context residues, problems, window key, window values, window
//		trigger.
// RETURN:	NULL.
const ATOMNAME_PREFIX = 'sprep_atomname_label';
local function proprep_atomname_labels [res,prob,wkey,val,trig]
    local [rkeys,ptype,txt,data] = prob;
    local [atoms,fix] = apt cat data;
    local old = aLabelName atoms;
    aSetHidden [atoms, 0];
    aSetLabelName [atoms, 1];
    WindowSetData [wkey , [ sysprep_grobs : [#_aSetLabelName,[atoms, old]]]];
endfunction


// FUNCTION: 	Entry point for ProPrep for atom name problems
// INPUT: 	[command,arguments]
// RETURN:	Depends on the command

local function proprep_atomname [cmd,arg]
    local prob=[], res=[], idx=[],atoms = [];;
    local val,trig,wkey;
    local override,err,fix,flag;
    local mvalid;

    if cmd === 'type' then
	return SPREP_TYPE.atomname;

    elseif cmd === 'panel' then
	return proprep_epnl_atomname [];

    elseif cmd === 'panel_event' then
	[res,prob,wkey,val,trig] = arg;
	if trig == 'atomname_cor' then
	    proprep_fix_atomname [res,prob];
	elseif trig == 'atomname_cor_all' then
	    prob = proprep_diagnose_atomname res;
	    proprep_fix_atomname [res,prob];
	endif
	return [];

    elseif cmd == 'panel_update' then
	[res,prob,wkey,val,trig] = arg;
	proprep_atomname_labels [res,prob,wkey,val,trig];
	return '';

    elseif cmd === 'diagnose' then
	res = arg;
	prob = proprep_diagnose_atomname res;
	return prob;

    elseif cmd === 'fix' then
	[res,prob] = arg;
	proprep_fix_atomname [res,prob];
	return one first prob;

    elseif cmd === 'isolate' then
	prob = arg(2);
	return first prob;

    elseif cmd === 'report' then
	[res,prob] = arg;
	return "";

    else
	return [];
    endif
endfunction

// ===== Metals ===========================================================

// pdbx_formal_charge from components.cif, except halogens
// using the rule that charge is otherwise # from (el name)#
// halogens: pass through to autotype?

const PDB_IONS = untag [
    AG:1, AL:3, AU:1, BA:2, BR:-1, CA:2, CD:2, CE:3, CL:-1, CO:2, CR:3, CS:1,
    CU:2, EU:2, FE:2, GA:3, GD:3, HG:2, HO:3, I:-1, IN:3, IR:4,  K:1, LA:3,
    LI:1, LU:3, MG:2, MN:2, MO:4, NA:1, NI:3, OS:3, PB:2, PD:2, PR:3, PT:2,
    RB:1, RU:3, SM:3, SR:2, TB:3, TL:1, V:3, W:6, Y:2, YB:3, ZN:2
];

local function rIsAminoXNA rkeys
    if not isflat rkeys then return app rIsAminoXNA rkeys; endif
    return m_join [rType rkeys, ['amino','dna','rna']];
endfunction

// FUNCTION: 	Identifies Bonds with ions. A problem is classified
//		if the metal atom is alone in its residue with
//		addition extra-residue bonds.
// INPUT:	context
// RETURN:	problems

local function proprep_diagnose_metal res 

	// Get metals ions alone in their residue.

    local metals = sm_MatchAll [
	'[#G1!#1,#G2,#T]',
	cat oChildren (res | m_diff [CNTXT_libmatch,[1,2,3]])
    ];
    metals = metals | oChildCount oParent metals == 1;

	// Do any of them have bonds to other residues.

    local bndToMetal = aBonds metals;
    metals = metals | app orE rIsAminoXNA oParent bndToMetal;
    bndToMetal = bndToMetal || rIsAminoXNA oParent bndToMetal;

    local rkeys = oParent metals;
    local ptypes = rep [SPREP_TYPE.metal(1), length metals];
    local met_txt = apt twrite ['Connected metal ({})', aElement metals];
    local data = metals;

    local serial = tr [ptypes, oSerialNumber rkeys];
    return [rkeys,ptypes,met_txt,data,1,serial];
endfunction

// FUNCTION:	Fix ions 
// INPUT:	[res,prob]
// RETURN:	problems

local function proprep_fix_metal [res,prob]
    local [rkeys,ptype,txt,data] = prob;
    local [metals,charge] = tr data;
    local bndToMetal = aBonds metals;

	// Remove bonds to amino acids only.

    bndToMetal = bndToMetal || rIsAminoXNA oParent bndToMetal;
    Unbond [metals, bndToMetal];

	// Set charge of metal and atoms it was bound to.

    aSetIon [metals, aIon metals - app length bndToMetal];
    aSetIon [bndToMetal, aIon bndToMetal -1];
    local midx = indexof [toupper aElement metals,PDB_IONS(1)];

	// Reset charge of metals (this is a fix for cases where the metal
	// charge is incorrect after un bonding.

    local ion_charge = aIon metals;
    ion_charge | midx = PDB_IONS(2)[pack midx];
    aSetIon [metals,ion_charge - app length aBonds metals];
    return [];
endfunction;

// FUNCTION: 	Panel for metal
// INPUT:	NULL
// RETURN:	metal panel

local function proprep_epnl_metal []
    return [
	centerV : 1,
	extendH : 1,
	Hbox : [
	    extendH : 1,
	    uniformCols : 1,
	    Button : [
		extendH : 1,
		name : 'metal_cor',
		text : 'Correct Selected',
		bubbleHelp : 'Correct selected items.'
	    ],
	    Button : [
		extendH : 1,
		name : 'metal_cor_all',
		text : 'Correct Similar',
		bubbleHelp : 'Correct all Metal items.'
	    ]
	]
    ];
endfunction

// FUNCTION: 	Entry point for ProPrep for metal
// INPUT: 	[command,arguments]
// RETURN:	Depends on the command

local function proprep_metal [cmd,arg]
    local prob=[], res=[], idx=[];
    local val,trig,wkey;
    local override,err,fix,flag;
    local mvalid;

    if cmd === 'type' then
	return SPREP_TYPE.metal;

    elseif cmd === 'panel' then
	return proprep_epnl_metal [];

    elseif cmd === 'panel_event' then
	[res,prob,wkey,val,trig] = arg;
	if trig == 'metal_cor' then
	    proprep_fix_metal [res,prob];
	elseif trig == 'metal_cor_all' then
	    prob = proprep_diagnose_metal res;
	    proprep_fix_metal [res,prob];
	endif
	return [];

    elseif cmd == 'panel_update' then
	[res,prob,wkey,val,trig] = arg;
	return [];

    elseif cmd === 'diagnose' then
	res = arg;
	prob = proprep_diagnose_metal res;
	return prob;

    elseif cmd === 'fix' then
	[res,prob] = arg;
	proprep_fix_metal [res,prob];
	return one first prob;

    elseif cmd === 'isolate' then
	prob = arg(2);
	return first prob;

    elseif cmd === 'report' then
	[res,prob] = arg;
	return "";

    else
	return [];
    endif
endfunction

// ===== SE ===========================================================

// FUNCTION: 	Identifies residue with SE.
// INPUT:	context
// RETURN:	problems

local function proprep_diagnose_se res 

	// ===== ENTER PRIVATE SYSTEM ===== //

    local osys = SystemPush res;
    local rkeys = last osys;

    local se = sm_MatchAll ['[Se]',Atoms []];
    local serkeys = uniq aResidue se;

    aSetElement [se, 'S'];
    local [xres,xatoms] = _amber_ResidueLookup [
	SPREP_RLIB,
	serkeys,
	STRONGMATCH_OPT
    ];
    serkeys = serkeys | app length xres;
    local seidx = indexof [serkeys, rkeys];

    SystemPop osys;

	// ===== EXIT PRIVATE SYSTEM ===== //

    serkeys = res[seidx];

	// Get rName and rClass remove blank classes.

    local allrclass = SPREP_rlib_rclass;
    local allrname = SPREP_rlib_rname;
    allrname | allrclass <> '' = allrclass | allrclass <> '';

    local i;
    local se_txt = rep ['', length serkeys];
    xres = xres | app length xres;
    for i = 1, length serkeys loop
	se_txt(i) = twrite [
	    'Selenium containing residue (mutate to {t:|,})',
	    uniq get [allrname, xres(i)]
	];
    endloop
    local data = xres;
    local serial = tr [SPREP_TYPE.se(1), oSerialNumber serkeys];
    if length serkeys then
	return [serkeys,SPREP_TYPE.se(1),se_txt,data,1,serial];
    else
	return [];
    endif
endfunction

// FUNCTION:	Fix Se problems if mutating to S creates a standard residue (
//		as defined as being present in RLIB). If not it is left as SE
//		to warn the user.
// INPUT:	[res,prob]
// RETURN:	mask of app length prob of whether it was fixed or not.

local function proprep_fix_se [prob,fixidx]
    local [rkeys,ptype,txt,xres] = prob;
    local seatoms = sm_MatchAll ['[Se]', cat rAtoms rkeys];
    aSetElement [seatoms, 'S'];
    rSetName [rkeys, SPREP_rlib_rname [apt get [xres,fixidx]]];
    return one rkeys;
endfunction;

// FUNCTION: 	Panel for SE panel
// INPUT:	NULL
// RETURN:	panel for se

local function proprep_epnl_se []
    return [
	centerV : 1,
	extendH : 1,
	Hbox : [
	    extendH : 1,
	    uniformCols : 1,
	    Button : [
		extendH : 1,
		name : 'se_state',
		text : 'State',
		bubbleHelp : 'Mutate Se to S for selected issue.'
	    ],
	    Button : [
		extendH : 1,
		name : 'se_cor',
		text : 'Correct Selected',
		bubbleHelp : 'Mutate Se to S for selected issue.'
	    ],
	    Button : [
		extendH : 1,
		name : 'se_cor_all',
		text : 'Correct Similar',
		bubbleHelp : 'Mutate Se to S for all Selenium issues.'
	    ]
	]
    ];
endfunction

// FUNCTION: 	Entry point for ProPrep for se
// INPUT: 	[command,arguments]
// RETURN:	Depends on the command

local function proprep_se [cmd,arg]
    local prob=[], res=[], idx=[];
    local val,trig,wkey;
    local override,err,fix,flag;
    local mvalid;
    local rkeys,abbr,txt,data, xres;

    if cmd === 'type' then
	return SPREP_TYPE.se;

    elseif cmd === 'panel' then
	return proprep_epnl_se [];

    elseif cmd === 'panel_event' then
	[res,prob,wkey,val,trig] = arg;
	if trig == 'se_cor' then
	    return proprep_fix_se [res,prob];
	elseif trig == 'se_cor_all' then
	    prob = proprep_diagnose_se res;
	    return proprep_fix_se [res,prob];
	elseif trig == 'se_state' then
	    [rkeys,abbr,txt,data] = prob;
	    xres = cat data;
	    local [result,code] = task_call [
		#SetState_Trigger
	    ,   [wkey,val,trig,xres]
	    ,	[master: 'parent', errmsg : 'ignore']
	    ];

	    if code == '' then
		proprep_fix_se [prob,result];
	    endif
	endif
	return [];

    elseif cmd == 'panel_update' then
	[res,prob,wkey,val,trig] = arg;
	[rkeys,abbr,txt,data] = prob;
	xres = uniq data;
	WindowSetAttr [wkey, [
	    se_state : [sensitive : length xres == 1],
	    se_cor : [sensitive : 1],
	    se_cor_all : [sensitive : 1]
	]];
	return [];

    elseif cmd === 'diagnose' then
	res = arg;
	prob = proprep_diagnose_se res;
	return prob;

    elseif cmd === 'fix' then
	[res,prob] = arg;
	return proprep_fix_se [prob,1];

    elseif cmd === 'isolate' then
	prob = arg(2);
	return first prob;

    elseif cmd === 'report' then
	[res,prob] = arg;
	return "";

    else
	return [];
    endif
endfunction

// ===== FUNCTIONS FUNCTIONS TO FIX CHAIN BREAKS/TERMINII ===================
// (CALLED WITHIN proprep_fix_cb & ter) 

const MAX_SIZE_BLDLOOP = 7;

const CBPID = [
    cb		: 1,
    ch_nterm	: 2,
    ch_cterm	: 3
];
const CBINDEX = [
    cb		: 1,
    ch_nterm	: 2,
    ch_cterm	: 2
];

// FUNCTION: 	Create charged version of residues.
// INPUT:	[
//		    residues to be charged,
//		    termini at other end (0 if chain termini),
//		    pid (see CBPID)
//		]
// RETURN:	Atoms which have been added.

local function chrgRes [rkeys,oterm,pid];
    local n_term = cat [
	rkeys | pid == CBPID.ch_nterm,
	oterm | pid == CBPID.cb
    ];
    local c_term = rkeys | pid <> CBPID.ch_nterm;

	// ===== Charge N terminus ===== //

    if length n_term then
	local ntat = app first apt sm_MatchAll [PRO_BB_MATCH, rAtoms n_term];
	ntat = app last ntat;
	aSetIon [ntat, 1];
	aSetGeometry [ntat, 'sp3'];
	Add_H ntat;
    endif

	// ===== Charge C terminus ===== //

    local hatoms;
    if length c_term then

	local coo = app first apt sm_MatchAll [COO_MATCH, rAtoms c_term];
	local hasCOO = app length coo;
	coo = coo | hasCOO;
	if length coo then
	    coo = tr [app second coo, app third coo];
	    hatoms = aBonds cat coo;
	    hatoms = cat (hatoms || m_join [aElement hatoms, ['H', 'LP']]);
	    oDestroy hatoms;
	    aSetGeometry [app first coo, 'sp2'];
	    aSetIon [app first coo, 0];
	    aSetName [app first coo, 'O'];

	    aSetGeometry [app second coo, 'sp3'];
	    aSetIon [app second coo, -1];
	    aSetName [app second coo, 'OXT'];

	    Add_H cat coo;
	endif

	local co = app first apt sm_MatchAll [
	    PRO_BB_MATCH,
	    rAtoms c_term | not hasCOO
	];
	if orE app length co then
	    local c = app first co;

		// !!! NOT GUARENTEED TO ONLY 1 H. If C is SP3 then it may fail.

	    Add_H c;
	    hatoms = cat aBonds cat c;
	    hatoms = cat (hatoms | m_join [aElement hatoms, ['H', 'LP']]);
	    aSetElement [hatoms,'O'];
	    aSetName [hatoms,'OXT'];
	    aSetDist [[c,hatoms],1.256];
	    aSetGeometry [hatoms,'sp3'];
	    aSetIon [hatoms,-1];
	    aSetHidden [hatoms, aHidden c];
	endif

	   // Check for extra bonds to COO when charging. Sometimes if O is
	   // too close to another atom autoConnect creates a bond.

	coo = app first apt sm_MatchAll [COO_MATCH, rAtoms c_term];
	local o1 = app second coo;
	local o2 = app third coo;
	coo = app first coo;

	local i=0;
	for i=1, length coo loop
	    local bond = cat aBonds o1(i);
	    bond = diff [bond, coo(i)];
	    if length bond then Unbond [o1(i), bond]; endif

	    bond = aBonds o2(i);
	    bond = diff [bond, coo(i)];
	    if length bond then Unbond [o2(i), bond]; endif
	endloop
    endif

    return hatoms;
endfunction

// FUNCTION: 	cap residues with NME or ACE
// INPUT:	[
//		    all residues,
//		    residues to be capped,
//		    Is their an opposite terminal to be capped (used in cases
//		    (of missing loops)
//		    termini and terminal type (1 for N, 2 for C)
//		]
// RETURN:	keys for new atoms in system.

local function capRes [res,rkeys,oterm,pid];
    local atoms = cat oAtoms res;

    local n_term = cat [
	rkeys | pid == CBPID.ch_nterm,
	oterm | pid == CBPID.cb
    ];
    local c_term = rkeys | pid <> CBPID.ch_nterm;

	// Cap N termini

    local allres = cat cResidues rChain uniq cat n_term;
    local nokf = pro_Acetylate n_term;
    local aceAtms = oChildren diff [
	cat cResidues rChain uniq cat n_term,
	allres
    ];

	//  Cap C termini

    allres = cat cResidues rChain uniq cat n_term;
    local cokf = pro_Amidate c_term;
    local nmeAtms = oChildren diff [
	cat cResidues rChain uniq cat n_term,
	allres
    ];

    local capAtms = cat cat [aceAtms,nmeAtms];

	// Organize fix flag (if chain break both ends must be fixed)

    local fixflag = zero rkeys;
    if andE (pid == CBPID.cb) then
	fixflag = nokf and cokf;
    elseif andE (pid <> CBPID.cb) then
	fixflag[indexof[n_term, rkeys]] = nokf;
	fixflag[indexof[c_term, rkeys]] = cokf;

	// If this else statement is used something bad happened.

    else
	fixflag = zero rkeys;
    endif
    return [capAtms, fixflag];
endfunction

// FUNCTION:	Is the residue capped.
// INPUT:	residue keys
// RETURN:	mask of 1 if the residue is a cap 0 if not.
local function isProteinCap res
    local ridx = indexof [res, CNTXT_rkeys];

	// A residue will be considered a cap if it has a strong match.
	// NOTE: All residues passed to the function have already gone through
	// a prescreening. Either they are residues with no backbone atoms,
	// or empty residues in chain breaks. If they are a residue with no
	// backbone atoms and they are in the library then it is a cap. If the
	// name is not in the library then it is a cap.

    local iscap = ridx;
    iscap | ridx = oChildCount (res| ridx)
	   and (m_join [CNTXT_libmatch[pack ridx], [0,1]]);
    return iscap;
endfunction

// ===== END OF FUNCTIONS TO FIX CHAIN BREAKS/TERMINII ======================

// ===== FUNCTIONS FOR CHAIN BREAKS =========================================

const CBFIXES = ['Auto','Cap','Charge','Build Loop'];
const CBFIXESHELP = [
	'Select Auto to apply fix specified in details.',
	'Select Cap to Cap terminal ends with NME/ACE.',
	'Select Charge to charge terminal groups.',
	'Select Build Loop to build missing loop.'
];
const CAPGROUPS = ['ACE','NME'];

// FUNCTION:	Return protein residuees
// INPUT:	residue keys
// RETURN:	residue keys of only receptor.

local function getProteinResidues res
    local allpres = res | rIsAmino res;

	// Check for non standard amino acids which may not be classified as AA
	// If bound to only residue that are amino and is in a chain with mostly
	// AA then it is an AA.

    local otherres = res | not rIsAmino res;
    local bndTo = app uniq oParent app cat app aBonds rAtoms otherres;
    bndTo = apt diff [bndTo, otherres];
    [otherres, bndTo] = [otherres,bndTo] || [app length bndTo];
    otherres = otherres | app andE rIsAmino bndTo;
    local mostlyAA = oChildren oParent otherres;
    mostlyAA = (app add mostlyAA)/ (app length mostlyAA);
    otherres = otherres | (mostlyAA > 0.9);
    allpres = cat [allpres, otherres];
    allpres = allpres [x_sort indexof [allpres, res]];

	// acount for cases where an amino acid is part of a ligand. Add empty
	// residues which are a lig chain.

    local ligatoms = _Atoms '$$ligand';
    local ligch = uniq aChain ligatoms;
    ligch = ligch | app andE apt m_join [cAtoms ligch, [ligatoms]];
    local ligres = cat cResidues ligch;
    ligres = uniq cat [ligres, aResidue ligatoms];
    local pres = diff [allpres,ligres];

    return pres;
endfunction

function graph_ccomponent_list;
function BondGraph;

// FUNCTION:	Diagnose Chain break and termini errors
// INPUT:	residue keys.
// RETURN:	problems

local function proprep_diagnose_cb res

    local prob = [];

	// Get protein residues

    local pres = getProteinResidues res;

	// If a residue is NOT bound to the residue on its right in the sequence
	// then it is a Nitrogen terminus. If a reisdue is NOT bound to the 
	// residue on its left them it is a cterminus.

    local isbonded = apt rIsBonded [pres, rotr pres];
    local n_term = pres |(rAtomCount pres
	and ((not isbonded) or (isbonded and (rChain pres <> rChain rotr pres)))
    );
    local n_idx = indexof [n_term, res];

    isbonded = apt rIsBonded [pres, rotl pres];
    local c_term = pres |(rAtomCount pres
	and ((not isbonded) or (isbonded and (rChain pres <> rChain rotl pres)))
    );

    local c_idx = indexof [c_term, res];

	// Save initial values for printing to listbox.

    local [i_n_term,i_c_term] = [n_term,c_term];

    local rres = reverse res;

	// Go ahead one residue in sequence in cases where there are missing
	// N-CA-C=O backbone atoms. This also captures cases which are caped.
	// Since we only want one match per residue use app first to capture
	// one match from two return when charge C terminus.

    local n_bb = app first apt sm_MatchAll [PRO_BB_MATCH,oAtoms n_term];
    local m_n_bb = app length n_bb;
    local t;
    while not andE m_n_bb loop
	t = m_join[indexof[res[n_idx],rres],x_pack (m_uniq oParent rres)];
	if orE t then
	    [n_idx,n_term,m_n_bb,i_n_term] = [n_idx,n_term,m_n_bb,i_n_term] || [
		not t
	    ];
	    [c_idx,c_term,i_c_term] = [c_idx,c_term,i_c_term] || [
		not t
	    ];
	endif
	n_idx | not m_n_bb = (n_idx | not m_n_bb)+1;
	n_term = res[n_idx];
	n_bb = app first apt sm_MatchAll [PRO_BB_MATCH,oAtoms n_term];
	m_n_bb = app length n_bb;
    endloop

	// Go back one residue in sequence in cases where there are missing
	// N-CA-C=O backbone atoms. This also captures cases which are caped.
	// Since we only want one match per residue use app first to capture
	// one match from two return when charge C terminus.

    local c_bb = app first apt sm_MatchAll [PRO_BB_MATCH,oAtoms c_term];
    local m_c_bb = app length c_bb;
    while not andE m_c_bb loop
	t = m_join [c_idx,x_pack (m_uniq oParent res)];
	if orE t then
	    [c_idx,c_term,m_c_bb,i_c_term] = [c_idx,c_term,m_c_bb,i_c_term] || [
		not t
	    ];
	    [n_idx,n_term,i_n_term, n_bb] = [n_idx,n_term,i_n_term, n_bb] || [
		not t
	    ];
	endif
	c_idx | not m_c_bb = (c_idx | not m_c_bb)-1;
	c_term = res[c_idx];
	c_bb = app first apt sm_MatchAll [PRO_BB_MATCH,oAtoms c_term];
	m_c_bb = app length c_bb;
    endloop

	// N chain termini are defined by being the first n terminus in a
	// uniq chain.

    local zres = zero res;
    zres[n_idx]=res[n_idx];
    local ch_nterm = cat app first apt join [
	[n_term],
	split [zres,mtoc m_uniq rChain res]
    ];

    local [ch_n_idx,ch_n_bb,i_ch_nterm] = [n_idx,n_bb,i_n_term] || [
	m_join [n_term, ch_nterm]
    ];
    [n_term,i_n_term,n_bb,n_idx] = [n_term,i_n_term,n_bb,n_idx] || [ m_diff [
	n_term,
	ch_nterm
    ]];


	// C chain termini are defined by being the last c terminus in a
	// uniq chain.

    zres = zero res;
    zres[c_idx]=res[c_idx];
    local ch_cterm = cat app last apt join [
	[c_term],
	split [zres,mtoc m_uniq rChain res]
    ];

    local [ch_c_idx,ch_c_bb,i_ch_cterm] = [c_idx,c_bb,i_c_term] || [
	m_join [c_term, ch_cterm]
    ];
    [c_term,i_c_term,c_bb,c_idx] = [c_term,i_c_term,c_bb,c_idx] || [ m_diff [
	c_term,
	ch_cterm
    ]];

	// Save all termini for cyclic peptide test.

    local [all_ch_nterm,all_ch_cterm] = [i_ch_nterm,i_ch_cterm];

	// ===== SUGGEST FIX SECTION ===== //

	// ===== N CHAIN TERMINI ===== //

    local ch_n_delinfo = cResidues rChain res[ch_n_idx];
    local x = apt indexof [res[ch_n_idx],ch_n_delinfo];
    ch_n_delinfo = apt keep [ch_n_delinfo,x-1];
    local resbefore = app last ch_n_delinfo;
    local m_ncap = isProteinCap resbefore;
    local m_firstres = m_join [ch_n_idx,x_uniq oParent res];

	// Is there a bond with the resbefore? Is there a bond with another
	// chain? Is there a bond with the C chain terminus? (Cyclic peptide)

    local i, bnd;
    for i=1, length ch_nterm loop

	    // Is there a bond with the resbefore? 

	if m_ncap(i) then
	    bnd = uniq oParent cat aBonds cat rAtoms resbefore[i];
	    m_ncap(i) = orE m_join [bnd,ch_nterm(i)];
	    continue;
	endif

	local N = cat aBonds last ch_n_bb(i);

	    // Is there a bond with a residue in another chain? 

	m_ncap(i) = orE m_diff [uniq aChain N, rChain ch_nterm(i)];
	if m_ncap(i) then continue; endif

	    // Is there a bond with the N terminus (Cyclic peptide?)

	m_ncap(i) = orE m_join [uniq aResidue N, all_ch_cterm(i)];

    endloop

	// If terminal residue in the chain is neutral, mark that it should
	// be charged.

    x = x_pack (m_firstres and not m_ncap);
    local ch_ntat = app last ch_n_bb[x];
    local ntrl = aFCharge ch_ntat <> 1;
    local x_ntrl = x | ntrl;

	// if it is not the first residue in the chain and not already
	// capped it.

    local x_cap = x_pack ((not m_firstres) and (not m_ncap));

	// If it is not the first residue but already capped
	// delete extra sequence info. If the preceeding residue is not an
	// amino then all residues with atoms before the terminal residue are
	// ok.

    local m_rtype = rType resbefore <> 'amino';
    m_rtype | not app length m_rtype = 0;
    local lcap_delinfo = ch_n_delinfo | m_rtype;
    ch_n_delinfo | m_rtype = lcap_delinfo || not app oChildCount lcap_delinfo;

    local l = app length ch_n_delinfo;
    l | m_ncap = (l | m_ncap) - 1;
    local x_del = x_pack ((not m_firstres) and m_ncap and l > 0);

    local keys = cat apt get [ [ch_nterm], [x_ntrl,x_cap,x_del]];
    [ch_nterm,i_ch_nterm,ch_n_delinfo] = [ch_nterm,i_ch_nterm,ch_n_delinfo] || [
	m_join [ch_nterm, keys]
    ];
    local ch_nfix = cat [
	rep ['Charge', length x_ntrl],
	rep ['Cap', length x_cap],
	rep ['Delete', length x_del]
    ];
    ch_nfix = ch_nfix[x_sort indexof [keys, ch_nterm]];

	// ===== C CHAIN TERMINI ===== //

	// Get keys to be deleted after termini is fix. (Typically empty res)

    local ch_c_delinfo = cResidues rChain res[ch_c_idx];
    x = apt indexof [res[ch_c_idx],ch_c_delinfo];
    ch_c_delinfo = apt drop [ch_c_delinfo,x];

    local ridx = indexof [res[ch_c_idx], rres];
    local m_lastres = m_join [ridx, x_uniq rChain rres];
    local resafter = app first ch_c_delinfo;
    local m_ccap = isProteinCap resafter;

    for i=1, length ch_cterm loop

	    // Is there a bond with the resafter? 

	if m_ccap(i) then
	    bnd = uniq oParent cat aBonds cat rAtoms resafter[i];
	    m_ccap(i) = orE m_join [bnd,ch_cterm(i)];
	    continue;
	endif

	local C = cat aBonds first ch_c_bb(i);

	    // Is there a bond with a residue in another chain? 

	m_ccap(i) = orE m_diff [uniq aChain C, rChain ch_cterm(i)];
	if m_ccap(i) then continue; endif

	    // Is there a bond with the N terminus (Cyclic peptide?)

	m_ccap(i) = orE m_join [uniq aResidue C, all_ch_nterm(i)];

    endloop

	// If it the last residue and not capped then it needs to be charged.

    x = x_pack (m_lastres and not m_ccap);
    local oxyAtms = aBonds app first ch_c_bb[x];
    oxyAtms = oxyAtms || aElement oxyAtms == 'O';
    local fcharge = aFCharge oxyAtms;
    ntrl = ((not app orE fcharge) and app length fcharge == 2)
	or sm_Match ['[C!H0]', app first ch_c_bb[x]]
    ;
    x_ntrl = x | ntrl;

	// if it is not the first residue in the chain and not already
	// capped, cap it. Get Information on seqences to delete.

    x_cap = x_pack ((not m_lastres) and (not m_ccap));

	// If it is not the first residue but already capped
	// delete extra sequence info if present.

    m_rtype = rType resafter <> 'amino';
    m_rtype | not app length m_rtype = 0;
    lcap_delinfo = ch_c_delinfo | m_rtype;
    ch_c_delinfo | m_rtype = lcap_delinfo || not app oChildCount lcap_delinfo;

    l = app length ch_c_delinfo;
    l | m_ccap = (l | m_ccap) - 1;
    x_del = x_pack (m_lastres and m_ccap and l > 0);

    keys = cat apt get [ [ch_cterm], [x_ntrl,x_cap,x_del]];
    [ch_cterm,i_ch_cterm,ch_c_delinfo] = [ch_cterm,i_ch_cterm,ch_c_delinfo] || [
	m_join [ch_cterm, keys]
    ];
    local ch_cfix = cat [
	rep ['Charge', length x_ntrl],
	rep ['Cap', length x_cap],
	rep ['Delete', length x_del]
    ];
    ch_cfix = ch_cfix[x_sort indexof [keys, ch_cterm]];

	// ===== CHAIN BREAKS ===== // 

	// Save delete info.

    local cb_delinfo = cResidues rChain res[n_idx];
    x = apt indexof [res[n_idx],cb_delinfo];
    cb_delinfo = apt keep [cb_delinfo,x-1];
    x = apt indexof [res[c_idx],cb_delinfo];
    cb_delinfo = apt drop [cb_delinfo,x];

	// Remove cases where it is infact just non-amino acid residues linking
	// a couple of chains. If the loop is one connected component then
	// there is no break;

    local m_naa = zero c_term;
    for i=1, length c_term loop
	local latoms = cat rAtoms cat [c_term(i), cb_delinfo(i), n_term(i)];
	local comp = graph_ccomponent_list BondGraph latoms;
	m_naa(i) = length comp <> 1;
    endloop

	// Removed cases that are not reall breaks.

    [n_idx,n_term,i_n_term,n_bb] = [n_idx,n_term,i_n_term,n_bb] ||
	[m_naa];

    [c_idx,c_term,i_c_term,c_bb] = [c_idx,c_term,i_c_term,c_bb] ||
	[m_naa];

    cb_delinfo = cb_delinfo | m_naa;

	// Remove cases where both ends of the chain break are already capped.
	// and there is no addition sequnce information

    local m_delcap = app isProteinCap cb_delinfo;
    local l_caps = cb_delinfo || m_delcap;
    l_caps = app length l_caps;
    local m_caps = l_caps == 2;

	// Is their sequence info to be deleted.

    local l_del = app length cb_delinfo;
    local m = m_caps and l_del <> 2;
    local cb_cdel,cb_ndel, cb_del_fix, i_cb_cdel;
    if orE m then
	local cb_delinfo_del = cb_delinfo | m;
	i_cb_cdel = c_term | m;
	cb_cdel = app first cb_delinfo_del;
	cb_ndel = app last cb_delinfo_del;
	cb_delinfo_del = apt drop [ cb_delinfo_del, 1];
	cb_delinfo_del = apt drop [ cb_delinfo_del, -1];
	cb_del_fix = rep ['Delete', length cb_cdel];
    endif

	// Removed capped ends

    [n_idx,n_term,i_n_term,n_bb] = [n_idx,n_term,i_n_term,n_bb] ||
	[not m_caps];

    [c_idx,c_term,i_c_term,c_bb] = [c_idx,c_term,i_c_term,c_bb] ||
	[not m_caps];

    [cb_delinfo,m_delcap] = [cb_delinfo,m_delcap] || [not m_caps];

	// Deal with cap, loop and bond cases.

    local cb_fix = rep ['Cap', length c_term];

	// Get loop length remove caps from calculation.

    local l_loop = cb_delinfo || not m_delcap;
    local loop_rname = rName cb_delinfo;
    l_loop = app length l_loop;

	// Get original loop distance. Need to using initial term to account
	// for cases that should not be a loop but may be counted as such
	// since we back peddled the n_idx and c_idx.

    local rdist = indexof [i_n_term,res] - indexof [i_c_term, res];
    local mrdist = rdist > 1 and rdist <= MAX_SIZE_BLDLOOP;
    cb_fix | mrdist = 'Build Loop';

	// If really big loop then cap termini.
	// This is the default setting for the cb_fix.

	// If there is no sequence information for the chain break,
	// do a check to see if they should be bonded. Automatically set
	// l_loop to 0 in cases where rdist =0;

    l_loop | rdist == 0 = 0;

    local m_close =
	    rdist == 0
	and m_join [c_term, i_c_term]
	and m_join [n_term, i_n_term]
    ;

    local ctat = app first (c_bb | m_close);
    local ntat = app last (n_bb | m_close);

	// If less then 1.6 angs then the bond should be formed

    local amDist = aDist [ctat,ntat];
    local isAmBd = amDist >  1.6;
    m_close[(x_pack m_close) | isAmBd] = 0;
    cb_fix | m_close = 'Bond';

	// ===== CREATE ETXT FOR CHAIN TERMINI ===== //

    local ch_ntxt = rep ['',length ch_nfix];
    local m_del = ch_nfix == 'Delete';
    local l_outgap = app length ch_n_delinfo;
    m = l_outgap <> 0 and not m_del;
    ch_ntxt | m = apt twrite [
	'{t:} N terminus, delete {t:} residue outgap',
	ch_nfix | m,
	app length (ch_n_delinfo | m)
    ];
    m = l_outgap == 0 and not m_del;
    ch_ntxt | m = apt twrite ['{t:} N terminus', ch_nfix | m];

    ch_ntxt | m_del = apt twrite [
	'{t:} {t:} residue outgap',
	ch_nfix | m_del,
	app length (ch_n_delinfo | m_del)
    ];


    local ch_ctxt = rep ['',length ch_cfix];
    m_del = ch_cfix == 'Delete';
    l_outgap = app length ch_c_delinfo;
    m = l_outgap <> 0 and not m_del;
    ch_ctxt | m = apt twrite [
	'{t:} C terminus, delete {t:} residue outgap',
	ch_cfix | m,
	app length (ch_c_delinfo | m)
    ];
    m = l_outgap == 0 and not m_del;
    ch_ctxt | m = apt twrite ['{t:} C terminus', ch_cfix | m];
    ch_ctxt | m_del = apt twrite [
	'{t:} {t:} residue outgap',
	ch_cfix | m_del,
	app length (ch_c_delinfo | m_del)
    ];

	// ===== CREATE ETXT FOR CHAIN BREAKS ===== //

    local cb_txt = zero c_term;

    local bldMask = cb_fix == 'Build Loop';
    local looptxt = apt twrite [
	'Build {t:}-loop ({t:}{t:}...{t:}{t:})',
	l_loop | bldMask,
	rDisplayName c_term | bldMask,
	rDisplayUID c_term | bldMask,
	rDisplayName n_term | bldMask,
	rDisplayUID n_term | bldMask
    ];
    cb_txt | bldMask = looptxt;

    local bndMask = cb_fix == 'Bond';
    local bndtxt = apt twrite [
	'Create bond with {t:}{t:}',
	rDisplayName n_term | bndMask,
	rDisplayUID n_term | bndMask
    ];

    cb_txt | bndMask = bndtxt;

    local capMask = cb_fix == 'Cap';
    local captxt = apt select [
	apt twrite ['{t:}-loop', l_loop | capMask],
	'break',
	l_loop | capMask
    ];
    captxt = apt twrite [
	'Cap {t:} ({t:}{t:}...{t:}{t:})',
	captxt,
	rDisplayName c_term | capMask,
	rDisplayUID c_term | capMask,
	rDisplayName n_term | capMask,
	rDisplayUID n_term | capMask
    ];

    cb_txt | capMask = captxt;

    local deltxt = apt twrite [
	'Delete {t:} residues ({t:}{t:}...{t:}{t:})',
	app length cb_delinfo_del,
	rDisplayName app first cb_delinfo_del,
	rDisplayUID app first cb_delinfo_del,
	rDisplayName app last cb_delinfo_del,
	rDisplayUID app last cb_delinfo_del
    ];

	// merge cb_del and cb

    c_term = cat [c_term, cb_cdel];
    i_c_term = cat [i_c_term, i_cb_cdel];
    n_term = cat [n_term, cb_ndel];
    l_loop = cat [l_loop, app length cb_delinfo_del];
    cb_delinfo = cat [cb_delinfo, cb_delinfo_del];
    cb_fix = cat [cb_fix, cb_del_fix];
    cb_txt = cat [cb_txt, deltxt];

	// Create Data structure

    local pid = cat [
	rep [CBPID.ch_nterm, length ch_nterm],
	rep [CBPID.ch_cterm, length ch_cterm],
	rep [CBPID.cb, length c_term]
    ];
    local oterm = cat [zero ch_nterm, zero ch_cterm, n_term];
    l_loop = cat [zero ch_nterm, zero ch_cterm, l_loop];
    local fix = cat [ch_nfix, ch_cfix, cb_fix];
    local delinfo = cat [ch_n_delinfo, ch_c_delinfo, cb_delinfo];

    local rkeys = cat [ch_nterm, ch_cterm, c_term];
    local data = tr [rkeys,pid,fix,oterm,l_loop,delinfo];

    rkeys = cat [i_ch_nterm,i_ch_cterm,i_c_term];

    local ptypes = cat [
	stretch [SPREP_TYPE.cb(1)(CBINDEX.ch_nterm), length ch_nterm],
	stretch [SPREP_TYPE.cb(1)(CBINDEX.ch_cterm), length ch_cterm],
	stretch [SPREP_TYPE.cb(1)(CBINDEX.cb), length c_term]
    ];

    local serial = tr [ptypes, oSerialNumber rkeys, oSerialNumber oterm];

    local etxt = cat [ch_ntxt,ch_ctxt,cb_txt];

    local m_uniq_errors = (m_uniq delinfo) or (app length delinfo == 0);
    [rkeys,ptypes,etxt,data,serial] = [rkeys,ptypes,etxt,data,serial] || [
	m_uniq_errors
    ];

    return [rkeys,ptypes,etxt,data,1,serial];
endfunction

// FUNCTION:	Fix cb errors
// INPUT:	[residues,problems, override]
// RETURN:	mask of app length problem of whether it was fixed or not.

local function proprep_fix_cb [res,prob,override]

    local [keys,ptype,etxt,data] = prob;
    local [rkeys,pid,fix,otherterm,l_loop,delinfo] = tr data;

	// In cases where the override is used there will be only one
	// type of fix therefore we can apply it to all selected fixes.

    if isnull override then override = ''; endif

    if override <> '' then
	fix = rep [override,length fix];
    endif

    local m,txt;
    local bldAtms=[],chrgAtms=[],capAtms=[],capFlag, bndAtms=[];
    local fixflag = one rkeys;

	// ===== Build missing loops ===== //

    local bldFix = fix == 'Build Loop';
    if anytrue bldFix then

	    // Does any c termini have COO. If yes delete 1 oxygen

	local oxy = app first apt sm_MatchAll [COO_MATCH, rAtoms rkeys];

	    // !!! Which oxygen should I take.

	oxy = oxy | app length oxy;
	oxy = tr [app second oxy, app third oxy];
	oxy = oxy || aName oxy == 'OXT';
	oxy = app first oxy;
	oxy = oxy | app length oxy;
	local light = aBonds oxy;
	light = light | m_join [aElement light, ['H', 'LP']];
	oDestroy cat [oxy,light];

	    // Delete any atoms in residue in the middle of the loop.

	oDestroy cat rAtoms cat (delinfo | bldFix);

	   // Delete any caps in delinfo;

	local caps = apt join [delinfo | bldFix, [CAPGROUPS]];
	oDestroy cat caps;

	   // Get loop residues

	local loopres = delinfo | bldFix;
	loopres = loopres || oValid loopres;
	loopres = apt cat [rkeys | bldFix, loopres];
	loopres = apt cat [loopres, otherterm | bldFix];

	local flag;
	[bldAtms,flag] = buildLoop [
	    res | CNTXT_libmatch <> LIBMATCH_LPATOMS,
	    loopres,
	    'Building Loop'
	];
	if length bldAtms then
	    local [r,c] = task_call [
		#MinimizeAtomSubSet,
		[res,bldAtms],
		[errmsg: 'ignore', master: 'parent']
	    ];
	    if c <> '' then exit []; endif
	endif
	if alltrue app oChildCount loopres then
	    app standardize_residue loopres;
	endif

	fixflag | bldFix = flag;
    endif

	// ===== Create amide bonds between residues ===== //

    local bndFix = fix == 'Bond';
    if anytrue bndFix then
	local bndres = tr [otherterm | bndFix, rkeys | bndFix];
	app pro_Polymerize bndres;
    endif

	// ===== Charge residues ===== //

    local term,oterm,ttype;
    local chrgFix = fix == 'Charge';
    if anytrue chrgFix then
	oDestroy (delinfo | chrgFix);
	chrgAtms = chrgRes ([rkeys,otherterm,pid] || [chrgFix]);
	standardize_residue uniq aResidue chrgAtms;
    endif

	// ===== Cap residues ===== //

    function rSetCapUID cap
	local adj = uniq oParent cat aBonds cat oChildren cap;
	adj = diff [adj,cap];
	local m_cap = m_diff [rName adj,CAPGROUPS];

	if anytrue m_cap then
	    local allres = cat cResidues rChain cap;
	    local xa = indexof [adj|m_cap, allres];
	    local xc = indexof [cap, allres];
	    local pa = rPos adj|m_cap;
	    local uid = (rUID (adj | m_cap)) + (xc-xa);
	    rSetUID [cap, uid];
	    rSetPos [cap, pa + (xc-xa)];
	endif
    endfunction

    local capFix = fix == 'Cap';
    if anytrue capFix then
	oDestroy (delinfo | capFix);
	[capAtms, capFlag] = capRes [
	    res		| oValid res,
	    rkeys	| capFix,
	    otherterm	| capFix,
	    pid		| capFix
	];
	standardize_residue uniq aResidue capAtms;
	app rSetCapUID uniq aResidue capAtms;
	fixflag | capFix = capFlag;
	aSetTether [capAtms,aPos capAtms,10,0,0.25];
    endif

    local delFix = fix == 'Delete';
    if anytrue delFix then
	oDestroy (delinfo | delFix);
    endif

    local newatoms = cat [bldAtms,chrgAtms,capAtms];
    oAddToCollection [
	STRUCTPREP_NEWATOM_SET,
	newatoms | not aIsLight newatoms
    ];
    return fixflag;
endfunction;

// FUNCTION: 	Panel for chain breaks and termini 
// INPUT:	NULL
// RETURN:	Chain Break panel

local function proprep_epnl_cb []
    local cbhelp = token droplast cat apt swrite ['{t:}\n', CBFIXESHELP];

    return [ centerV : 1, extendH : 1, Hbox : [
	extendH : 1,
	uniformCols : 1,
	Option : [
	    name : 'cb_options',
	    extendH : 1,
	    text : CBFIXES,
	    bubbleHelp : cbhelp
	],
	Button : [
	    extendH : 1,
	    name : 'cb_cor',
	    text : 'Correct Selected',
	    bubbleHelp : 'Correct selected items.'
	],
	Button : [
	    extendH : 1,
	    name : 'cb_cor_all',
	    text : 'Correct Similar',
	    bubbleHelp : 'Correct all similar items.'
	]
    ]];
endfunction

// FUNCTION:	Set page default when chain break and termini error is selected
// INPUT:	window key, problems
// RETURN:	refusal page text.

local function proprep_set_page_defaults_cb [wkey,prob]

    local fixes = CBFIXES;
    local cbhelp = CBFIXESHELP;
    local txt;
    local init_cb_opt = first CBFIXES;

	// If there is a Chain Break & Termini selected return refusal text.
	// Otherwise set correct page on CB pabel and sensitivities.

    local ptype = uniq second prob;
    if length ptype <> 1 then
	txt = 'Please select 1 type of error';
    else
	local [rkeys,pid,fix,otherterm,l_loop,delinfo] = tr prob(4);
	local cbsens = 1;

	    // If we need to delete disable options.

	if anytrue (fix == 'Delete') then cbsens = 0; endif

	    // If there is no sequence info or termini
	    // then remove 'Build Loop' option

	if
		cbsens
	    and (alltrue ((app length delinfo) == 0) or ptype == 'Termini')
	then
	    fixes = CBFIXES | CBFIXES <> 'Build Loop';
	    cbhelp = CBFIXESHELP | CBFIXES <> 'Build Loop';
	elseif cbsens and anytrue ((app length delinfo) == 0) then
	   cbsens = 0;
	endif

	if (length uniq fix) == 1 then
	    init_cb_opt = uniq fix;
	endif

	cbhelp = token droplast cat apt swrite ['{t:}\n', cbhelp];
	WindowSetAttr [ wkey, [
	    //cb_pager : [page : 1],
	    cb_options : [ text: fixes, bubbleHelp: cbhelp, sensitive: cbsens ]
	]];
	txt = '';
    endif

	// Set set option pagers to first in list.

    WindowSetData [wkey, [
	cb_options : init_cb_opt
    ]];

    return txt;
endfunction


// FUNCTION: 	Entry point for ProPrep for chain breaks and termini.
// INPUT: 	[command,arguments]
// RETURN:	Depends

local function proprep_cb [cmd,arg]
    local prob=[], cntxt=[],res=[], idx=[];
    local val,trig,wkey;
    local override,err,fix,rmask,flag;
    local mvalid;
    local keys,pid,fixes,oterm,lpLength;

    if cmd === 'type' then
	return SPREP_TYPE.cb;

    elseif cmd === 'panel' then
	return proprep_epnl_cb [];

    elseif cmd === 'panel_event' then
	[res,prob,wkey,val,trig] = arg;
	override = val.cb_options;

	if override == first CBFIXES then
	    override = '';
	endif

	if trig == 'cb_cor'then
	    proprep_fix_cb [res,prob,override];
	elseif trig == 'cb_cor_all'then
	    local ptype = uniq second prob;
	    prob = proprep_diagnose_cb res;
	    prob = prob || [second prob == ptype];

	    [keys,pid,fixes,oterm,lpLength] = tr prob(4);
	    local tooshort =
		    orE (override <> fixes)
		and override <> ''
		and override == 'Cap'
		and ptype == 'Break'
		and l_length prob > 1
	    ;
	    local toolong =
		    orE (override <> fixes)
		and override <> ''
		and override == 'Build Loop'
		and ptype == 'Break'
		and l_length prob > 1
	    ;
	    local terminicap =
		    orE (override <> fixes)
		and override <> ''
		and override == 'Cap'
		and ptype == 'Termini'
		and l_length prob > 1
	    ;
	    local terminicharge =
		    orE (override <> fixes)
		and override <> ''
		and override == 'Charge'
		and ptype == 'Termini'
		and l_length prob > 1
	    ;

	    local ans = 1;
	    if toolong then
		ans = YesNoCancel
		    'Do you wish to build the long loops?\n'
		    'If no then only short loops will be build.'
		;
		if not ans then
		    prob = prob || [fixes == 'Build Loop'];
		endif
	    elseif tooshort then
		ans = YesNoCancel
		    'Do you wish to cap the short loops?\n'
		    'If no then only long loops will be capped.'
		;
		if not ans then
		    prob = prob || [fixes == 'Cap'];
		endif
	    elseif terminicap then
		ans = YesNoCancel
		    'Do you wish to cap all chain termini?\n'
		    'If no then only termini with outgaps will be capped.'
		;
		if not ans then
		    prob = prob || [fixes == 'Cap'];
		endif
	    elseif terminicharge then
		ans = YesNoCancel
		    'Do you wish to charge all chain termini?\n'
		    'If no then only termini without outgaps will be charged.'
		;
		if not ans then
		    prob = prob || [fixes == 'Charge'];
		endif

	    endif

	    proprep_fix_cb [res,prob,override];
	endif
	return [];

    elseif cmd == 'panel_update' then
	[res,prob,wkey,val] = arg;
	local txt = proprep_set_page_defaults_cb [wkey,prob];
	return txt;

    elseif cmd === 'fix' then
	[res,prob] = arg;
	proprep_fix_cb [res,prob,''];
	return one first prob;

    elseif cmd === 'diagnose' then
	res = arg;
	prob = proprep_diagnose_cb res;
	return prob;

    elseif cmd === 'isolate' then
	prob = arg(2);
	local data = prob(4);
	[keys,pid,fixes,oterm,lpLength] = tr data;
	return cat [keys,oterm | oterm <> 0];

    elseif cmd === 'report' then
	[res,prob] = arg;
	return "";

    else
	return [];
    endif
endfunction

// ===== FORCEFIELD ========================================================

// diagnoseFF examines the system and reports (for each residue) the
// presence of forcefield issues.  A single error is reported for each
// residue in the system.  Multiple residues can be implicated in a
// single forcefield issue.  Return the prob structure.

local function diagnoseFF res 

	// Set up the data structure to record the troubles

    local org_res = res;
    local osys = SystemPush res;
    res = last osys;
    local atoms = cat rAtoms res;		// relevant atoms
    for 3 loop					// extend out to torsion
	atoms = uniq cat prepend [aBonds atoms, atoms];
    endloop

	// The issues are collected one at a time and then
	// collated into a single list related to the residues

    const TERM = ['type','str','ang','stb','tor','vdw'];
    local eTerm = rep [zero res, length TERM];

    function AddIssue [ akeyidx, text ]
	local i;

	local iterm = indexof [text, TERM];

	if not l_length akeyidx then return; endif
	local akeylists = apt get [ [atoms], akeyidx ];

	for i = 1, length akeylists loop
	    local idx = pack indexof [aResidue akeylists(i), res];
	    eTerm(iterm) = put [first [eTerm(iterm),eTerm(iterm)=[]], idx, 1];
	endloop
    endfunction

	// Collect the various issues related to parameterization
	// !!! oop, !!! itor

    local info = pot_Info[];
    local xbond = BondGraph atoms;
    local deg = app length xbond;

    local mask = aMMType atoms == '??';
    AddIssue [ x_pack mask, 'type' ];

    if info.vdwEnable then
	mask = not first pot_Parm_vdw [atoms,atoms];
	AddIssue [ [atoms|mask], 'vdw' ];
    endif

    local xB = stretch [x_id xbond, deg];
    local xC = cat xbond;

    if info.strEnable then
	mask = not first pot_Parm_str [atoms[xB],atoms[xC]];
	AddIssue [ [xB,xC] || [mask and xB < xC], 'str' ];
    endif

    local xA = cat xbond[xB];
    [xB,xC] = apt stretch [[xB,xC], nest deg[xB]];
    [xA,xB,xC] = [xA,xB,xC] || [xA <> xC];

    if info.angEnable then
	mask = not first pot_Parm_ang apt get [[atoms],[xA,xB,xC]];
	AddIssue [ [xA,xB,xC] || [mask and xA < xC], 'ang' ];
    endif
#if 0
    if info.stbEnable then
	mask = not first pot_Parm_stb apt get [[atoms],[xA,xB,xC]];
	AddIssue [ [xA,xB,xC] || [mask and xA < xC], 'stb' ];
    endif
#endif
    [xA,xB,xC] = [xA,xB,xC] || [xB < xC];
    local xD = cat xbond[xC];
    [xA,xB,xC] = apt stretch [ [xA,xB,xC], nest deg[xC] ];
    [xA,xB,xC,xD] = [xA,xB,xC,xD] || [ xB <> xD and xA <> xD ];

    if info.torEnable then
	mask = not first pot_Parm_tor apt get [[atoms],[xA,xB,xC,xD]];
	AddIssue [ [xA,xB,xC,xD] || [mask], 'tor' ];
    endif

	// Prepare the text messages from the data vectors

    local eText = rep ['' , length res];
    local idx = x_pack iadd eTerm;

    eText[idx] = apt twrite [
	'Missing parameters ({|,})',
	 apt mget [nest TERM, tr apt get [eTerm, [idx]]]
    ];

    SystemPop osys;
    local serial = tr ['FF', oSerialNumber org_res];
    return [
	org_res | eText <> '',
	rep [ 'FF', add (eText <> '')],
	eText | eText <> '',
	rep [ [], add (eText <> '')],
	0,
	serial | eText <> ''
    ];
endfunction

// FUNCTION: 	Entry point for ProPrep for atom type errors.
// INPUT: 	[command,arguments]
// RETURN:	Depends on the command

local function proprep_forcefield [cmd,arg]
    local prob=[], rkeys, idx=[];
    local val,trig,wkey;
    local override, err, fix, rmask, flag;

    if cmd === 'type' then
	return SPREP_TYPE.ff;

    elseif cmd === 'panel' then				// widgets
	return [centerV : 1, extendH : 1,
	    Text : [
		name : 'ff_text',
		title : 'Forcefield:',
		sensitive : 0
	    ]
	];

    elseif cmd === 'panel_event' then
	[rkeys,prob,wkey,val,trig] = arg;
	return [];

    elseif cmd == 'panel_update' then
	[rkeys,prob,wkey,val,trig] = arg;
	WindowSetData [wkey, [ff_text : (pot_Info []).title]];
	return '';

    elseif cmd === 'fix' then
	[rkeys,prob] = arg;
	return [];

    elseif cmd === 'diagnose' then
	return diagnoseFF arg;

    elseif cmd === 'isolate' then
	prob = arg(2);
	return first prob;

    elseif cmd === 'report' then
	[rkeys,prob] = arg;
	return "";

    endif
endfunction

// ===== CHARGES ===========================================================

// FUNCTION: 	Identifies residue with missing hydrogens
// INPUT:	context
// RETURN:	problems

local function proprep_diagnose_charge res 
    local atoms = cat rAtoms res;

    const QNEG = SMARTS_TABLE [                 // must be negative charge
	1, '[#8;+0,-*;X2,X][#1,#6,#G5,#G6!#8]',
	1, '[N;+0,-*;X3,X2,X1][#1,#6,#G5!#7]',
	1, '[#9;+0;X1][!#G8]',
	0
    ];

    local prob = [[],[],[],[],[],[]];
    local serial;
    local q = aCharge atoms;
    local Q = iadd aIon atoms;
    if andE (abs q < 1e-4) then
	if not andE sm_Match ['[#1,CX4]', atoms] then
	    serial = nest ['Charge', 'No charge'];
	    return [
		0,
		'Charge',
		'System is not charged',
		[atoms],
		1,
		serial
	    ];
	endif
    endif

    if (abs ((add q) - Q)) > 0.0001 then
	serial = nest ['Charge', 'Charge <> Ion'];
	prob = [
	    0,
	    'Charge',
	    'Partial charge does not equal ionization',
	    [atoms],
	    1,
	    serial
	];
    elseif orE ((q | sm_Match [QNEG, atoms]) > -0.1) then
	serial = nest ['Charge', 'Incorrect charge'];
	prob = [
	    0,
	    'Charge',
	    'System has incorrect partial charges',
	    [atoms],
	    1,
	    serial
	];
    endif
    return prob;
endfunction

// FUNCTION:	Fix missing hydrogen errors
// INPUT:	[res,prob]
// RETURN:	NULL, But also assigned correct H Name from library.

local function proprep_fix_charge [res,prob]
    local [rkeys,abbr,txt,data] = prob;
    local atoms = cat data;
    local q = first PartialCharge [atoms, 'FF'];
    aSetCharge [atoms, q];
    return [];
endfunction;

// FUNCTION: 	Panel for atom names
// INPUT:	NULL
// RETURN:	Missing Hs panel

local function proprep_epnl_charge []
    return [
	centerV : 1,
	extendH : 1,
	Hbox : [
	    extendH : 1,
	    uniformCols : 1,
	    Hbox : [
		extendH : 1,
		Button : [
		    extendH : 1,
		    name : 'charge_cor',
		    text : 'Charge System',
		    bubbleHelp :
			'Charge system using method for'
			'current forcefield.'
		],
		Button : [
		    name : 'charge_show',
		    text : '?',
		    bubbleHelp : 
			'Briefly select the atoms being charged\n'
			'in the MOE window.'
		]
	    ],
	    Label : [extendH:1],
	    Label : [extendH:1]
	]
    ];
endfunction

// FUNCTION: 	Entry point for ProPrep for missing Hs
// INPUT: 	[command,arguments]
// RETURN:	Depends on the command

local function proprep_charge [cmd,arg]

    local prob=[], res=[], idx=[];
    local val,trig,wkey;
    local override,err,fix,flag;
    local mvalid;

    if cmd === 'type' then
	return SPREP_TYPE.charge;

    elseif cmd === 'panel' then
	return proprep_epnl_charge [];

    elseif cmd === 'panel_event' then
	[res,prob,wkey,val,trig] = arg;
	if trig == 'charge_cor' then
	    proprep_fix_charge [res,prob];
	elseif trig== 'charge_show' then
	    local atoms = cat prob(4);
	    show_selection [atoms, 0];
	endif
	return [];

    elseif cmd == 'panel_update' then
	return [];

    elseif cmd === 'diagnose' then
	res = arg;
	prob = proprep_diagnose_charge res;
	return prob;

    elseif cmd === 'fix' then
	[res,prob] = arg;
	proprep_fix_charge [res,prob,1];
	return one first prob;

    elseif cmd === 'isolate' then
	prob = arg(2);
	return cat prob(4);

    elseif cmd === 'report' then
	[res,prob] = arg;
	return "";

    else
	return [];
    endif
endfunction
#eof

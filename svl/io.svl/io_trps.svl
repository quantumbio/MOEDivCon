#svl
//	io_trps.svl		Tripos file format I/O
//
//	30-nov-2020 (mk) fix property data conversion
//	31-jan-2020 (mk) utf-8 sweep
//	10-oct-2018 (kk) Use private system in ReadTriposeMOL2
//	05-apr-2018 (pl) replace >C.cat= with C.2, expose ConvertTriposCTAB
//	30-jan-2018 (hf) D20 -> D2O
//	10-oct-2017 (mk) use current rotamer libs for amino acid dedection
//	19-jan-2017 (em) Correct MOL2 export
//	26-apr-2016 (hf) native gzip support
//	26-feb-2016 (em) Add Write support for @<TRIPOS>PROPERTY_DATA
//	03-feb-2016 (mk) use cTagId to split tags
//	19-oct-2015 (em) Add Read support for @<TRIPOS>PROPERTY_DATA
//	25-oct-2012 (jl) Write single-letter (uniq-ified) chain names
//	01-oct-2012 (jl) use amber10.mdb and pro_StandardRes [] to set rTypes
//	25-jun-2012 (hf) set CellParameters before mol_Create
//	14-oct-2011 (jl) honor NO_CHARGES in @<TRIPOS>MOLECULE
//	01-sep-2011 (kk) Default to chain name for mol_name when non-null
//	08-jul-2011 (kk) Preserve MOL_NAME on export; SystemPush/Pop
//	08-jul-2011 (kk) Simplify atom partition logic on write
//	06-jun-2011 (jl) Fix multi-molecule/chain problem writing mol2 file
//	01-feb-2011 (jl) insert double bond C.cat/N.pl3 groups
//	22-jun-2010 (jl) fix fwrite_TriposMOL2, atom/chain order, subst name
//	01-aug-2009 (pl) do explicit aSetPos when creating chains
//	29-may-2009 (jl) corrections re: backbone flags, substr names/numbers
//	05-jan-2009 (pl) GOLD write option
//	31-jan-2008 (jl) improve guessing for w/o-H input, deal w/ explicit LP
//	11-jan-2008 (jl) fixed various SUBSTRUCTURE bugs
//	28-nov-2007 (pl) fixed mol_type bug (repeats)
//	19-nov-2007 (pl) strip blanks from residue chain names
//	21-sep-2007 (pl) updated chain letter catenation
//	05-sep-2007 (pl) don't cat .* on funny chain names
//	28-aug-2007 (pl) always write substructures
//	14-aug-2007 (pl) fixed Read_ Write_ format name bug
//	01-dec-2006 (pl) read PBC data
//	11-nov-2006 (pl) overhaul reader and writer - new typing rules
//	22-aug-2006 (kk) protect FixAroOco2 from LPs
//	15-aug-2006 (pl) write N.am for sulfonamides
//	13-jul-2006 (pl) provide fread_, atom ids are arbitrary not sequential
//	08-jul-2006 (pl) fixed ar bonds on O.co2, zero charge writing
//	05-dec-2005 (pl) fixed sulfonamide anions
//	04-oct-2005 (pl) fixed writing of coordination bonds
//	25-jan-2005 (pl) better fixing of ar bonds on import
//	13-dec-2004 (pl) fixed write of NO2 SO2 PO etc., deleted read FC adjust
//	23-jun-2004 (pl) fixed writing of aromatic bonds
//	21-jun-2004 (jd) mark chains, aro, rUID, rINS, fwrite_TriposMOL2
//	17-feb-2004 (jd) missing db_Close in function ImportTriposMOL2
//	07-jan-2004 (pm) convert types tolower so that s.o == s.O
//	22-nov-2002 (pl) added db_ExportTriposMOL2
//	21-nov-2002 (pl) N aro bug and furan bug
//	02-aug-2002 (pm) fixed output field width when nAtoms is power of 10
//	04-jun-2002 (kk) C.1 bo, 3/4 chars for resname, O.co2=sp2 db_->mol_
//	20-mar-2002 (pl) re-wrote molecule division logic on write (cTag etc)
//	30-oct-2001 (pm) fixed field width bugs in fwrites
//	30-apr-2001 (pl) incorporated ctab_to_mol analysis
//	06-feb-2001 (pm) changed File to $File
//	03-jan-2001 (al) return value from ReadTriposMOL2
//	22-dec-2000 (pm) added option file_field
//	30-oct-2000 (al) allow uppercase types in BOND block
//	16-jul-2000 (pl) added P.4 to input types
//	25-jan-2000 (pl) fixed isonitrile bug on write
//	29-jun-1999 (pl) fixed N.pl3 on write for aromatics
//	18-may-1999 (kk) pick up resnames from substructure(7)
//	03-may-1999 (jd) Wrapper function db_ImportMOL2
//	19-apr-1999 (pl) import of tripos to database
//	05-feb-1999 (kk) allow no substructure line
//	26-jan-1999 (kk) add N.pl3 SMILES for tryprophan ring N
//	06-nov-1998 (pl) added O.co2 type
//	07-aug-1998 (kk) rnames in atoms, support atom permute
//	04-oct-1996 (pl) notice
//
// COPYRIGHT (C) 1996-2020 CHEMICAL COMPUTING GROUP ULC ("CCG").
// ALL RIGHTS RESERVED.
//
// PERMISSION TO USE, COPY, MODIFY AND DISTRIBUTE THIS SOFTWARE IS HEREBY
// GRANTED PROVIDED THAT: (1) UNMODIFIED OR FUNCTIONALLY EQUIVALENT SOFTWARE
// DERIVED FROM THIS SOFTWARE MUST CONTAIN THIS NOTICE; (2) ALL CODE DERIVED
// FROM THIS SOFTWARE MUST ACKNOWLEDGE THE AUTHOR(S) AND INSTITUTION(S); (3)
// THE NAMES OF THE AUTHOR(S) AND INSTITUTION(S) NOT BE USED IN ADVERTISING
// OR PUBLICITY PERTAINING TO THIS SOFTWARE WITHOUT SPECIFIC WRITTEN PRIOR
// PERMISSION; (4) ALL CODE DERIVED FROM THIS SOFTWARE BE EXECUTED WITH THE
// MOLECULAR OPERATING ENVIRONMENT LICENSED FROM CCG.
//
// CCG DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
// ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, AND IN NO EVENT
// SHALL CCG BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
// ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
// IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
// OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#set title	'Tripos File I/O'
#set class	'MOE:file-io'
#set version	'2020.11'

function pro_StandardRes;
function amber_ResidueLibrary;
function Write_Prompt, Read_Return, Read_ProcessStandardOptions;
function Read_Prompt, Read_Return, Read_ProcessStandardOptions;
function RenderProtein;

#ifnbif putadd
    local function putadd [sum, I, Ival]	// putadd sum(I) += Ival
	[I,Ival] = apt resize [[I,Ival], l_length [I,Ival]];
	local [idx, mask] = sam I;
	[I,Ival] = apt get [[I,Ival],[idx]];
	local dst = I | mask;
	sum[dst] = sum[dst] + s_add [Ival, mtoc mask];
	return sum;
    endfunction
#endif

// A Tripos file is an white-space separated ASCII file with '#' indicating
// comment lines.  The file is divided into blocks of lines with each block
// having the format
//
//	@<class>section
//
// and tripos uses @<TRIPOS>XXX where XXX can be (in order of appearance)
//
// MOLECULE
//
//	L1:	molecule title
//	L2:	#atoms #bonds #substructures #features #sets
//	L3:	SMALL or PROTEIN or NUCLEIC_ACID or BIOPOLYMER or POLYMER
//	L4:	NO_CHARGES or USER_CHARGES or DICT_CHARGES or GAST_HUCK
//	L5:	? (INVALID_CHARGES)
//	L6:	? (Lattice Structure)
//
// ATOM
//
//	id# name x y z type substr# substrname charge flags
//
//	flags : WATER|BACKBONE|DICT|DIRECT|ESSENTIAL|CAP (| are separators)
//
// BOND
//
//	id# atom# atom# order flags
//
//		order :	1 2 3 ar am du un
//		flagss : BACKBONE|DICT|INTERRES|CAP	(| are separators)
//
// DICT
//
//	L1:	dictionary-type dictionary-name
//
// SUBSTRUCTURE	substructure (e.g., residues)
//
//	id# name alpha-atom# type (?) (chain ID?) res-class (?) flags
//
//		type : RESIDUE|TEMP
//		flags : ROOT|DICT
//
//	NOTE: only the first three fields are required; this code is
//	written to expect either seven fields, or three

const MODIFY_GUANIDINIUM = 1;	// insert double bond = 1

const MOLECULE_BLOCK	 = "@<TRIPOS>MOLECULE";
const ATOM_BLOCK	 = "@<TRIPOS>ATOM";
const BOND_BLOCK	 = "@<TRIPOS>BOND";
const SUBSTRUCTURE_BLOCK = "@<TRIPOS>SUBSTRUCTURE";

const EMPTY = '****';	// indicates field is empty

const WATER_RES = ['HOH', 'WAT', 'TIP', 'SOL', 'OH2', 'DOD', 'D2O'];
const DNA_RES   = ['DT', 'DA', 'DG', 'DC', 'DI', 'DU',
		   'T' , 'A' , 'G' , 'C' , 'I' , 'U' , 'N'
];

const NUCLEIC_MAIN = [
    'C3\'','C4\'','C5\'', 'O3\'','O3\'','O5\'',
    'C3*','C4*','C5*','O1P','O2P','O3P','O3*','O5*','P'
];
const AMINO_MAIN = ['N','CA','C','O','OXT','CH3'];

// =============================== READING ===================================

// PerceiveElement tries to get the element from the Tripos type by
// looking for an element-like prefix if the atype is not already an element

local function PerceiveElement atype
    local i, j;

    atype = tolower atype;
    local elsym = tolower ELEMENT_SYM;
    local ELSYM = ELEMENT_SYM;

    const XLATE = [
	[ 'Du', 'Du.C', 'ANY', 'HEV', 'HET', 'HAL', 'LP' ],
	[ 'lp', 'c',    'c',   'c',   'n',   'f',   'lp' ]
    ];
    i = indexof [atype, tolower XLATE(1)];
    (atype | i) = XLATE(2)[pack i];

    local el = atype;

    local eidx = indexof [atype, elsym];
    (el | eidx) = ELSYM[pack eidx];
    (atype | eidx) = '';

    for i in x_pack not eidx loop
	if atype(i) == 'lp' then
	    el(i) = 'LP';
	    atype(i) = '';
	elseif (j = indexof [".", string atype(i)]) then
	    el(i) = tok_keep [atype(i), dec j];
	    atype(i) = tok_drop [atype(i), dec j];
	    if (j = indexof [el(i), elsym]) then
		el(i) = ELSYM(j);
	    else
		el(i) = 'C';
	    endif
	else
	    el(i) = 'C';
	    atype(i) = '.3';
	endif
    endloop

    return [el, tok_cat [el,atype]];
endfunction

// ConvertTriposCTAB converts a ctab and partial information into a mol
// structure trying largely to ignore tripos atom types and focusing
// on the bond orders and elements.

global function ConvertTriposCTAB ctab
    local i, idx, mask;

    local [el, atype] = PerceiveElement ctab(1)(CTAB_A_SYM);

    local atno	 = el_Protons el;
    local col	 = el_spValence el;
    local charge = ctab(1)(CTAB_A_CHARGE);
    local ion	 = zero charge;

    local bA	 = ctab(2)(CTAB_B_FROM);
    local bB	 = ctab(2)(CTAB_B_TO);
    local bO	 = ctab(2)(CTAB_B_TYPE);

	// Check whether there are hydrogens present.  Check, too, whether
	// there are formal charges - integral, non-zero values.  Determine
	// whether there are atoms adjacent to atoms with positive fc's, and
	// whether there are H's connected to each atom.

    local has_H   = orE (atno == 1);
    local fcharge = zero charge, pneigh = zero charge;
    local Hneigh  = zero charge;
    if (add abs charge) > 0.1 then
	idx = x_pack (((abs charge) >= 1) and ((mod1 charge) < 0.01));
	fcharge[idx] = charge[idx];
    endif

    Hneigh = putadd [zero ion, bA | (atno[bB] == 1), 1];
    Hneigh = putadd [Hneigh, bB | (atno[bA] == 1), 1];

    pneigh = putadd [zero ion, bA | (fcharge[bB] >= 1), 1];
    pneigh = putadd [pneigh, bB | (fcharge[bA] >= 1), 1];

    local deg  = putadd [putadd [zero ion, bA, 1], bB, 1];
    local nLP = putadd [putadd [zero ion, bA, el[bB]=='LP'], bB, el[bA]=='LP'];

	// replace any aromatic bonds involving C.cat with single bonds

    if orE (mask = (atype == 'C.cat')) then
	(bO | bO == CTAB_BT_ARO and (mask[bA] or mask[bB])) = 1;
    endif

	// look at the aromatic subgraph paying attention to the
	// terminal ar bonds to Group VI (O.co2, S.2, etc)
	// which we will attempt to pair up into O=X-[O-] resonance

    local nA = putadd [zero atype, bA | bO == CTAB_BT_ARO, 1];
    nA = putadd [nA, bB | bO == CTAB_BT_ARO, 1];

    local npi = zero atype;			// number of pi bonds

    for i = 2, 4 loop
	npi = putadd [putadd [npi, bA | bO == i, i], bB | bO == i, i];
    endloop

    local term_ar = (col == 6 and (deg - nLP) == 1 and nA > 0);

    local arbond = graph_uneighbors ([bA,bB] || [term_ar[bA] or term_ar[bB]]);

    if length arbond < length term_ar then
	arbond = cat [arbond, rep [[], length term_ar - length arbond]];
    endif

    for i in x_pack (not term_ar and app length arbond > 1) loop
	local cap = [0,0,0,0,1,1,2,3,0](inc col(i));	 // pi capacity
	local Oco2 = sort arbond(i);

	while length Oco2 > 1 while npi(i) < cap loop
	    [idx, mask] = sam atype[Oco2];
	    Oco2 = split[Oco2[idx], mtoc mask];
	    Oco2 = Oco2[x_sort neg app length Oco2];

	    if length Oco2(1) > 2 then
		Oco2 = cat Oco2;
	    else
		Oco2 = cat Oco2;
		Oco2 = Oco2[x_sort neg atno[Oco2]];
	    endif

	    term_ar(Oco2(1)) = -2;			// double bond
	    term_ar(Oco2(2)) = -1;			// single bond
	    npi(i) = inc npi(i);			// one more double bond

	    Oco2 = drop [Oco2, 2];
	endloop

	ion[Oco2] = -1;
	term_ar[Oco2] = -1;
    endloop

    if length (idx = x_pack (bO == CTAB_BT_ARO)) then
	mask = term_ar[bA[idx]] == -2 or term_ar[bB[idx]] == -2;
	bO[idx | mask] = 2;
	idx = idx | not mask;

	mask = term_ar[bA[idx]] == -1 or term_ar[bB[idx]] == -1;
	bO[idx | mask] = 1;
	idx = idx | not mask;
    endif

    arbond = term_ar = nA = [];

	// remove any aromatic bonds that remain and assign single/double
	// bonds.  We preferentially weight aromatic-type atoms

    local n2 = putadd [putadd [zero ion, bA, bO == 2], bB, bO == 2];

    if orE (bO == CTAB_BT_ARO) then
	const WEIGHT = tr [
	    [ 'C.2',	 5 ],
	    [ 'C.ar',	 5 ],
	    [ 'N.2',	 5 ],
	    [ 'N.ar',	 5 ]
	];
	i = indexof [atype, WEIGHT(1)];
	local Wa = mput [one atype, i, WEIGHT(2)[pack i]];

	i = x_pack (bO == CTAB_BT_ARO);
	mask = (
	      (col[bA[i]] <> 5 and n2[bA[i]])
	   or (col[bB[i]] <> 5 and n2[bB[i]])
	);
	bO[i | mask] = 1;
	i = i | not mask;

	mask = graph_maxmatch [bA[i], bB[i], Wa[bA[i]] + Wa[bB[i]]];
	bO[i] = inc notnot mask;
    endif

	// special known atom types are assigned formal charges
	// based upon the type of atom

    local nO = select [bO, 1.5, bO <> CTAB_BT_ARO];
    nO = select [0, bO, el[bA] == 'LP' or el[bB] == 'LP'];

    local sumbo = putadd [putadd [zero ion, bA, nO], bB, nO];
    sumbo = floor (sumbo + 1/12);

	// Replace C.cat with 3 nbrs and 4 bonds with C.2

    if length (idx = x_pack (atype == 'C.cat' and sumbo == 4 and deg == 3)) then
	atype[idx] = 'C.2';
    endif

    function SetIon [val, idx, mask]
	ion[idx | mask] = val;
	return idx | not mask;
    endfunction

    if length (idx = x_pack (col == 4)) then
	idx  = SetIon [ 1, idx, atype[idx] == 'C.cat'];
	idx  = SetIon [-1, idx, (pneigh[idx] and atype[idx] == 'C.1')];
	mask = (abs fcharge[idx]) >= 1;
	ion [idx | mask] = fcharge [idx | mask];
	idx  = idx | not mask;
	idx  = SetIon [-1, idx, sumbo[idx] >= 5];
	idx  = SetIon [ 0, idx, sumbo[idx] == 4];
	idx  = SetIon [-1, idx, Hneigh[idx]];
	ion[idx] = 0;		// vs. default to -1
    endif

    if length (idx = x_pack (el == 'O')) then
	mask = (abs fcharge[idx]) >= 1;
	ion [idx | mask] = fcharge [idx | mask];
	idx  = idx | not mask;
	idx  = SetIon [ 0, idx, sumbo[idx] == 2];
	idx  = SetIon [-1, idx, atype[idx] == 'O.co2'];
	idx  = SetIon [ 1, idx, sumbo[idx] >= 3];
	idx  = SetIon [-1, idx, sumbo[idx] == 1 and atype[idx] == 'O.2'];
	idx  = SetIon [ 0, idx, sumbo[idx] == 0];
	idx  = SetIon [-1, idx, has_H];
	ion[idx] = 0;		// vs. default to -1
    endif

    if length (idx = x_pack (el <> 'O' and col == 6)) then
	mask = (abs fcharge[idx]) >= 1;
	ion [idx | mask] = fcharge [idx | mask];
	idx  = idx | not mask;
	idx  = SetIon [ 0, idx, sumbo[idx] >= 6];
	idx  = SetIon [ 1, idx, sumbo[idx] == 5];
	idx  = SetIon [ 0, idx, sumbo[idx] == 4];
	idx  = SetIon [ 1, idx, sumbo[idx] == 3];
	idx  = SetIon [ 0, idx, sumbo[idx] == 2];
	idx  = SetIon [-1, idx, sumbo[idx] == 1 and atype[idx] == 'S.2'];
	idx  = SetIon [ 0, idx, sumbo[idx] == 0];
	idx  = SetIon [-1, idx, has_H];
	ion[idx] = 0;		// vs. default to -1
    endif

    if length (idx = x_pack (col == 5)) then
	idx  = SetIon [1,  idx, atype[idx] == 'N.4'];
	idx  = SetIon [-1, idx, ((atype[idx] == 'N.2') and (deg[idx] == 2) and
				 (sumbo[idx] == 2))
	];
	mask = (abs fcharge[idx]) >= 1;
	ion [idx | mask] = fcharge [idx | mask];
	idx  = idx | not mask;
	idx  = SetIon [ 1, idx, sumbo[idx] >= 6];
	idx  = SetIon [ 0, idx, sumbo[idx] == 5];
	idx  = SetIon [ 1, idx, sumbo[idx] == 4];
	idx  = SetIon [ 0, idx, sumbo[idx] == 3];
	idx  = SetIon [-1, idx, Hneigh[idx]];
	ion[idx] = 0;		// vs. default to -1
    endif

    if length (idx = x_pack (deg == 0)) then
	ion[idx] = int charge[idx];
    endif

#if MODIFY_GUANIDINIUM

	// Modify bonding for C.cat/N.pl3 groups

    local Catneigh, tryN, ndx, iN, jC, ib;
    if length (idx = x_pack (atype == 'N.pl3')) then
	Catneigh = putadd [zero ion, bA | (atype[bB] == 'C.cat'), 1];
	Catneigh = putadd [Catneigh, bB | (atype[bA] == 'C.cat'), 1];

	idx = idx | andE [
	    Catneigh[idx] == 1, deg[idx] == 3, not fcharge[idx],
	    sumbo[idx] == 3
	];
	if length idx then
	    tryN = idx[x_sort (2 - Hneigh[idx])];	// bond #3 is C.cat

	    mask = (atype == 'C.cat');
	    ndx  = x_pack (mask[bA] or mask[bB]);
	    for iN in tryN loop
		ib = ndx(x_pack ((bA[ndx] == iN) or (bB[ndx] == iN)));
		jC = [bA(ib), bB(ib)] | not ([bA(ib), bB(ib)] == iN);
		if ion(jC) then
		    ion(jC) = ion(jC) - 1;
		    ion(iN) = ion(iN) + 1;
		    bO(ib)  = CTAB_BT_2;
		endif
	    endloop
	endif
    endif
#endif

    // replace the modified quantities and return
    ctab(1)(CTAB_A_SYM)    = el;
    ctab(1)(CTAB_A_CHARGE) = ion;
    ctab(2)(CTAB_B_TYPE)   = bO;

    return ctab;
endfunction

// Make sure both amino and nucleic acids are res-typed correctly
// (set RNA if the residue contains the properly-named, extra oxygen)

local function SetResTypes [mdata, mol, res_name, substr_id, amber_rnames]
    local res_choices = cat [pro_StandardRes [], amber_rnames];
    local res_type    = select ['amino', 'none', indexof[res_name,res_choices]];

    local ndx = x_sort mdata.asubstr;
    local na  = btoc mdata.asubstr[ndx];
    local an  = split [(mol_aName mol)[ndx], na], i;

    for i in x_pack indexof [res_name, DNA_RES] loop
	res_type(i) = 'dna';
	if anytrue indexof [an(substr_id(i)), ['O2*', 'O2\'']] then
	    res_type(i) = 'rna';
	endif
    endloop

    return res_type;
endfunction

// fread_TriposMOL2 reads a molecule from a tripos file (returning a mol)
// We are given an unget_buff which consists of a possible vector of lines
// to be read first

global function fread_TriposMOL2 [mol_file, unget_buff]
    local fnum = fopenrz mol_file;

	// ReadLine reads in a line from the file and stores it into
	// the variable 'line'.  We also increment the line number.  We
	// return true if a line was read and 0 if end of file.

    local line = "";				// line in the file
    local valid_Q = 1;				// charges valid?

    function ReadLine []
	line = [];
	local argv = [];
	local gotline = 0, ldata;
	loop
	    if length unget_buff then
		ldata = last unget_buff;
		unget_buff = droplast unget_buff;
	    else
		ldata = freadb [fnum, 'line', 1];
		if isnull ldata then break; endif
		ldata = cat ldata;
	    endif
	    gotline = 1;
	    if not (last ldata === "\\") then
		argv = append [argv, ldata];
		break;;
	    endif
	    argv = append [argv, droplast ldata];
	endloop
	line = cat argv;
	return gotline;
    endfunction

    function UnreadLine []
	unget_buff = append [unget_buff, line];
    endfunction

    function ReadBlockLine []
	if not ReadLine [] then return 0; endif
	if line(1) === "@" then
	    UnreadLine [];
	    return 0;
	elseif line(1) === "#" then	//Comment line... Keep reading
	    return ReadBlockLine [];
	endif
	return 1;
    endfunction

	// IsBlock tests what kind of block header it is

    function IsBlock btype
	if not (line(1) === "@") then return 0; endif
	return keep [line, length btype] === btype;
    endfunction

	// MoleculeBlock reads the MOLECULE block.  It is assumed that
	// we are on the @<TRIPOS>MOLECULE line itself

    local ctab;
    local mol;					// db_mol to save
    local mdata;				// molecule data

    function MoleculeBlock []
	ctab = ctab_Extract [];			// empty
	mol  = [];

	mdata = [
	    natoms:	0,				// # atoms
	    nbonds:	0,				// # bonds
	    nsubs:	0,				// # substructures
	    name:	'',				// molecule name
	    atype:	[],				// atom type tokens
	    cell:	['', [1,1,1], [90,90,90]],	// cell parameters
	    small:	0,				// small mols don't
							// set/use rUID's
	    pdata:	[]				// Property Data
	];

	    // read the molecule name

	if not ReadBlockLine [] then return; endif
	while first line === " " loop line = dropfirst line; endloop
	while last line === " " loop line = droplast line; endloop
	mdata.name = token line;

	    // read the item counts

	if not ReadBlockLine [] then return; endif
	local c = int round first sread [cat [line, " 0 0 0"], '{n}{n}{n}'];

	mdata.natoms = max [0, c(1)];
	mdata.nbonds = max [0, c(2)];
	mdata.nsubs  = max [0, c(3)];

	    // read the residue type, check whether it's a small molecule

	if not ReadBlockLine [] then return; endif	// type line
	while first line === " " loop line = dropfirst line; endloop
	while last line === " " loop line = droplast line; endloop
	if token line == 'SMALL' then mdata.small = 1; endif

	    // read the charge status

	if not ReadBlockLine [] then return; endif	// charge line
	if token line == 'NO_CHARGES' then valid_Q = 0; endif
    endfunction

	// AtomBlock reads in all of the atom records in the
	// @<TRIPOS>ATOM section of a molecule.

    function AtomBlock []
	local i;
	local adata = rep [[], mdata.natoms], natoms = 0;

	for i = 1, mdata.natoms while ReadBlockLine[] loop
	    local argv = wordsplit [line, " \t\012\015"];
	    if length argv < 10 then
		argv = cat [argv, rep ["", 10 - length argv]];
	    else
		argv = keep [argv, 10];
	    endif
	    natoms = inc natoms;
	    adata(i) = app token argv;		// add data item
	endloop

	mdata.natoms = natoms;
	adata = tr keep [adata,natoms];

	local zatoms = rep [0, natoms], deczatoms = dec zatoms;

	ctab(1)(CTAB_A_X)	= atof adata(3);
	ctab(1)(CTAB_A_Y)	= atof adata(4);
	ctab(1)(CTAB_A_Z)	= atof adata(5);
	ctab(1)(CTAB_A_SYM)	= adata(6);
	ctab(1)(CTAB_A_MASS)	= zatoms;
	ctab(1)(CTAB_A_CHARGE)	= select [atof adata(9), 0, valid_Q];
	ctab(1)(CTAB_A_STEREO)	= zatoms;
	ctab(1)(CTAB_A_HCOUNT)	= deczatoms;
	ctab(1)(CTAB_A_RADICAL)	= zatoms;
	ctab(1)(CTAB_A_APO)	= deczatoms;
	ctab(1)(CTAB_A_RGROUP)	= deczatoms;
	ctab(1)(CTAB_A_NUM)	= int atof adata(1);

	mdata.acharge	= ctab(1)(CTAB_A_CHARGE);
	mdata.atype	= ctab(1)(CTAB_A_SYM);
	mdata.aname	= adata(2);
	mdata.abackbone	= m_findmatch ['*BACKBONE', adata(10)];
	mdata.asubstr	= int atof adata(7);
    endfunction

	// BondBlock reads the @<TRIPOS>BOND section of the file

    function BondBlock []
	local i;
	local bdata = rep [0, mdata.nbonds], nbonds = 0;

	for i = 1, mdata.nbonds while ReadBlockLine[] loop
	    local argv = wordsplit [line, " \t\012\015"];
	    if length argv < 4 then
		argv = cat [argv, rep ["", 4 - length argv]];
	    else
		argv = keep [argv, 4];
	    endif
	    nbonds = inc nbonds;
	    bdata(i) = app token tolower argv;		// add data item
	endloop

	bdata = dropfirst tr keep [bdata,nbonds];	// A,B,O

	const B_TYPE = tr [			// conversion table
	    ['1', 1], ['am',1],			// 1 must be first
	    ['2', 2], ['3', 3],
	    ['ar', CTAB_BT_ARO],		// "aromatic" bond
	    ['du',0], ['un',0]
	];

	bdata(1) = indexof [int atof bdata(1), ctab(1)(CTAB_A_NUM)];
	bdata(2) = indexof [int atof bdata(2), ctab(1)(CTAB_A_NUM)];
	bdata(3) = B_TYPE(2)[maxE [1, indexof [tolower bdata(3), B_TYPE(1)]]];

	    // strip illegal bonds and duplicate bonds (taking first)
	    // and fill the ctab structure with the data

	bdata = bdata || [
		bdata(1) > 0 and bdata(1) <= l_length ctab(1)
	    and bdata(2) > 0 and bdata(2) <= l_length ctab(1)
	    and bdata(3) > 0
	];

	bdata = bdata || [m_uniq (
	      minE [bdata(1),bdata(2)] * l_length ctab(1)
	    + maxE [bdata(1),bdata(2)]
	)];

/*
	bdata = bdata || [
		ctab(1)(CTAB_A_SYM)[bdata(1)] <> 'Du'
	    and ctab(1)(CTAB_A_SYM)[bdata(2)] <> 'Du'
	];
*/

	ctab(2)(CTAB_B_FROM  ) = bdata(1);
	ctab(2)(CTAB_B_TO    ) = bdata(2);
	ctab(2)(CTAB_B_TYPE  ) = bdata(3);
	ctab(2)(CTAB_B_STEREO) = zero bdata(1);

	mdata.nbonds = nbonds = l_length ctab(2);

	ctab = ConvertTriposCTAB ctab;
	mol = first mol_ExtractFromCTAB ctab;

	mol(1)(MOL_NAME) = mdata.name;

	mol(2)(MOL_CHAIN_NAME) = mdata.name;

	mol(4)(MOL_ATOM_NAME)	  = mdata.aname;
	mol(4)(MOL_ATOM_CHARGE)   = mdata.acharge;
	mol(4)(MOL_ATOM_BACKBONE) = mdata.abackbone;

	mdata.abackbone = [];
	mdata.acharge = [];
	mdata.aname = [];
    endfunction

	// SubstructureBlock reads in the substructure definitions
	// and adjusts the molecule (possibly re-arranging the
	// atoms)

    function SplitResidueName [str,resstr]
	str = string str;
	resstr = string resstr;
	local rname = '', ruid = 0, rins = " ";
	local vals  = fieldsplit [str, "_"];

	if length vals > 1 then
	    rname     = first vals;
	    local tmp = last vals;
	    ruid      = int atof token tmp[x_pack isdigit tmp];
	    if not isdigit last tmp then rins = last tmp; endif
	    if (anytrue app isnull vals) or (not isdigit last rname) then
		ruid = -ruid;
	    endif

	else
	    rname    = str;
	    local c1 = last str;
	    local c2 = last droplast str;

	    if isdigit c1 or (not isdigit c1 and isdigit c2) then
		if not isdigit c1 and isdigit c2 then
		    rins  = last str;
		    rname = droplast str;
		endif
		if (token resstr <> token "") and (strpos [resstr, rname] == 1) then     // the sdata(7) defines the residue code
		    ruid = int atof token drop [rname, length resstr];
		    rname = keep [rname, length resstr];
		else                                                    // execute standard MOE process
            vals = split [rname, btoc isdigit rname];
            if alltrue isdigit last vals then
                ruid  = int atof token last vals;
                rname = cat droplast vals;
            endif
	    endif
	    endif
	endif

	return [token keep [rname, 4], ruid, keep [rins, 1]];
    endfunction

    function ParseResidueName [str,resstr]
	if (str == '') or (str == EMPTY) then return ['*', 0, " "]; endif

	    // For small molecules, we'll only break the substructure name
	    // if it's too long (> 4 characters)

	if mdata.small then
	    if tok_length str <= 4 then return [str, 0, " "]; endif
	endif

	return SplitResidueName [str,resstr]; // [rname, ruid, rins]
    endfunction

    function SubstructureBlock []
	local i;
	local sdata = rep [[], mdata.nsubs], nsubs = 0;

	    // Extract the entries in rotamer libraries that have rType as
	    // {amino, l-amino or r-amino}

	local amber_amino = findmatch ['*amino*', R_TYPES];
	local amber_lib   = amber_ResidueLibrary [];
	local amber_mask  = zero x_id amber_lib;
	for i = 1, length amber_lib loop
	    amber_mask(i) = andE indexof [amber_lib(i).mol(3)(MOL_RES_TYPE),
		amber_amino
	    ];
	endloop
	local amber_rnames = (apt tagget [amber_lib, 'rName']) | amber_mask;

	for i = 1, mdata.nsubs while ReadBlockLine [] loop
	    local argv = wordsplit [line, " \t\012\015"];
	    if length argv < 7 then
		argv = cat [argv, rep ["", 7 - length argv]];
	    else
		argv = keep [argv, 7];
	    endif
	    argv = app token argv;
	    sdata(i) = argv;
	    nsubs = inc nsubs;
	endloop

	sdata = tr keep [sdata, nsubs];
	mdata.nsubs = nsubs;
	if nsubs <= 0 then return; endif		// leave as-is

	    // decide on the residue name, number and ins from the
	    // substructure name.  If argv(7) is non-empty then get
	    // the residue class from there

	local substr_id = int atof sdata(1);

	local res_chain = sdata(6);
	local res_name, res_uid, res_ins;
	local tmp_res_name, tmp_res_uid, tmp_res_ins;
	for i = 1, length sdata(2) loop
	    [tmp_res_name, tmp_res_uid, tmp_res_ins] = ParseResidueName [sdata(2)(i),sdata(7)(i)];
	    res_name = cat [res_name, tmp_res_name];
	    res_uid = cat [res_uid, tmp_res_uid];
	    res_ins = cat [res_ins, tmp_res_ins];
	endloop

//	local [res_name, res_uid, res_ins] = tr app ParseResidueName [ sdata(2),sdata(7) ];
//	local [res_name, res_uid, res_ins] = tr app ParseResidueName sdata(2);
	local res_type  = SetResTypes [
	    mdata, mol, res_name, substr_id, amber_rnames]
	;
	if length (i = x_pack not indexof [mdata.asubstr, substr_id]) then
	    res_name  = append [res_name, '*'];
	    res_uid   = append [res_uid, 0];
	    res_ins   = append [res_ins, " "];
	    res_type  = append [res_type, 'none'];
	    res_chain = append [res_chain, ''];

	    substr_id = append [substr_id, 1 + max substr_id];
	    mdata.asubstr = put [mdata.asubstr, i, last substr_id];

	    mdata.nsubs = (nsubs = inc nsubs);
	endif

	    // sort the atoms by substructure (since they are not
	    // required to be sorted; we can safely permute the
	    // mol structure since there is only one residue

	mdata.asubstr = indexof [mdata.asubstr, substr_id];
	substr_id = x_id substr_id;

	local [idx, mask] = sam mdata.asubstr;
	if not ltE idx then
	    mol = mol_aPermute [mol, idx];
	    mdata.atype = mdata.atype[idx];
	endif
	mdata.asubstr = [];

	mol(3)(MOL_RES_NAME)	= res_name;
	mol(3)(MOL_RES_UID)	= res_uid;
	mol(3)(MOL_RES_INS)	= res_ins;
	mol(3)(MOL_RES_TYPE)	= res_type;
	mol(3)(MOL_RES_NATOMS)	= mtoc mask;

	    // subdivide the residues by chain and add in the names;
	    // we calculate chains by change in name

	mask = res_chain <> rotr res_chain;
	mask(1) = 1;

	local cname = rep [mdata.name, add mask];
	idx = x_pack (
		(res_chain|mask) <> '*'
	    and (res_chain|mask) <> ''
	    and not m_findmatch ['*.*', cname]
	);
	cname[idx] = tok_cat [cname[idx], '.', (res_chain|mask)[idx]];

	mol(2)(MOL_CHAIN_NAME)   = cname;
	mol(2)(MOL_CHAIN_HEADER) = rep [mdata.name, add mask];
	mol(2)(MOL_CHAIN_TAG)    = rep [mdata.name, add mask];
	mol(2)(MOL_CHAIN_NRES)   = mtoc mask;
    endfunction

	// PBC_Block reads the periodic boundary conditions block
	//	comment line
	//	version pbc_type				\\
	//	xmin ymin zmin xmax ymax zmax			\\
	//	solvent_type num_solvent_shells			\\
	//	reorient_molecule_flag status_flag		\\
	//	calc_electrostatics_flag			\\
	//	8_atom_id_numbers

    function PBC_Block []
	if not ReadBlockLine [] then return; endif
	if not ReadBlockLine [] then return; endif
	local argv = wordsplit [line, " \t\012\015"];
	local minpt = atof app token argv[[3,4,5]];
	local maxpt = atof app token argv[[6,7,8]];
	local dim = maxE [0, maxpt - minpt];
	local dummies = int app atof app token drop [argv, 13];
	if andE dim > 0 then
	    mdata.cell = ['P1', dim, [90,90,90]];
	    local mask = not indexof [ctab(1)(CTAB_A_NUM), dummies];
	    mol = mol_aMask [mol, mask];
	    mdata.atype = mdata.atype | mask;
	endif
    endfunction

    function PROPERTY_Block []
	while ReadBlockLine[] loop
	    if isnull line then continue; endif
	    local values = app token wordsplit [line, "|\t "];
	    mdata.pdata.(values(1)) =
		tok_drop [tok_cat tok_cat [dropfirst values, ' '], -1]
	    ;
	endloop
    endfunction

	// search for and read in the molecule data

    function NextSection []
	local eof = 0;
	while not (line(1) === "@") loop	// skip to next section
	until eof = not ReadLine [] endloop
	return not eof;
    endfunction

    mol = [];					// molecule to return
    NextSection [];

    if IsBlock MOLECULE_BLOCK then
	MoleculeBlock [];

	NextSection [];
	if IsBlock "@<TRIPOS>DICT" then ReadLine []; endif

	NextSection [];
	if not IsBlock ATOM_BLOCK then mdata.natoms = 0; endif
	AtomBlock [];

	NextSection [];
	if not IsBlock BOND_BLOCK then mdata.nbonds = 0; endif
	BondBlock [];

	NextSection [];
	if not IsBlock SUBSTRUCTURE_BLOCK then mdata.nsubs = 0; endif
	SubstructureBlock [];

	    // Check whether amino acids and/or nucleic acids have backbone
	    // atoms marked

	local num_atoms = add mol(3)(MOL_RES_NATOMS), r_tmp;
	local in_res    = split [igen num_atoms, mol(3)(MOL_RES_NATOMS)], i;
	local r_hold    = zero mol(4)(MOL_ATOM_BACKBONE);

	local r_ndx = x_pack indexof [mol(3)(MOL_RES_TYPE), 'amino'];
	for i in r_ndx loop
	    r_tmp = indexof [(mol_aName mol)[in_res(i)], AMINO_MAIN];
	    r_hold[in_res(i)] = notnot r_tmp;
	endloop

	r_ndx = x_pack indexof [mol(3)(MOL_RES_TYPE), cat ['rna', 'dna']];
	for i in r_ndx loop
	    r_tmp = indexof [(mol_aName mol)[in_res(i)], NUCLEIC_MAIN];
	    r_hold[in_res(i)] = notnot r_tmp;
	endloop

	    // Pass the input backbone settings back to the caller iff
	    // they're set and they differ from those determined above.
	    // Use the new values going forward.

	if anytrue mol(4)(MOL_ATOM_BACKBONE) then
	    if anyfalse (r_hold == mol(4)(MOL_ATOM_BACKBONE)) then
		mdata.mol2_backbone = mol(4)(MOL_ATOM_BACKBONE);
	    endif
	endif

	mol(4)(MOL_ATOM_BACKBONE) = r_hold;

	while NextSection[] loop
	    if IsBlock "@<TRIPOS>FF_PBC" then
		PBC_Block [];
		continue;
	    endif
	    if IsBlock "@<TRIPOS>PROPERTY_DATA" then
		PROPERTY_Block [];
		continue;
	    endif
	    if IsBlock MOLECULE_BLOCK then
		UnreadLine [];
		break;
	    endif
	until not ReadLine[] endloop
    endif

    fclose fnum;
    return [mol, unget_buff, mdata];
endfunction

// ImportTriposMOL2
// options - tagged vector of options as follows:
//	overwrite:  if set overwrite records starting at entry 1
//	file_field: if set then write file name in database field

global function ImportTriposMOL2 [mol_file, dst_file, mfield, options]
    local fnum = fopenrz mol_file;

    local append_flag = allfalse options.overwrite;
    local file_field  = anytrue options.file_field;

    local mdb = 0;			// 0 = read into MOE else into mdb
    local ent = 0;			// entry key (0 = append)

	// if we are importing into a database then open up the database
	// and make sure that there is a molecule field (otherwise create it)

    if not (dst_file === '' or dst_file === []) then
	mdb = db_Open dst_file;

	if mfield === '' or mfield === [] then
	    mfield = db_FirstFieldType [mdb, 'molecule'];
	endif

	if mfield === [] then
	    mfield = 'mol';
	endif

	if not (db_FieldType [mdb,mfield] === 'molecule') then
	    db_EnsureField [mdb, mfield, 'molecule'];
	endif

	if not append_flag then			// merging?
	    ent = db_NextEntry [mdb, 0];	// yes: get first entry
	endif

	if file_field then
	    db_EnsureField [mdb, '$File', 'char'];
	endif
    endif

    local mol, unget_buff = [];

    loop
	[mol, unget_buff] = fread_TriposMOL2 [fnum, unget_buff];
	if isnull mol then break; endif

	local data = [];
	data.(mfield) = mol;
	if file_field then
	    data.('$File') = swrite ['{}', mol_file];
	endif
	db_Write [mdb, ent, data];
	if ent then ent = db_NextEntry [mdb, ent]; endif
    endloop

    db_Close mdb;
    fclose fnum;
endfunction

// Wrapper function so we have a function name which stick to
// db_Import*** naming convention.

global function db_ImportMOL2 [mol_file, dst_file, mfield, options]
    if (dst_file === '' or dst_file === []) then
	exit 'There is no molecular database file specified.';
    endif
    return ImportTriposMOL2 [mol_file, dst_file, mfield, options];
endfunction

global function: ReadTriposMOL2 [filename,options]
    [filename,[],options] = Read_Prompt[filename,'tripos',options];

    local fnum = fopenrz filename;

    local ntotal = 0;
    local mol, unget_buff = [], mdata;
    local cell = [];

    local sys = SystemPush [];
    local msg = [];
    if not call[] then
	msg = Message [0, ''];
	filename = ftrimname [fenvname filename, 60];
    endif

    loop
	[mol, unget_buff, mdata] = fread_TriposMOL2 [fnum, unget_buff];
	if isnull mol then break; endif	// EOF
	mol_Create mol;
	ntotal = inc ntotal;
	if ntotal == 1 then
	    cell = mdata.cell;
	endif
	if (length msg and ntotal == 2) then
	    Message [msg, twrite [ 'Reading MOL2 file: {}', filename]];
	endif
    endloop

    if length msg and ntotal > 1 then
	if 'child' == second task_fork [title:'!ReadTriposMOL2',prio:0] then
	    sleep 2; // keep the message displayed for 2 sec min
	    exit[];
	endif
    endif

    local chains = _moe_Extract [Chains[]];
    SystemPop sys;
    chains = first _moe_Create [chains];

    if istrue cell(1) and ntotal == 1 and not CellEnable [] then
	CellEnable 0;
	CellLatticeReplicate [1, 1, 1];
	CellCoordinateMode 'normal';
	CellParameters cell;
	CellEnable 1;
    endif
    
    if not MOE_BATCH then
        RenderProtein [chains, [center:1]];
    endif

    if length msg then
	Message [msg, []];
    endif
    fclose fnum;

    return Read_Return [chains, call[]];
endfunction

// ================================ WRITING ===================================

// ChainNames calculates the chain names from a mol structure, looking
// at the MOL_CHAIN_NAME.  We'll extract the chain name suffix to
// preserve PDB naming conventions, or EMPTY if no suffix exists.

local function ChainNames mol
    local cname = resize [mol(2)(MOL_CHAIN_NAME), l_length mol(2)], i, n;

    for i = 1, length cname loop
	n	 = string cname(i);
	n	 = mput [n, isspace n, "_"];
	cname(i) = token cLetter token n;
    endloop

    (cname | isspace cname) = EMPTY;

	// Make sure that the chain names are uniq; for those that
	// are not, add in some numbers.  Don't change cname == EMPTY.

    local [idx, mask] = sam cname;
    cname = split [cname[idx], mtoc mask];

    for i in x_pack (app length cname > 1) loop
	if alltrue (cname(i) == EMPTY) then
	    cname(i) = tok_cat ['Q', totok x_id cname(i)];
	else
	    cname(i) = tok_cat [cname(i), totok x_id cname(i)];
	endif
    endloop

    cname = put [cname, idx, cat cname];

    return cname;
endfunction

// WriteTriposFromCTAB writes out a molecule from a CTAB structure and a
// possible mol structure (for proteins).  We believe whatever data is in
// the ctab structure - it is assumed that atom types and bond orders
// have been set to the correct tripos values.

const CTAB_BT_AM = inc CTAB_BT_ARO;		// am amide bond

local function WriteTriposFromCTAB [fnum, ctab, mol, extra_lines, pdata]

	// fix up the input in preparation for writing

    if orE (app length ctab(1) <> l_length ctab(1)) then
	ctab(1) = apt resize [ctab(1), l_length ctab(1)];
    endif
    if orE (app length ctab(2) <> l_length ctab(2)) then
	ctab(2) = apt resize [ctab(2), l_length ctab(2)];
    endif
    if orE (app length mol(2) <> l_length mol(2)) then
	mol(2) = apt resize [mol(2), l_length mol(2)];
    endif
    if orE (app length mol(3) <> l_length mol(3)) then
	mol(3) = apt resize [mol(3), l_length mol(3)];
    endif
    if orE (app length mol(4) <> l_length mol(4)) then
	mol(4) = apt resize [mol(4), l_length mol(4)];
    endif

	// extract the residue data from the tag-along mol structure.
	// if is null then we invent an empty one

    local molname = token mol(1)(MOL_NAME);

    if l_length mol(2) == 0 then
	mol(2)(MOL_CHAIN_NAME)   = '';
	mol(2)(MOL_CHAIN_HEADER) = '';
	mol(2)(MOL_CHAIN_TAG)    = '';
	mol(2)(MOL_CHAIN_NRES)   = 1;

	mol(3)(MOL_RES_NAME)   = '';
	mol(3)(MOL_RES_NATOMS) = l_length ctab(1);
	mol(3)(MOL_RES_TYPE)   = 'none';
	mol(3)(MOL_RES_UID)    = 1;
	mol(3)(MOL_RES_INS)    = " ";

	mol(4)(MOL_ATOM_NAME) = tok_cat [
	    mol(4)(MOL_ATOM_EL), totok x_id mol(4)(MOL_ATOM_EL)
	];
	mol(4)(MOL_ATOM_BACKBONE) = rep [0, l_length mol(4)];
    endif

    if molname == '' then
	if orE (mol(2)(MOL_CHAIN_TAG) <> '') then
	    molname = first diff [mol(2)(MOL_CHAIN_TAG), ''];
	elseif orE (mol(2)(MOL_CHAIN_NAME) <> '') then
	    molname = first diff [mol(2)(MOL_CHAIN_NAME), ''];
	elseif orE (mol(2)(MOL_CHAIN_HEADER) <> '') then
	    molname = first diff [mol(2)(MOL_CHAIN_HEADER), ''];
	endif
	if molname == '' then
	    molname = 'NONAME';
	endif
    endif

    local res_natoms = mol(3)(MOL_RES_NATOMS);
    local res_name   = mol(3)(MOL_RES_NAME);
    local res_type   = mol(3)(MOL_RES_TYPE);
    local res_id     = igen l_length mol(3);
    local res_class  = select [res_name, EMPTY,
	andE [res_name <> '', res_name <> '*']
    ];
    local res_chain  = stretch [ChainNames mol, mol(2)(MOL_CHAIN_NRES)];

	// Sybyl dislikes residues starting with a number - prefix Q.
	// If the residue name is '', change it to '<n>' where n is the
	// residue ID.

    local m = res_name == '', tname = tok_cat ['<', totok res_id, '>'];;
    res_name | m = tname | m;

    local idx = x_pack isdigit app first app string res_name;
    res_name[idx] = tok_cat ['Q', res_name[idx]];

	// Reflect the molecule being written out - small/large, etc.
	// Biopolymers use rUID's, small molecules do not.  Biopolymers
	// contain 1+ amino acid and/or nucleic acid.

    const AMINO   = ['amino', 'l-amino', 'd-amino'];
    const NUCLEIC = ['rna', 'dna'];

//  local prot_check = s_add [notnot indexof [res_type, AMINO],
//	mol(2)(MOL_CHAIN_NRES)
//  ];
//  local nucl_check = s_add [notnot indexof [res_type, NUCLEIC],
//	mol(2)(MOL_CHAIN_NRES)
//  ];

	// use dict_index = 4 (macromol) - avoid 0's

    local mol_type = 'SMALL', dict_index = 4, m2;
    local tr_res_type = rep ['GROUP', length res_name];

//  if anytrue ((prot_check > 4) or (nucl_check > 4)) then
    if anytrue indexof [res_type, cat [AMINO, NUCLEIC]] then
	mol_type = 'BIOPOLYMER';

	idx = x_pack andE [indexof [res_type, 'rna'],
	    tok_length res_name == 1, res_name <> '*'
	];
	res_class[idx] = tok_cat ['r', res_class[idx]];

	idx = x_pack andE [indexof [res_type, 'dna'],
	    tok_length res_name == 1, res_name <> '*'
	];
	res_class[idx] = tok_cat ['d', res_class[idx]];

	m  = indexof [res_type, cat [AMINO, NUCLEIC]];
	m2 = indexof [res_name, WATER_RES];
	m  = not (m or m2);
	res_class | m	    = EMPTY;
	tr_res_type | not m = 'RESIDUE';

    else
	res_class = rep [EMPTY, length res_name];
    endif

	// Add rUID's to output residue names for biopolymers.  Generate
	// them as needed to differentiate residues.  The following name
	// convention is used:
	//
	//	ALA, rUID=3:	ALA3
	//	ALA, rUID=-3:	ALA_3
	//	BC5, rUID=3:	BC5_3
	//	BC5, rUID=-3:	BC5__3

    if mol_type == 'BIOPOLYMER' then
	local r_id = mol(3)(MOL_RES_UID);

	    // Generate rUID's if ALL are zero

	if allfalse r_id then r_id = x_id r_id; endif

	if length (idx = x_pack (res_name <> '' and res_name <> '*')) then
	    local under_check = select ['_', '',
		isdigit app last app string res_name
	    ];
	    local minus_check = rep ['', length res_name];
	    minus_check[idx]  = select ['_', '', r_id[idx] < 0];

	    res_name[idx] = tok_cat [
		res_name[idx], under_check[idx], minus_check[idx],
		totok abs r_id[idx]
	    ];

	    idx = idx | mol(3)(MOL_RES_INS)[idx] <> " ";
	    res_name[idx] = tok_cat [
		res_name[idx], app token mol(3)(MOL_RES_INS)[idx]
	    ];
	endif
    endif

	// Collect unlabeled residues into <n> nomenclature

    if length (idx = x_pack (res_name == '' or res_name == '*')) then
	res_name[idx] = tok_cat ['<', totok res_id[idx], '>'];
    endif

	// extract some atom data

    local resnum = stretch [igen l_length mol(3), mol(3)(MOL_RES_NATOMS)];
    local backbone = mol(4)(MOL_ATOM_BACKBONE);
    local aname = mol(4)(MOL_ATOM_NAME);

    local res_alpha = backbone and (
	(
		stretch [indexof [res_type,AMINO], res_natoms]
	    and aname == 'CA'
	) or (
		stretch [indexof [res_type,NUCLEIC], res_natoms]
	    and aname == 'P'
	)
    );
    res_alpha = app first app pack split [
	select [x_id res_alpha, 0, res_alpha], res_natoms
    ];
    res_alpha | app isnull res_alpha = 0;

	// Use the heavy atom closest to the centroid of any residue not
	// already assigned a root atom.  If there are no heavy atoms,
	// use the first atom.  We assume the root is what the
	// fragment rotates/translates about...

    local first_atom = inc ((pscan res_natoms) - res_natoms);
    first_atom | (res_natoms == 0) = 0;

    local Z = el_Protons mol(4)(MOL_ATOM_EL);
    local i;
    for i in x_pack (res_alpha == 0) loop
	local ndx = x_pack ((resnum == i) and (Z > 1));
	if length ndx then
	    local respos = apt get [
		ctab(1)[[CTAB_A_X, CTAB_A_Y, CTAB_A_Z]], [ndx]
	    ];
	    local ctr    = app add respos / length ndx;
	    res_alpha(i) = ndx(x_min norm (respos - ctr));
	else
	    res_alpha(i) = first_atom(i);
	endif
    endloop

	// write the header data out to the file followed by the
	// atoms, bonds, substructures and sets

#if 0
    local rescount = select [0, length res_id,	// suppress substructures
	    andE (res_id == 1)
	and andE (res_name == '>')
    ];
#else
    local rescount = length res_id;
#endif

    fwrite [fnum, '@<TRIPOS>MOLECULE\n'];
    fwrite [fnum, '{}\n', first wordsplit [string molname, "\012\015"]];
    fwrite [fnum, '{} {} {} {} {} {}\n',
	l_length ctab(1),			// atom count
	l_length ctab(2),			// bond count
	rescount,				// substructure count
	0,					// feature count
	0					// set count
    ];

    local no_charges = (max abs ctab(1)(CTAB_A_CHARGE) < 0.00005);

    fwrite [fnum, '{}\n', mol_type];
    fwrite [fnum, '{}\n', select ['NO_CHARGES', 'USER_CHARGES', no_charges]];
    fwrite [fnum, '\n'];
    fwrite [fnum, '\n'];

	// write the atoms

    local atomfmt = twrite [
	'{{n:{}}'
	' {{t:-{}b}'
	' {{n:10.4f} {{n:10.4f} {{n:10.4f}'
	' {{t:-5b}'
	' {{n:{}}'
	' {{t:-{}b}'
	' {{n:8.4f}'
	' {{t:{}}'
	'\n',
	max [3, 1 + floor (log10 max [1, l_length ctab(1)])],
	max [4, max tok_length aname],
	1 + floor (log10 max [1, length res_id]),
	max [1, max tok_length res_name]
    ];

    fwrite [fnum, '@<TRIPOS>ATOM\n'];
    apt fwrite [fnum, atomfmt,
	igen l_length ctab(1),
	select [aname, '*', aname <> ''],
	ctab(1)(CTAB_A_X),
	ctab(1)(CTAB_A_Y),
	ctab(1)(CTAB_A_Z),
	ctab(1)(CTAB_A_SYM),
	stretch [res_id, res_natoms],
	stretch [res_name, res_natoms],
	ctab(1)(CTAB_A_CHARGE),
	select ['BACKBONE', '', backbone]
    ];

	// write the bonds block

    const BONDSYM = ['1','2','3','ar','am'];

    local bfrom = ctab(2)(CTAB_B_FROM);
    local bto   = ctab(2)(CTAB_B_TO);

    local bondorder = int round ctab(2)(CTAB_B_TYPE);

    bondorder[x_pack (bondorder <= 0)] = 1;
    bondorder[x_pack (bondorder >= 3 and bondorder < CTAB_BT_ARO)] = 3;

    idx = x_pack (bondorder >= CTAB_BT_ARO);
    bondorder[idx] = 4 + (bondorder[idx]-CTAB_BT_ARO);

    bondorder = minE [bondorder, length BONDSYM];

    local bondflags = ['','BACKBONE','INTERRES','BACKBONE|INTERRES'][ inc (
	      (backbone[bfrom] and backbone[bto])
	+ 2 * (resnum[bfrom] <> resnum[bto])
    )];

    local bondfmt = twrite [
	'{{n:{}} {{n:{}} {{n:{}}  {{t:-3} {{}\n',
	max [3, 1 + floor (log10 max [1, l_length ctab(2)])],
	max [3, 1 + floor (log10 max [1, l_length ctab(1)])],
	max [3, 1 + floor (log10 max [1, l_length ctab(1)])]
    ];

    fwrite [fnum, '@<TRIPOS>BOND\n'];
    apt fwrite [fnum, bondfmt,
	igen l_length ctab(2),			// bond number
	bfrom,					// bond source
	bto,					// bond destination
	BONDSYM[bondorder],			// bond order symbol
	bondflags				// bond flags
    ];

	// write out the substructures, turning any "<n>" residue names
	// into "****" - we assume < 9999 of them

    ndx		  = x_findmatch [['<#>', '<##>', '<###>', '<####>'], res_name];
    res_name[ndx] = EMPTY;

	// Determine the #interresidue bonds for each substructure and
	// write the corrected substructure records

    local n_off_res = zero igen rescount;
    ndx		    = x_pack (resnum[bfrom] <> resnum[bto]);
    n_off_res	    = putadd [n_off_res, resnum[bfrom[ndx]], 1];
    n_off_res	    = putadd [n_off_res, resnum[bto[ndx]], 1];

    if rescount > 0 then
	local subfmt = twrite [
	   '{{n:{}} {{t:-{}b} {{n:{}} {{t:-{}b} {} {{t:-{}b} {{t:-{}b}'
	   ' {{n:{}}\n',
	    max [3, 1 + floor (log10 max [1, max res_id])],
	    max [1, max tok_length res_name],
	    max [3, 1 + floor (log10 max [1, max res_alpha])],
	    max [1, max tok_length tr_res_type],
	    dict_index,
	    max [1, max tok_length res_chain],
	    max [1, max tok_length res_class],
	    max [1, 1 + floor (log10 max [1, max n_off_res])]
	];
	apt fwrite [fnum, '@<TRIPOS>SUBSTRUCTURE\n'];
	apt fwrite [fnum, subfmt,
	    res_id, res_name, res_alpha,
	    tr_res_type,
	    res_chain, res_class, n_off_res
	];
    endif

	// Dump all property data out.  Data is untyped, and formatted as:
	// "fieldname | fieldvalue".

    if notnull pdata then
	local [field_names, field_data] = untag pdata;

	    // Convert all white space in field names to "_".

	field_names = app string field_names;
	if length field_names then
	    field_names || apt m_join [field_names, [" \t\n|"]] = "_";
	endif

	    // Convert tab + newline in char fields to " ".

	local char_mask = app isflatchar field_data;
	local tmp = field_data | char_mask;
	if length tmp then
	    tmp || apt m_join [tmp, ["\t\n|"]] = " ";
	    field_data | char_mask = tmp;
	endif

	    // Enforce double precision on float fields.

	tmp = field_data | not char_mask;
	local int_mask = apt eqL [int tmp, tmp];
	if length tmp then
	    tmp | not int_mask = apt swrite ['{n:.15g}', tmp | not int_mask];
	    field_data | not char_mask = tmp;
	endif

	    // Finally output one field per line.

	fwrite [fnum, '@<TRIPOS>PROPERTY_DATA\n'];
	apt fwrite [fnum, '{}\t|\t{}\n', field_names, field_data];

	field_names = field_data = tmp = [];
    endif

	// write out the additional data

    if length extra_lines then
	apt fwrite [fnum, '{}\n', extra_lines];
    endif

    fwrite [fnum, '# MOE {n:.2f} (io_trps.svl {n:.2f})\n',
	MOE_VERSION, atof (modenv[]).version
    ];
endfunction

// AdjustCTAB adjusts a given CTAB structure so that it is in proper
// tripos form: atom types and bond orders.  WARNING! we assume that
// aromatic bonds have been set, otherwise no aromatic types will result
// Also, we assume that the HCOUNT field indicates any implicit H's

local function AdjustCTAB [ctab, mode]
    local i, j, idx, mask;

    local ion = resize [ctab(1)(CTAB_A_CHARGE), l_length ctab(1)];
    local el = resize [ctab(1)(CTAB_A_SYM), l_length ctab(1)];
    local impH = maxE [0, ctab(1)(CTAB_A_HCOUNT)];

    local bA = ctab(2)(CTAB_B_FROM), bB = ctab(2)(CTAB_B_TO);
    local [mol, [atno, bO]] = mol_ExtractFromCTAB ctab;

    ion = mol(4)(MOL_ATOM_ION);

    local nLP = putadd [putadd [zero ion, bA, el[bB]=='LP'], bB, el[bA]=='LP'];
    local hav = putadd [putadd [zero ion, bA, atno[bB]>1], bB, atno[bA]>1];

	// Calculate the number of neighbors for each atom, less the number
	// of explicit lone pairs - this was causing problems wrt #implicit
	// hydrogens

    local deg = putadd [putadd [zero ion, bA, one bB], bB, one bA];
    local xdeg = deg + impH - nLP;

	// extend the valence and then further extend the [N+][O-] pairs
	// where possible for further extended valence.  We only extend
	// up to a given capacity for each atom (aro bonds are 1.5)

    const ATOMINFO = [
	// row2 = bond order capacity, row3 = Pauling electronegativity
	['B',  'C',  'N',  'O',  'P',  'S',  'As',  'Se',  'Te' ],
	[ 4,    4,    5,    3,    6,    6,    6,     6,     6   ],
	[ 1.57, 2.55, 3.04, 3.44, 2.19, 2.58, 2.18,  2.55,  2.10]
    ];
    local aipos = indexof [el, ATOMINFO(1)];
    local eneg = (cat [0, ATOMINFO(3)])[inc aipos];

    const CAPACITY = [
	['B',  'C',  'N',  'O',  'P',  'S',  'As',  'Se',  'Te' ],
	[ 4,    4,    5,    3,    6,    6,    6,     6,     6   ]
    ];

    i = indexof [el, CAPACITY(1)];
    local cap = (mput [zero el, i, CAPACITY(2)[pack i]] - impH + nLP);

    local norder = select [1.5, bO, bO == CTAB_BT_ARO];
    local sumbo = putadd [putadd [zero ion, bA, norder], bB, norder] + impH;

    idx = x_pack (bO == 1 or bO == 2 and ion[bA] and ion[bB]);

    loop
	idx = idx | norder[idx] < 3;
	idx = idx | ion[bA[idx]] * ion[bB[idx]] < 0;
	idx = idx | (
	    sumbo[bA[idx]] < cap[bA[idx]] and sumbo[bB[idx]] < cap[bB[idx]]
	);
	if isnull idx then break; endif		// all done

	local w = 10 - abs (eneg[bA[idx]] - eneg[bB[idx]]);
	mask = graph_maxmatch [bA[idx], bB[idx], w];

	i = idx|mask;				// increase formal order
	bO[i] = inc bO[i];
	norder[i] = norder[i] + 1;

	j = bB[i];
	i = bA[i];

	sumbo[i] = sumbo[i] + 1;		// increase numerical order
	sumbo[j] = sumbo[j] + 1;
	ion[i] = int (ion[i] - sign ion[i]);	// merge charges
	ion[j] = int (ion[j] - sign ion[j]);
    endloop

    local effatno = atno - ion;			// effective atno

    sumbo = ceil sumbo;

	// determine the full list of aromatic bonds and then retain
	// only the six-ring aromatics
	// !!! CALCULATE FROM SCRATCH

    local arobond = (ctab(2)(CTAB_B_TYPE) == CTAB_BT_ARO);
    local aroatom = put [zero ion, cat ([bA,bB] || [arobond]), 1];

    idx = cat graph_scycle_list graph_uneighbors ([bA,bB] || [arobond]);
    idx = idx | app length idx == 6;
    [i,j] = [cat idx, cat app rotr idx];

    idx = pack indexof [
	minE[i ,j ] * l_length ctab(1) + maxE[i ,j ],
	minE[bA,bB] * l_length ctab(1) + maxE[bA,bB]
    ];

    bO[idx] = CTAB_BT_ARO;

	// locate [N+1]=[C+0] and convert to [N+0]-[C+1] (for NCN resonance)
	// locate [O+1]=[C+0] and convert to [O+1]-[C+1] for oxonium

    function AdjacentTo amask
	local adj = putadd [zero ion, bA | amask[bB], 1];
	return putadd [adj, bB | amask[bA], 1];
    endfunction

    function Carbocation [Amask, Bmask]
	local i = x_pack (
	    bO == 2 and (Amask[bA] and Bmask[bB] or Amask[bB] and Bmask[bA])
	);
	bO[i] = 1;
	ion[bA[i]] = select [1, 0, el[bA[i]] == 'C'];
	ion[bB[i]] = select [1, 0, el[bB[i]] == 'C'];
    endfunction

    local n2 = putadd [putadd [zero ion, bA, bO == 2], bB, bO == 2];

    Carbocation [
	(
		el == 'C' and ion == 0 and n2 == 1)
	    and AdjacentTo (el == 'N' and ion == 0 and not n2 and sumbo <= 3
	),
	(el == 'N' and ion == 1 and n2 == 1)
    ];

    Carbocation [
	el == 'C' and ion == 0 and n2 == 1,
	el == 'O' and ion == 1 and n2 == 1
    ];

	// Determine the bond types associated with each atom.

    local atype = el;
    local baro = (bO == CTAB_BT_ARO);

    local n1 = putadd [putadd [zero ion, bA, bO == 1], bB, bO == 1];
	  n2 = putadd [putadd [zero ion, bA, bO == 2], bB, bO == 2];
    local n3 = putadd [putadd [zero ion, bA, bO == 3], bB, bO == 3];
    local nA = putadd [putadd [zero ion, bA, baro   ], bB, baro   ];

    local n23 = n2 + n3;

    [idx, mask] = sam el;
    local tel = tag [el[idx]|mask, split [idx, mtoc mask]];

	// determine adjacency information used to determine conjugation
	// amCO : causes adj N.3 to become N.am (C=O, C=S, S=O)

    [i,j] = apt get [ [bA,bB], [x_pack (bO == 2)] ];

    local amCO = putadd [ zero ion, i,
	   (el[i] == 'C' and (el[j] == 'O' or el[j] == 'S'))
	or (el[i] == 'S' and el[j] == 'O')
    ];
    amCO = putadd [ amCO, j,
	   (el[j] == 'C' and (el[i] == 'O' or el[i] == 'S'))
	or (el[j] == 'S' and el[i] == 'O')
    ];

	// assign the preliminary atom types based upon the
	// formal bond orders

    function SetType [t, idx, mask]
	if not orE mask then return idx; endif
	atype[idx | mask] = t;
	return idx | not mask;
    endfunction

    if length (i = tel.C) then
	i = SetType ['C.3', i, xdeg[i] >= 4];				// CX4
	i = SetType ['C.1', i, xdeg[i] < 3 and (n2[i] > 1 or n3[i])];	// sp
	i = SetType ['C.1', i, ion[i] > 0 and n23[i]];			// =C+-
	i = SetType ['C.cat', i, ion[i] > 0 and not nA[i]];		// >C+-
	i = SetType ['C.3', i, not (n23[i] or nA[i])];			// sp3
	i = SetType ['C.ar', i, nA[i] >= 2];				// aro
	i = SetType ['C.2', i, n23[i]];					// sp2
	atype[i] = 'C.3';
    endif

    if length (i = tel.P) then
	atype[i] = 'P.3';
    endif

    if length (i = tel.S) then
	i = SetType ['S.o2', i, sumbo[i] >= 5 ];
	i = SetType ['S.o' , i, sumbo[i] >= 4 ];
	i = SetType ['S.3' , i, xdeg[i]  >= 4 ];
	i = SetType ['S.2' , i, n23[i]	      ];
	atype[i] = 'S.3';
    endif

    function InSmallRing I
	local xbond = mol(4)(MOL_ATOM_BONDS);
	local J, K, L;

	for J in xbond(I) loop
	    for K in diff [xbond(J),I] loop
		for L in diff [xbond(K),J] loop
		    if L == I then return 1; endif
		    if indexof [I, diff [xbond(L),[J,K]]] then return 1; endif
		endloop
	    endloop
	endloop

	return 0;
    endfunction

    if length (i = tel.N) then
	i = SetType ['N.4'  , i, xdeg[i] >= 4];
	i = SetType ['N.1'  , i, xdeg[i] <  3 and (n3[i] or n2[i] > 1)];

	if mode == 'gold' then
	    i = SetType ['N.pl3', i, aroatom[i] and xdeg[i] == 3];
	endif

	i = SetType ['N.ar' , i, nA[i] >= 2 ];
	i = SetType ['N.pl3', i, sumbo[i] >= 5];
	i = SetType ['N.pl3', i, aroatom[i] and xdeg[i] == 3];
	i = SetType ['N.2'  , i, n23[i]];

	if orE (mask = atype == 'C.cat' or (xdeg < 4 and effatno == 5)) then
	    i = SetType ['N.pl3', i, xdeg[i] == 3 and (AdjacentTo mask)[i]];
	endif
	if orE amCO then
	    i = SetType ['N.am', i, xdeg[i] == 3 and (AdjacentTo amCO)[i]];
	endif

	i = SetType ['N.3', i, app InSmallRing i];		// 3-4 rings

	mask = (xdeg < 4 and (n23 or nA or aroatom));		// "pi" atoms
	idx = AdjacentTo mask;					// conj count

	i = SetType ['N.3', i, not idx[i]];			// 0 conj
	i = SetType ['N.2', i, xdeg[i] < 3];			// D2 conj
	i = SetType ['N.pl3', i, hav[i] < 3];			// N.pl3H etc.
	i = SetType ['N.pl3', i, idx[i] > 1];			// 2 conj

	atype[i] = 'N.pl3';
    endif

    if length (i = tel.O) then
	i = SetType['O.2', i, n23[i] or nA[i]];
	atype[i] = 'O.3';
    endif

	// look for terminal oxygens that may require resonance with
	// double bonds and negative charges (carboxylate, etc.)
	// make the types O.co2 then set the bond orders to aro
	// Take the opportunity to patch NO2 if pentavalent N's not used

    mask = (xdeg == 1 and el == 'O' and ion <= 0);

    for i in x_pack (not n3 and AdjacentTo mask > 1) loop
	idx = x_pack (
	       bA == i and mask[bB]
	    or bB == i and mask[bA]
	);
	j = diff [cat [bA[idx], bB[idx]], i];
	j = j[x_sort ion[j]];				// <0 first
	if andE (ion[j] >= 0) then continue; endif	// all 0's

	if atype(i) == 'N.2' and n2(i) == 1 and ion(i) == 1 then
	    if length j == 2 then
		ion[append[j,i]] = 0;			// nitro
		atype(i) = 'N.pl3';
		atype[j] = 'O.2';
		bO[idx] = 2;
		continue;
	    endif
	    if length j == 3 and add ion[j] <= -2 then
		ion(first j) = 0;
		ion(i) = 0;
		atype(i) = 'N.pl3';
	    endif
	endif

	if ion(i) <> 0 then continue; endif

	ion[j] = (add ion[j] * invz length j);
	atype[j] = 'O.co2';
	bO[idx] = CTAB_BT_ARO;
    endloop

	// look for terminal sulfurs in the same way as O.co2 but
	// set the type to O.2 if there is such resonance

    mask = (xdeg == 1 and el == 'S' and ion <= 0);

    for i in x_pack (not n3 and AdjacentTo mask > 1) loop
	idx = x_pack (
	       bA == i and mask[bB]
	    or bB == i and mask[bA]
	);
	j = diff [cat [bA[idx], bB[idx]], i];
	if andE (ion[j] >= 0) then continue; endif	// all 0's
	if ion(i) <> 0 then continue; endif

	ion[j] = (add ion[j] * invz length j);
	atype[j] = 'S.2';
	bO[idx] = CTAB_BT_ARO;
    endloop

	// set the bond order of N.am to amCO atoms to "am"
	// set the bond order of N.pl3 to C.cat to "ar"

    mask = (						// N.am-C=O
	   atype[bA] == 'N.am' and amCO[bB]
	or atype[bB] == 'N.am' and amCO[bA]
    );
    (bO | mask) = CTAB_BT_AM;

    mask = (						// N.pl3-C.cat
	   atype[bA] == 'N.pl3' and atype[bB] == 'C.cat'
	or atype[bB] == 'N.pl3' and atype[bA] == 'C.cat'
    );
    (bO | mask) = CTAB_BT_ARO;

	// replace the updated ctab values and return the new data

    ctab(1)(CTAB_A_CHARGE) = ion;
    ctab(1)(CTAB_A_SYM) = atype;
    ctab(2)(CTAB_B_TYPE) = bO;

    return ctab;
endfunction

// WriteTriposMOL2 will write Tripos .mol2 (sybyl) files.  We write out
// each molecule (detected by connectivity).

local function write_molecule [fnum, atoms, mode, mol_name, pdata]
    local ctab = ctab_Extract [atoms, [
	aro:		1,
	xvalence:	0
    ]];

    local mol = mol_Extract atoms;		// for residue info
    if anytrue mol_name then
	mol(1)(MOL_NAME) = token mol_name;
    endif
    ctab = AdjustCTAB [ctab,mode];		// assign types, etc.

    if max abs mol(4)(MOL_ATOM_CHARGE) >= 0.00005 then
	ctab(1)(CTAB_A_CHARGE) = mol(4)(MOL_ATOM_CHARGE);
    endif

    WriteTriposFromCTAB [fnum, ctab, mol, mode, pdata];
endfunction

global function fwrite_TriposMOL2 [filename, mol_object, opt]
    local fh = fopenw filename;
    local mode = token opt.mode;    // write mode: e.g., 'gold'

	// Determine which atoms to write; we do not write empty residues.

    local atoms = uniq cat oAtoms cat mol_object;

	// Divide the atoms into groups, each group to be written to a
	// separate molecule area. The rules are:
	//  1) atoms in the same chain are in the same group.
	//  2) chains that share a non-null ('') tag are in the same group,
	//     unless opt.ignore tags is set.
	//  3) tags that share a molecule number are in the same group.
	//
	// Groups are to be written in cNumber (Sequence Editor) order.

    local [idx, seg] = sac cNumber aChain atoms;
    atoms = split [atoms[idx], seg];		    // 1) Split by chain.

	// mol_Extract assigns the first non-null chain tag to MOL_NAME,
	// otherwise it assigns the first non-null chain name.
	// We would prefer the chain name for single chain molecules.
	// [small molecule vs protein molecule issue]

    local mol_name = cName aChain app first atoms;

	// Build a neighbor list using tags and calculate connected components.

    if length atoms > 1 then
	local ctags   = cTag   aChain app first atoms;
	local ctagids = cTagId aChain app first atoms;
	local nlist = app x_pack (
	    ctagids == [ctagids] and ctags <> '' and isfalse opt.ignore_tags
	);

	idx = graph_ccomponent_list nlist;	    // 2) Join by tag.

	if length idx < length atoms then
	    idx = idx[x_sort app min idx]; // (necessary?)
	    seg = app length idx;
	    atoms = app cat split [atoms[idx = cat idx], seg];
	    mol_name = app uniq app cat split [mol_name[idx], seg];
	endif

	if length atoms > 1 then

	    // Build a neighbor list from molecule numbers and
	    // calculate connected components.

	    nlist = rep [[], length atoms];
	    local imol = app sortuniq aMoleculeNumber atoms;

	    local i, x = x_id atoms;
	    for i = 1, dec length x loop
		nlist(i) = i + x_pack app length apt join [
		    [imol(i)], imol[x = dropfirst x]
		];
	    endloop

	    idx = graph_ccomponent_list nlist;    // 3) Join by molecule.

	    if length idx <= length atoms then
		idx = idx[x_sort app min idx];	// (necessary?)
		seg = app length idx;
		atoms = app cat split [atoms[idx = cat idx], seg];
		mol_name = app uniq app cat split [mol_name[idx], seg];
	    endif
	endif
    endif

    [atoms, mol_name] = [atoms, mol_name] || [app length atoms];

	// Write out each of the atom groups. If the mol_name is '',
	// then mol_Extract in write_molecule will choose the MOL_NAME;
	// cTag, if non-null, else first non-null cName.

    mol_name = mol_name || mol_name <> '';
    mol_name | app length mol_name <> 1 = '';

    for i = 1, length atoms loop
	write_molecule [fh, atoms(i), mode, mol_name(i), opt.pdata];
    endloop

    if fh then fclose fh; endif
endfunction

global function: WriteTriposMOL2 [filename,options]
    [filename,[],options] = Write_Prompt[filename,'tripos',options];
    fwrite_TriposMOL2 [filename, Atoms [], options];
endfunction

// db_ExportTriposMOL2 exports a moe database to tripos format.
//
//	options
//	    .esel	selected entries only

global function db_ExportTriposMOL2 [db_file, mol2_file, fields, options]
    local mdb = db_Open db_file;
    local esel = anytrue options.esel and indexof [mdb, dbv_ViewKeys[]];
    local mode = token options.mode;
    local fnum, mfield = '';

	// make sure that our database contains the right exportable field
	// and then open the output file
    local [fldnames, fldtypes] = db_Fields mdb;

    if fields === [] or fields === '' then
	fields = fldnames;
    elseif allfalse (fldtypes == 'molecule') then
	exit 'Molecule field required for export.';
    else
	fldtypes = db_FieldType [mdb, fields];
	fldnames = fields;
    endif
    if add (fldtypes == 'molecule') > 1 then
	exit 'Multiple molecule fields available, select only one';
    endif
    mfield = fldnames | fldtypes == 'molecule';

    if type mol2_file === 'tok' then		// open output file
	fnum = fopenw mol2_file;
    else
	fnum = mol2_file;
    endif

	// run through the database and write the data to the file

    local psys = SystemPush [];

    local ent = 0;
    while (ent = db_NextEntry [mdb, ent]) loop
	if esel then
	    if not dbv_EntrySelect [mdb,ent] then continue; endif
	endif

	local pdata = tag [fldnames, db_ReadFields [mdb, ent, fields]];
	local mol = pdata.(mfield);
	pdata = pdata | tags pdata <> mfield;

	local chains = mol_Create mol;
	cSetName [chains | cName chains == '', mol(1)(MOL_NAME)];

	write_molecule [fnum, cat cAtoms chains, mode, mol(1)(MOL_NAME), pdata];
	oDestroy chains;
    endloop

    SystemPop psys;

    if type mol2_file === 'tok' then fclose fnum; endif
    db_Close mdb;
endfunction

// #eof

local function main []
//    const MDB = '$MOE/ff/mmff94-test/mdata.mdb';
    const MDB = 'mmff.mdb';
    local mdb = db_Open MDB;
    local mfield = db_RequireFieldType [mdb,'molecule'];
    local ent = 0, entnum = 0;
    local omdb;

    if omdb = dbv_Key 'io_trps.mdb' then
	db_Delete [omdb, db_Entries omdb];
    else
	omdb = db_Open ['io_trps.mdb', 'create'];
	db_EnsureField [omdb, 'mol', 'molecule'];
	db_EnsureField [omdb, 'mol2', 'molecule'];
	db_EnsureField [omdb, 'ok', 'int'];
	db_EnsureField [omdb, 'remark', 'char'];
	db_EnsureField [omdb, 'dIon', 'int'];
	db_EnsureField [omdb, 'dH', 'int'];
	dbv_Open db_Filename omdb;
    endif

    while ent = db_NextEntry [mdb, ent] loop
	entnum = inc entnum;
	local mol = first db_ReadFields [mdb, ent, mfield];

	local chains = mol_Create mol;
	local atoms = cat cAtoms chains;

	local f = fopen '';
	fwrite_TriposMOL2 [f, chains, []];
	fseek [f, 0];

	local [rmol, unget_buff] = fread_TriposMOL2 f;
	local tchains = mol_Create rmol;
	local tatoms = cat cAtoms tchains;

	local rem = [];

	local dIon = add aIon atoms - add aIon tatoms;
	local dH = add aHCount atoms - add aHCount tatoms;
	local ok = not dIon and not dH;

	db_Write [omdb, 0, [
	    mol:	mol,
	    mol2:	mol_Extract tchains,
	    ok:		ok,
	    dIon:	dIon,
	    dH:		dH,
	    remark:	rem
	]];

	oDestroy chains;
	oDestroy tchains;
    endloop

    fclose f;
    db_Close mdb;
endfunction

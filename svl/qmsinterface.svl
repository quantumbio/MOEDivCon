#svl

#set title   'QuantumBio QMScore Interface'
#set class   'QuantumBio'
#set version '2009.01'
#set main 'qb_QMScore'

/*  NOTE:  If you change the Key lists here, you need to update the
 *         Option lists and default indices in qmspanel.svl.
 */

const HAM_KEYS =
    [
    'AM1',
    'MNDO',
    'MNDOD',
    'PDDGPM3',
    'PM3',
    'PM6'
    ];

const LIG_KEYS =
    [
    'NOOPT',
    'LIGOPT',
    'COMPLEXOPT'
    ];

global function qb_QMScore [receptor_mols, ligand_mol, opts]

/*
local fp = fopenw '~daren/tmp/mols.txt';
fwrite [fp, 'Ligand:  {v}\n\n', ligand_mol];
fwrite [fp, 'Target:  {v}\n', receptor_mols];
return [[], "Test"];
fclose fp;
*/

local errmess = [];
local workdir;
local subdirname;
if opts.pwd === 1 then
    workdir = getenv 'PWD';
else
    workdir = opts.workdir;
endif

    write ['Work Dir:  {}\n', workdir];  //DEBUG

if opts.task === [] then
    subdirname = opts.workdir;
else
    subdirname = twrite ['{}/qb_out{n:}', opts.workdir, opts.task];
    local okay = _fmkdir subdirname;
    if okay === -1 then
        errmess = swrite ['Unable to create subdirectory:  {}',
            subdirname];
        return [[], errmess];
    endif
endif

//  Child process inherits parent's environment, which is defined in script
//  calling MOE.

local process_key = exe_open ['moedivconscoring', subdirname, [], 1];
local process_keys = [process_key];
local status = exe_status process_keys;

local prios = exe_getpriority process_keys;
exe_setpriority [process_keys, prios];

local stdin = exe_stdin process_keys;
local stdout = exe_stdout process_keys;

//  Pass the two backbones to QuantumBio's Divcon QMScore
//
//  SplitReceptor ensures that there is only one chain per molecule
//  in the receptor collection.

local retValue, success = 0;
local mol, molIndex, molCount, residueIndex, residueCount, atomIndex, atomCount;
molCount = length receptor_mols;
fwrite [stdin, '{c:}\n', HAM_KEYS(opts.ham)];
fwrite [stdin, '{c:}\n', select ['FREQ', 'NOFREQ', opts.freq]];
fwrite [stdin, '{c:}\n', LIG_KEYS(opts.opt)];
fwrite [stdin, '{n:}\n', molCount];

write ['{c:}\n', HAM_KEYS(opts.ham)];//DEBUG
write ['{c:}\n', select ['FREQ', 'NOFREQ', opts.freq]];//DEBUG
write ['{c:}\n', LIG_KEYS(opts.opt)];//DEBUG
write ['{n:}\n', molCount];//DEBUG

for molIndex = 1, molCount, 1 loop
    mol = receptor_mols(molIndex);
    atomIndex = 1;
    residueCount = mol(2)(MOL_CHAIN_NRES)(1);
    fwrite [stdin, '{n:}\n', residueCount];

    write ['{n:}\n', residueCount];//DEBUG

    for residueIndex = 1, residueCount, 1 loop
        atomCount = mol(3)(MOL_RES_NATOMS)(residueIndex);
        fwrite [stdin, '{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex),
            mol(3)(MOL_RES_UID)(residueIndex), atomCount];

        write ['{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex),//DEBUG
            mol(3)(MOL_RES_UID)(residueIndex), atomCount];//DEBUG

       for atomCount loop
            fwrite [stdin, '{c:} {c:} {n:.4f}\n',
                mol(4)(MOL_ATOM_NAME)(atomIndex),
                mol(4)(MOL_ATOM_EL)(atomIndex),
                mol(4)(MOL_ATOM_CHARGE)(atomIndex)];
            fwrite [stdin, '{n:.4f} {n:.4f} {n:.4f}\n',
                mol(4)(MOL_ATOM_X)(atomIndex),
                mol(4)(MOL_ATOM_Y)(atomIndex),
                mol(4)(MOL_ATOM_Z)(atomIndex)];

            write ['{c:} {c:} {n:.4f}\n',//DEBUG
                mol(4)(MOL_ATOM_NAME)(atomIndex),//DEBUG
                mol(4)(MOL_ATOM_EL)(atomIndex),//DEBUG
                mol(4)(MOL_ATOM_CHARGE)(atomIndex)];//DEBUG
            write ['{n:.4f} {n:.4f} {n:.4f}\n',//DEBUG
                mol(4)(MOL_ATOM_X)(atomIndex),//DEBUG
                mol(4)(MOL_ATOM_Y)(atomIndex),//DEBUG
                mol(4)(MOL_ATOM_Z)(atomIndex)];//DEBUG

            atomIndex = atomIndex + 1;
        endloop
    endloop
endloop

[retValue] = fread [stdout, '{n:}\n'];

//  There is only one molecule and one chain in the ligand/poses collection.
fwrite [stdin, '{n:}\n', 1];
mol = ligand_mol;
atomIndex = 1;
residueCount = mol(2)(MOL_CHAIN_NRES)(1);
fwrite [stdin, '{n:}\n', residueCount];
for residueIndex = 1, residueCount, 1 loop
    atomCount = mol(3)(MOL_RES_NATOMS)(residueIndex);
    fwrite [stdin, '{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex),
        mol(3)(MOL_RES_UID)(residueIndex), atomCount];
    for  atomCount loop
        fwrite [stdin, '{c:} {c:} {n:.4f}\n',
            mol(4)(MOL_ATOM_NAME)(atomIndex),
            mol(4)(MOL_ATOM_EL)(atomIndex),
            mol(4)(MOL_ATOM_CHARGE)(atomIndex)];
        fwrite [stdin, '{n:.4f} {n:.4f} {n:.4f}\n',
            mol(4)(MOL_ATOM_X)(atomIndex),
            mol(4)(MOL_ATOM_Y)(atomIndex),
            mol(4)(MOL_ATOM_Z)(atomIndex)];
        atomIndex = atomIndex + 1;
    endloop
endloop

[retValue] = fread [stdout, '{n:}\n'];

const NUMRESULTS = 11;
local results, return_statement;
local sleep_time = 0.05, sleep_inc = 0.05;
while exe_status process_key loop
    sleep sleep_time;
    sleep_time = min [1, sleep_time + sleep_inc];
    [[return_statement]] = fread [stdout, '{c:*}'];

    write ['Divcon: {}\n', return_statement];//DEBUG

    if return_statement === "updatescore" then
        local name, nameValue;
        local parameter, parameterValue;
        [[name]] = fread [stdout, '{c:*}'];
        [[nameValue]] = fread [stdout, '{c:*}'];
        results = cat [results, [[name, nameValue]]];
        for NUMRESULTS loop
            [[parameter]] = fread [stdout, '{c:*}'];
            [[parameterValue]] = fread [stdout, '{n:}'];
            results = cat [results, [[parameter, parameterValue]]];
        endloop
        success = 1;
        fwrite [stdin, '{c:}\n', 'Ok'];

    elseif return_statement === "QBException" then
        [[return_statement]] = fread [stdout, '{c:*}'];
        while neL [return_statement, "Divcon done."] loop
            errmess = cat [errmess, return_statement];
            [[return_statement]] = fread [stdout, '{c:*}'];
        endloop;
        fwrite [stdin, '{c:}\n', 'Ok'];
    endif
endloop

exe_kill  [process_key, 0];
exe_kill  process_key;
exe_close process_keys;

//  Clean up working directory.
local templist = flist [subdirname, 'MOE_AM1_*.dmx*'];
templist = cat [templist, flist [subdirname, 'MOE_AM1_*.out']];

local fname = twrite ['{}/fort.8', subdirname];
if ftype fname === 'file' then
    templist = cat [templist, fname];
endif

//fdelete templist;//DEBUG

if success === 1 then
    return [results, []];
else
    return [[], errmess];
endif
endfunction


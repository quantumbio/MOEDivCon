#svl

#set title   'QMScore Interface'
#set class   'QM'
#set version '2009.01'
#set main 'qms_Score'

const HAM_KEYS =
    [
    'AM1',
    'MNDO',
    'MNDOD',
    'MNDO_NMR',
    'PDDGPM3',
    'PM3',
    'PM6'
    ];

const LIG_KEYS =
    [
    'COMPLEXOPT',
    'LIGOPT',
    'NOOPT'
    ];

global function qms_Score [receptor_mols, ligand_mol, opts]

local subdirname;
if opts.task === [] then
    subdirname = opts.workdir;
else
    subdirname = twrite ['{}/qb_out{n:}', opts.workdir, opts.task];
    local okay = _fmkdir subdirname;
    if okay === -1 then 
        write ['Unable to create subdirectory:  {}', subdirname];
        return [];
    endif
endif

//  Child process inherits parent's environment, which is defined in script
//  calling MOE.

local process_key = exe_open ['moedivconscoring', subdirname, [], 1];
local process_keys = [process_key];
local status = exe_status process_keys;

local prios = exe_getpriority process_keys;
exe_setpriority [process_keys, prios];

local stdin = exe_stdin process_keys;
local stdout = exe_stdout process_keys;
//local stderr = exe_stderr process_keys;

//  Pass the two backbones to QuantumBio's Divcon QM Score
//
//  SplitReceptor ensures that there is only one chain per molecule
//  in the receptor collection.

local retValue;
local mol, molIndex, molCount, residueIndex, residueCount, atomIndex, atomCount;
molCount = length receptor_mols;
fwrite [stdin, '{c:}\n', HAM_KEYS(opts.ham)];
fwrite [stdin, '{c:}\n', select ['FREQ', 'NOFREQ', opts.freq]];
fwrite [stdin, '{c:}\n', LIG_KEYS(opts.opt)];

write ['{}\n', HAM_KEYS(opts.ham)];
write ['{}\n', select ['FREQ', 'NOFREQ', opts.freq]];
write ['{}\n', LIG_KEYS(opts.opt)];

fwrite [stdin, '{n:}\n', molCount];
for molIndex = 1, molCount, 1 loop
    mol = receptor_mols(molIndex);
    atomIndex = 1;
    residueCount = mol(2)(MOL_CHAIN_NRES)(1);
    fwrite [stdin, '{n:}\n', residueCount];
    for residueIndex = 1, residueCount, 1 loop
        atomCount = mol(3)(MOL_RES_NATOMS)(residueIndex);
        fwrite [stdin, '{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex),
            mol(3)(MOL_RES_UID)(residueIndex), atomCount];
        for atomCount loop
            fwrite [stdin, '{c:} {c:} {n:.4f}\n',
                mol(4)(MOL_ATOM_NAME)(atomIndex),
                mol(4)(MOL_ATOM_EL)(atomIndex),
                mol(4)(MOL_ATOM_CHARGE)(atomIndex)];
            fwrite [stdin, '{n:.4f} {n:.4f} {n:.4f}\n',
                mol(4)(MOL_ATOM_X)(atomIndex),
                mol(4)(MOL_ATOM_Y)(atomIndex),
                mol(4)(MOL_ATOM_Z)(atomIndex)];
            atomIndex = atomIndex + 1;
        endloop
    endloop
endloop

[retValue] = fread [stdout, '{n:}\n'];

//  There is only one molecule and one chain in the ligand/poses collection.
fwrite [stdin, '{n:}\n', 1];
mol = ligand_mol;
atomIndex = 1;
residueCount = mol(2)(MOL_CHAIN_NRES)(1);
fwrite [stdin, '{n:}\n', residueCount];
for residueIndex = 1, residueCount, 1 loop
    atomCount = mol(3)(MOL_RES_NATOMS)(residueIndex);
    fwrite [stdin, '{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex),
        mol(3)(MOL_RES_UID)(residueIndex), atomCount];
    for  atomCount loop
        fwrite [stdin, '{c:} {c:} {n:.4f}\n',
            mol(4)(MOL_ATOM_NAME)(atomIndex),
            mol(4)(MOL_ATOM_EL)(atomIndex),
            mol(4)(MOL_ATOM_CHARGE)(atomIndex)];
        fwrite [stdin, '{n:.4f} {n:.4f} {n:.4f}\n',
            mol(4)(MOL_ATOM_X)(atomIndex),
            mol(4)(MOL_ATOM_Y)(atomIndex),
            mol(4)(MOL_ATOM_Z)(atomIndex)];
        atomIndex = atomIndex + 1;
    endloop
endloop

[retValue] = fread [stdout, '{n:}\n'];

const NUMRESULTS = 11;
local results, return_statement;
local sleep_time = 0.05, sleep_inc = 0.05;
while exe_status process_key loop
    sleep sleep_time;
    sleep_time = min [1, sleep_time + sleep_inc];
    [[return_statement]] = fread [stdout, '{c:*}'];

    print return_statement;

    if return_statement === "updatescore" then
        local name, nameValue;
        local parameter, parameterValue;
        [[name]] = fread [stdout, '{c:*}'];
        [[nameValue]] = fread [stdout, '{c:*}'];
        results = cat [results, [[name, nameValue]]];
        for NUMRESULTS loop
            [[parameter]] = fread [stdout, '{c:*}'];
            [[parameterValue]] = fread [stdout, '{n:}'];
            results = cat [results, [[parameter, parameterValue]]];
        endloop
        fwrite [stdin, '{c:}\n', 'Ok'];
    endif
endloop

exe_kill  [process_key, 0];
exe_kill  process_key;
exe_close process_keys;

//  Clean up working directory.
local templist = flist [subdirname, 'MOE_AM1_*.dmx*'];
templist = cat [templist, flist [subdirname, 'MOE_AM1_*.out']];

local fname = twrite ['{}/fort.8', subdirname];
if ftype fname === 'file' then
    templist = cat [templist, fname];
endif

//fdelete templist;

return results;

endfunction


#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2009 QuantumBio Inc. and/or its affiliates.
	
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

#set title   'QuantumBio QMScore Interface'
#set class   'QuantumBio'
#set version '2009.01'
#set main 'qb_QMScore'

/*  NOTE:  If you change the Key lists here, you need to update the
 *         Option lists and default indices in qmspanel.svl.
 */

const HAM_KEYS =
    [
    'AM1',
    'MNDO',
    'MNDOD',
    'PDDGPM3',
    'PM3',
    'PM6'
    ];

const LIG_KEYS =
    [
    'NOOPT',
    'LIGOPT',
    'COMPLEXOPT'
    ];

global function qb_QMScore [receptor_mols, ligand_mol, opts]

local errmess = [];
local subdirname;
if opts.task === [] then
    subdirname = opts.workdir;
else
    subdirname = twrite ['{}/qb_out{n:}', opts.workdir, opts.task];
    local okay = _fmkdir subdirname;
    if okay === -1 then
        errmess = swrite ['Unable to create subdirectory:  {}',
            subdirname];
        return [[], errmess];
    endif
endif

//  exe_open child process inherits parent's environment.
local process_key = exe_open ['moedivconscoring', subdirname, [], 1];
local process_keys = [process_key];
local status = exe_status process_keys;

local prios = exe_getpriority process_keys;
exe_setpriority [process_keys, prios];

local stdin = exe_stdin process_keys;
local stdout = exe_stdout process_keys;

//  Pass the two backbones to QuantumBio's Divcon QMScore
//
//  SplitReceptor ensures that there is only one chain per molecule
//  in the receptor collection.

local retValue, success = 0;
local mol, molIndex, molCount, residueIndex, residueCount, atomIndex, atomCount;
molCount = length receptor_mols;
fwrite [stdin, '{c:}\n', HAM_KEYS(opts.ham)];
fwrite [stdin, '{c:}\n', select ['FREQ', 'NOFREQ', opts.freq]];
fwrite [stdin, '{c:}\n', LIG_KEYS(opts.opt)];
fwrite [stdin, '{n:}\n', molCount];
for molIndex = 1, molCount, 1 loop
    mol = receptor_mols(molIndex);
    atomIndex = 1;
    residueCount = mol(2)(MOL_CHAIN_NRES)(1);
    fwrite [stdin, '{n:}\n', residueCount];
    for residueIndex = 1, residueCount, 1 loop
        atomCount = mol(3)(MOL_RES_NATOMS)(residueIndex);
        fwrite [stdin, '{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex),
            mol(3)(MOL_RES_UID)(residueIndex), atomCount];
       for atomCount loop
            fwrite [stdin, '{c:} {c:} {n:.4f}\n',
                mol(4)(MOL_ATOM_NAME)(atomIndex),
                mol(4)(MOL_ATOM_EL)(atomIndex),
                mol(4)(MOL_ATOM_ION)(atomIndex)];
            fwrite [stdin, '{n:.4f} {n:.4f} {n:.4f}\n',
                mol(4)(MOL_ATOM_X)(atomIndex),
                mol(4)(MOL_ATOM_Y)(atomIndex),
                mol(4)(MOL_ATOM_Z)(atomIndex)];
            atomIndex = atomIndex + 1;
        endloop
    endloop
endloop

[retValue] = fread [stdout, '{n:}\n'];

//  There is only one molecule and one chain in the ligand/poses collection.
fwrite [stdin, '{n:}\n', 1];
mol = ligand_mol;
atomIndex = 1;
residueCount = mol(2)(MOL_CHAIN_NRES)(1);
fwrite [stdin, '{n:}\n', residueCount];
for residueIndex = 1, residueCount, 1 loop
    atomCount = mol(3)(MOL_RES_NATOMS)(residueIndex);
    fwrite [stdin, '{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex),
        mol(3)(MOL_RES_UID)(residueIndex), atomCount];
    for  atomCount loop
        fwrite [stdin, '{c:} {c:} {n:.4f}\n',
            mol(4)(MOL_ATOM_NAME)(atomIndex),
            mol(4)(MOL_ATOM_EL)(atomIndex),
            mol(4)(MOL_ATOM_ION)(atomIndex)];
        fwrite [stdin, '{n:.4f} {n:.4f} {n:.4f}\n',
            mol(4)(MOL_ATOM_X)(atomIndex),
            mol(4)(MOL_ATOM_Y)(atomIndex),
            mol(4)(MOL_ATOM_Z)(atomIndex)];
        atomIndex = atomIndex + 1;
    endloop
endloop

[retValue] = fread [stdout, '{n:}\n'];

const NUMRESULTS = 11;
local results, return_statement;
local sleep_time = 0.05, sleep_inc = 0.05;
while exe_status process_key loop
    sleep sleep_time;
    sleep_time = min [1, sleep_time + sleep_inc];
    [[return_statement]] = fread [stdout, '{c:*}'];

    write ['Divcon: {}\n', return_statement];//DEBUG

    if return_statement === "updatescore" then
        local name, nameValue;
        local parameter, parameterValue;
        [[name]] = fread [stdout, '{c:*}'];
        [[nameValue]] = fread [stdout, '{c:*}'];
        results = cat [results, [[name, nameValue]]];
        for NUMRESULTS loop
            [[parameter]] = fread [stdout, '{c:*}'];
            [[parameterValue]] = fread [stdout, '{n:}'];
            results = cat [results, [[parameter, parameterValue]]];
        endloop
        success = 1;
        fwrite [stdin, '{c:}\n', 'Ok'];

    elseif return_statement === "QBException" then
        [[return_statement]] = fread [stdout, '{c:*}'];
        while neL [return_statement, "Divcon done."] loop
            errmess = cat [errmess, return_statement];
            [[return_statement]] = fread [stdout, '{c:*}'];
        endloop;
        fwrite [stdin, '{c:}\n', 'Ok'];
    endif
endloop

exe_kill  [process_key, 0];
exe_kill  process_key;
exe_close process_keys;

//  Clean up working directory.
local templist = flist [subdirname, 'MOE_AM1_*.dmx*'];
templist = cat [templist, flist [subdirname, 'MOE_AM1_*.out']];

local fname = twrite ['{}/fort.8', subdirname];
if ftype fname === 'file' then
    templist = cat [templist, fname];
endif

//fdelete templist;//DEBUG

if success === 1 then
    return [results, []];
else
    return [[], errmess];
endif
endfunction


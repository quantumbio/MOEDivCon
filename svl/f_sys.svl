#svl
//	f_sys.svl	System File Types
//
//	17-oct-2012 (kk) Pass center opt to ReadPDB
//	11-oct-2012 (kk) Shortened some action descriptions
//	25-jun-2012 (hf) moved CellParameters call to io_pdb
//	23-mar-2012 (kk) Fixed FIELD_WIDTH logic Is_PDB
//	12-mar-2012 (kk) Fixed 'HEADER' check in Is_PDB
//	20-feb-2012 (al) SVLRun accepts file handle
//	17-feb-2012 (al) check for scalar tok filename in open_molecule
//	16-feb-2012 (hf) Fixed crash in SKC opener if file handle used
//	13-jan-2012 (kk) Fixed ATOM record recognition when all atom ids > 9999
//	14-dec-2011 (kk) Additional REMARK pattern for PDB ID
//	25-oct-2011 (kk) Restore alt_loc default to Ignore
//	11-oct-2011 (al) add HTML open
//	18-aug-2011 (kk) Looser pdb patterns (*.pdb); *.sdf.[gz,z] support
//	28-mar-2011 (kk) PDB GUI update
//	09-mar-2011 (kk) PDB multi_entry option (catenated PDB files)
//	03-mar-2011 (kk) task_call in open_mol now master:parent
//	28-jan-2011 (kk) Crystal Contacts etc in PDB GUI
//	19-nov-2010 (kk) Integrate Seqres & Show Alts: default on (in ReadPDB)
//	04-nov-2010 (kk) ImportFile: add CIF
//	08-oct-2010 (kk) Removed filename_tag [auto was always on anyway]
//	14-sep-2010 (kk) Open MACMOD & MAESTRO as multiple mol files (like mdl)
//	14-sep-2010 (kk) ImportFile: add MAESTRO; skip dbv_DefaultView
//	18-aug-2010 (hf) changed SKC open logic to allow superatoms to be built
//	02-jul-2010 (al) add .csv to ASCII
//	15-jun-2010 (al) add MOE and MDL MOL to ImportFile; unify button label
//	11-jun-2010 (kk) increase nchars for io_Is_TRIPOS to 2048
//	23-apr-2010 (kk) PDB ID check to exclude mmcifs
//	14-apr-2010 (hf) load sketch files into sketch viewer
//	25-jan-2010 (kk) Check ATOM/HETATM fields - broken by previous change
//	02-dec-2009 (kk) Additional REMARK pattern for PDB ID
//	18-sep-2009 (kk) [0-9]???.pdb pattern added
//	28-may-2009 (al) molecule append to db: create mol field if empty db
//	01-apr-2009 (al) change run to task_run in open_Op_SVLRun
//	25-mar-2009 (al) add 'openmol' for XTL files
//	17-mar-2009 (al) add 'openmol' for PDB files (for clipboard paste)
//	22-jan-2009 (kk) PDB open alternate location options
//	22-jan-2009 (kk) psilo*.pdb patterns prio 1
//	07-jan-2009 (al) do not overlap file exts in io_Is_PDB and MiscExt
//	07-jan-2009 (al) add .smi to MiscExtensionOnly
//  	30-sep-2008 (ac) changed SA/Report default directory
//	12-sep-2008 (ms) fixed arg for conf_ui.svl in open_Op_ImportConf
//	11-sep-2008 (al) added .pptx etc.
//	29-aug-2008 (kk) add maestro molecule file type
//	29-aug-2008 (kk) add option to use BIOMT transforms from a PDB file
//  	08-aug-2008 (ac) added open for SA/Report
//	09-jul-2008 (al) name patterns now case insensitive; bubbleHelp token
//	26-may-2008 (al) put PDB into MiscExtensionOnly to type ent.gz as pdb
//	21-may-2008 (al) set prio
//	13-may-2008 (al) add Misc patterns; use patterns, not extensions
//	22-apr-2008 (al) allow nchars==0
//	22-apr-2008 (al) fix warning for SD # molecules
//	15-apr-2008 (al) add dbimport of MDL MOL files, pdf type
//	07-aug-2007 (pl) allow open of SD files into MOE
//	13-jul-2007 (kk) Update PDB_Prompter
//	25-apr-2007 (kk) REMARK type identifier in Is_PDB (eg CNX)
//	19-dec-2006 (sb) no need to translate import file types for dbimport
//	03-nov-2006 (kk) Change PDB defaults
//	06-apr-2006 (kk) fix io_Is_PDB for fullcheck mode
//	08-mar-2006 (ac) added "view in database browser" to File/Open plugin
//	12-sep-2005 (al) add dummy 'bin' type
//	22-mar-2005 (pl) change task title for conformation import
//	28-jan-2005 (jd) assigned a default open operation to SD files (import)
//	27-oct-2004 (jd) added MDLSKC format to io_is_MDL
//	12-feb-2004 (al) fix io_Is_PDB for fullcheck mode
//	03-feb-2004 (al) run is default action for svl files instead of load
//	27-jan-2003 (m2) fixed bubblehelp
//	23-jan-2003 (m2) changed symmetries options to non_crys
//	20-jan-2003 (m2) cleaned up interface for Load PDB File
//	07-jan-2003 (m2) added defaults from RC and changed hoh&hetero interface
//	16-jan-2003 (pm) added macromodel import to databases
//	02-dec-2002 (kk) Symmetry option for ReadPDB
//	21-nov-2002 (pl) added macromodel
//	14-mar-2002 (pl) added Import Conformations for MOE and SDF
//	21-feb-2001 (kk) Added ignore_conect options to PDB
//	20-feb-2001 (ms) Fixed "Append to Database" for new MOE filetype
//	19-feb-2001 (kk) Added PDB type
//	14-feb-2001 (ms) Open MDB: kluge to "fix" windows/samba fperm bug
//	03-jan-2001 (pm) Import to Database: do each filetype separately
//	06-nov-2000 (pl) added forcefield file type
//	24-oct-2000 (al) options to open functions for future use
//	05-sep-2000 (al) created
//
// COPYRIGHT (C) 2000-2012 CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
//
// PERMISSION TO USE, COPY, MODIFY AND DISTRIBUTE THIS SOFTWARE IS HEREBY
// GRANTED PROVIDED THAT: (1) UNMODIFIED OR FUNCTIONALLY EQUIVALENT CODE
// DERIVED FROM THIS SOFTWARE MUST CONTAIN THIS NOTICE; (2) ALL CODE DERIVED
// FROM THIS SOFTWARE MUST ACKNOWLEDGE THE AUTHOR(S) AND INSTITUTION(S); (3)
// THE NAMES OF THE AUTHOR(S) AND INSTITUTION(S) NOT BE USED IN ADVERTISING
// OR PUBLICITY PERTAINING TO THE DISTRIBUTION OF THE SOFTWARE WITHOUT
// SPECIFIC, WRITTEN PRIOR PERMISSION; (4) ALL CODE DERIVED FROM THIS SOFTWARE
// BE EXECUTED WITH THE MOLECULAR OPERATING ENVIRONMENT (MOE) LICENSED FROM
// CHEMICAL COMPUTING GROUP INC.
//
// CHEMICAL COMPUTING GROUP INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
// AND IN NO EVENT SHALL CHEMICAL COMPUTING GROUP INC. BE LIABLE FOR ANY
// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
// RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
// CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
// CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#set title	'System Molecule and Database File Types'
#set class	'MOE:file-io'
#set version	'2012.10'

// ------------------------- io_Is_XXX FUNCTIONS -------------------------
//
// The naming convention io_Is_XXX must be followed; XXX is a unique suffix
//
// These functions are permitted to fail
// The calling function is io_WhatIs
//
// Each function performs one of three actions, depending on the argument:
//	A) returns the file type specification (null argument)
//		- this must be nested to allow multiple type specifications
//
//	B) performs file type verification/validation
//	    argument is [data, mode, type]:
//		mode: QUICKCHECK or FULLCHECK
//		data: prefix of the file, passed as a string
//		type: QUICKCHECK: suggested filetype
//		      FULLCHECK: []
//	    returns:
//		- a file type code token if the file type is recognized;
//		  the returned code must be one of those specified in
//		  the file type specification
//		- NOT_SURE if more data is needed to definitely accept/reject
//		- NOT_THIS_TYPE if file is recognized to be not of the type
//	   The function is not vectorized (operates on a single file at a time)
//
//	C) returns an information string (character vector)
//	    argument is [data, mode, filetype]:
//		mode: GIVEINFO
//		data: filename
//		filetype: file type token;
//		    the file has been identified to be of the expected type
//	   The function is not vectorized (operates on a single file at a time)
//
// Verification/validation:
// The role of the identifier function is to quickly identify
// whether or not a file is of the recognized type:
//
//	- for speed, two "modes" of identification are possible
//		(the mode to use is given by the caller):
//	    QUICKCHECK: the file has the correct extension so if the
//		contents do not contradict expectations, return positive id;
//		this is intended to be a quick'n'dirty check
//	    FULLCHECK : the file extension was unrecognized; do a more
//		thorough check on the contents
//	- the number of bytes required ("nchars" option) must be minimized
//	    for speed, and should be the number required for fast verification;
//	    this number is only used by the caller when the file extension
//	    is correct, and will be clipped if deemed too large
//	- the argument is either a file handle (number) or character string
//	    (the string is given either as lines or as a flat character vector)
//	    depending on the "readertype" option in the file type specification
//	- if the function returns NOT_SURE, it will be called again (one time)
//	    with more data (the amount of data is controlled by the caller)
//
// File type specification:
// Specify each file type with a function that returns the following table:
//
// [fcode, ext, options]
//	fcode: file type code token, this also appears in the panel
//	ext  : standard file extension(s) (tokens) as well as
//		name patterns containing wildcards: CASE-INSENSITIVE
//	options    : [readertype:val, nchars:nc, prio:n]
//	readertype : 'stream': (default) expects textchars (string)
//	             'line'  : expects textlines (strings)
//		     'bin'   : expects bytes
//		     'file'  : expects file number as argument
//	nchars     : suggested # of chars needed for identification
//		N.B. this should be the minimum number of characters to
//		verify whether this is NOT a file of this type
//	prio       : smaller # is checked first (def:10)
//
// ---------------------------- OPEN FUNCTIONS -----------------------------
//
// The naming convention open_Op_YYY must be followed; YYY is a unique suffix
//
// These functions are permitted to fail
// Some error-handling is done by the caller; specific errors must be
//	handled here
//
// The argument is of the form [fnames, fcodes, options]
//	fnames  : a list of filename tokens or a single filename token
//	    depending on whether the function accepts multiple files
//	fcodes	: for each fid, the file type token as specified in io_Is_XXX
//	options	: a tagged vector of options from the main open panel
//	    FOR FUTURE USE
// If the argument is [], then return an open operation specification table
//	whose entries are of the form:
//
// [fcode, opcode, opdesc, options]
//	fcode  : file type code token
//	opcode : open operation code token
//	opdesc : short descriptor token of open operation (appears in panel)
//		This is permitted to be '' (unspecified):
//		for shared opcodes, opdesc needs to be specified just once
//	options: optional (can be omitted)
//	    [defwin:winname, mult:flag, bubbleHelp:info_str]
//
//	    defwin: name of window in which the action is default (token)
//		set to 'default' to be the general default action
//		set to 'none' (default) if never the default action
//	    mult: 1: if opfcn accepts multiple files as argument
//	          0: (default) if opfcn accepts exactly 1 file as argument
//	    bubbleHelp: formatted information token (used to be string)
//		(appears in bubbleHelp)
//
// Called by:
//	io_GetOps (with null argument)
//	open_OpenFile (non-null argument; ignores the return values)

// ===========================================================================

// filetype fcodes

const
    MOE_MOL	= 'moe',
    MOEOLD	= 'moe_old',
    MDL_SKC	= 'mdl_skc',
    MDL_MOL	= 'mdl_mol',
    MDL_SDF	= 'mdl_sdf',
    MDL_RGF	= 'mdl_rgf',
    MDL_RXN	= 'mdl_rxn',
    MDL_RDF	= 'mdl_rdf',
    TRIPOS	= 'tripos',
    PDB_MOL	= 'pdb',
    XTL_MOL	= 'xtl',
    MOE_MDB	= 'moe_mdb',
    ASCII	= 'ascii',
    CIF		= 'cif',
    MACMOD	= 'macmod',
    MAESTRO	= 'maestro'
;

const HTML = 'html';

const
    NOT_SURE		= '',		// special io_Is_XXX return values
    NOT_THIS_TYPE	= '???'
;
const					// second argument to io_Is_XXX
    QUICKCHECK	= 0,
    FULLCHECK	= 1,
    GIVEINFO	= 2
;

const					// opcodes
    OPENMOL	= 'openmol',		// open molecule
    DBNEW	= 'dbnew',
    DBADD	= 'dbadd',
    DBIMPORT	= 'dbimport',
    OPENPDB	= 'openpdb'		// PDB has its own prompter
;

const GZIP_EXT =  ['gz','z','zip'];

// io_Is_MiscExtensionOnly identifies files by extension only (they will
// not work for cut and paste).  These are here to rapidly identify common
// files in people's directories.

global function io_Is_MiscExtensionOnly arg

    if arg === [] then
	const OPT = [ readertype: 'stream', nchars: 0 ];

	const PDB_PAT = cat tok_cat [
	    ['*.pdb', 'psilo*.ent', '[0-9]???.ent', 'pdb[0-9]???.ent'],
	    [cat ['', tok_cat ['.', GZIP_EXT]]]
	];
	const PDB_PATTERNS = [
	    PDB_MOL, PDB_PAT, [ readertype: 'stream', nchars: 0, prio: 1 ]
	];

	const SDF_EXT = tok_cat [ '*.sdf', cat ['', tok_cat ['.', GZIP_EXT]] ];
	const SDF_PATTERNS = [
	    MDL_SDF, SDF_EXT, [ readertype: 'stream', nchars: 0, prio: 1 ]
	];

	const MAE_EXT = cat tok_cat [
	    ['*.mae','*.qxp'], [ tok_cat ['.', GZIP_EXT] ]
	];
	const MAE_PATTERNS = [
	    MAESTRO, MAE_EXT, [ readertype: 'stream', nchars: 0, prio: 1 ]
	];

	const MMD_EXT = tok_cat ['*.mmd', tok_cat ['.', GZIP_EXT]];
	const MMD_PATTERNS = [
	    MACMOD, MMD_EXT, [ readertype: 'stream', nchars: 0, prio: 1 ]
	];

	return [
	    PDB_PATTERNS,
	    SDF_PATTERNS,
	    MAE_PATTERNS,
	    MMD_PATTERNS,
	    ['c',	'*.c',						OPT ],
	    ['f',	'*.f',						OPT ],
	    ['perl',	'*.pl',						OPT ],
	    ['sh',	'*.sh',						OPT ],
	    ['csh',	'*.csh',					OPT ],
	    ['awk',	'*.awk',					OPT ],
	    [HTML,	['*.htm','*.html'],				OPT ],
	    ['xml',	['*.xml','*.xsd'],				OPT ],
	    ['h',	['*.h','*.hpp'],				OPT ],
	    ['c++',	['*.c++','*.cpp','*.cc'],			OPT ],
	    ['obj',	['*.o','*.obj'],				OPT ],
	    ['exe',	'*.exe',					OPT ],
	    ['bat',	'*.bat',					OPT ],
	    ['com',	'*.com',					OPT ],
	    ['tar',	'*.tar',					OPT ],
	    ['lib',	['*.a','*.lib','*.dll'],			OPT ],
	    ['doc',	['*.doc','*.docx'],				OPT ],
	    ['gif',	'*.gif',					OPT ],
	    ['jpg',	['*.jpg','*.jpeg'],				OPT ],
	    ['png',	'*.png',					OPT ],
	    ['pdf',	'*.pdf',					OPT ],
	    ['ppt',	['*.ppt','*.pps','*.pptx','*.ppsx'],		OPT ],
	    ['excel',	['*.xls','*.xll','*.xlsx'],			OPT ],
	    [ ASCII,	['*.txt','*.smi','*.csv'],			OPT ],
	    ['log',	'*.log',					OPT ],
	    ['java',	['*.java','*.class','*.js','*.jsp','*.jar'],	OPT ],
	    ['bin',	['*.bin','*~','.*~'],				OPT ]
	];
    endif

    if arg(2) == 0 then		return arg(3);	// filetype
    elseif arg(2) == 1 then	return '???';	// not me!
    endif
endfunction

global function io_Is_ASCII arg
    if arg === [] then
	return [[ ASCII, [], [] ]];
    endif
    if arg(2) === 0 or arg(2) === 1 then	// quickcheck & fullcheck
	return '???';
    endif
endfunction

global function io_Is_HTML arg
    if arg === [] then
	return [[
	    HTML, ['*.html','*.htm'], [readertype:'line', nchars:500, prio: 1]
	]];
    endif

    if arg(2) == QUICKCHECK or arg(2) == FULLCHECK then
	const DOC_PATT = '<!DOCTYPE*';
	const HTML_PATT = '<html';

	local words = app token arg(1);
	if anytrue m_findmatch [[DOC_PATT, HTML_PATT], words] then
	    return HTML;
	endif
	return select [HTML, '???', arg(2) == 0];
    endif
endfunction

global function open_Op_HTML arg
    if arg === [] then
	return [[HTML, 'html_open', 'Open HTML File', [defwin:'default']]];
    endif
    LaunchDocument first arg;
endfunction

// ---------------------------- SVL FILE ID & OPS ----------------------------

const FTYPE_SVL = 'svl';

global function io_Is_SVL arg
    if arg === [] then
	return [[FTYPE_SVL, '*.svl', [readertype:'line', nchars:100, prio:1]]];
    endif

    if arg(2) == QUICKCHECK or arg(2) == FULLCHECK then
	const ID = "#svl";
	if keep [arg(1)(1), length ID] === ID then return FTYPE_SVL; endif
	return select [FTYPE_SVL, '???', arg(2) == 0];
    endif
endfunction

global function open_Op_SVLRun arg
    if arg === [] then
	return [[FTYPE_SVL, 'svl_run', 'Run SVL File', [defwin:'default']]];
    endif

    local fn = first arg;

    if isscalarnum fn then
	fn = freadb [fn, 'char', INT_MAX];
    endif

    task_run [fn, [], [master:'none', creator:'detach']];
endfunction

global function open_Op_SVLLoad arg
    if arg === [] then
	return [[FTYPE_SVL, 'svl_load', 'Load SVL File', []]];
    endif

    local fn = first arg;

    if isscalarnum fn then
	fn = freadb [fn, 'char', INT_MAX];
    endif

    load fn;
endfunction

// ------------------------- DATABASE OPEN FUNCTIONS -----------------------

global function open_Op_ImportFile arg
    const OPT = [
	defwin:'none',
	bubbleHelp:'Import into a MOE database.',
	mult:1
    ];
    const SD_OPT = [
	defwin:'default',
	bubbleHelp:'Import into a MOE database.',
	mult:1
    ];

    const IMPORT_LABEL = 'Import to Database';

    if arg === [] then
	return [
	    [ TRIPOS,	DBIMPORT, IMPORT_LABEL,	OPT   ],
	    [ MOE_MDB,	DBIMPORT, IMPORT_LABEL,	OPT   ],
	    [ MDL_SDF,	DBIMPORT, IMPORT_LABEL,	SD_OPT],
	    [ MDL_MOL,	DBIMPORT, IMPORT_LABEL,	OPT   ],
	    [ MDL_RGF,	DBIMPORT, IMPORT_LABEL,	OPT   ],
	    [ PDB_MOL,	DBIMPORT, IMPORT_LABEL,	OPT   ],
	    [ ASCII,	DBIMPORT, IMPORT_LABEL,	OPT   ],
	    [ CIF,	DBIMPORT, IMPORT_LABEL,	OPT   ],
	    [ MAESTRO,  DBIMPORT, IMPORT_LABEL,	OPT   ],
	    [ MACMOD,   DBIMPORT, IMPORT_LABEL,	OPT   ],
	    [ MOE_MOL,	DBIMPORT, IMPORT_LABEL, OPT   ]
	];
    endif

    local [fnames, fcodes, options] = arg;
    run ['dbimport.svl', [fcodes, fnames]];
endfunction

global function open_Op_ImportConf arg
    const OPT = [
	defwin:'none', bubbleHelp:'Database conformational search.', mult:1
    ];

    if arg === [] then
	return [
	    [ MOE_MDB,  'conf_importMDB',   'Import Conformations', OPT],
	    [ MDL_SDF,	'conf_importSD',    'Import Conformations', OPT]
	];
    endif

    local [name, fcode, options] = arg;
    if second task_fork [statics:'new'] === 'child' then
	task_settitle [-1, 'Conformation Import'];
	run [ 'conf_ui.svl', [name, []] ];	// ignore fcode and options
	exit[];
    endif
endfunction

// open_Op_MDB: fid is a single file identifier

global function open_Op_MDB arg
    if arg === [] then
	return [
	    [MOE_MDB, DBNEW, 'Database Viewer', [defwin:'default']]
	];
    endif

    local [name, fcode, options] = arg;
    local ecode = task_call [
	'dbv_OpenFile', [name, 0], [master:'parent', errmsg:'ignore']
    ];
    if second ecode === 'error' then
	dbv_OpenFile [name, 1];
    endif
endfunction

global function open_Op_ReadOnlyMDB arg
    if arg === [] then
	return [
	    [MOE_MDB, 'ReadOnlyMDB', 'Database Viewer (R/O)', []]
	];
    endif

    local [name, fcode, options] = arg;
    dbv_OpenFile [name,1];
endfunction

global function open_Op_BrowseMDB arg
    if arg === [] then
	return [
	    [MOE_MDB, 'BrowseMDB', 'Database Browser', []]
	];
    endif

    local [name, fcode, options] = arg;
    run ['dbbrowse.svl', name];
endfunction

global function open_Op_SAReport arg
    if arg === [] then
	return [
	    [MOE_MDB,	'SA/Report', 'SAReport', []],
	    [MDL_SDF,	'SA/Report', 'SAReport', []]
	];
    endif

    local [name, fcode, options] = arg;
    local curdir = twrite ['{}/sareport_html', fpath name];
    run ['sareport.svl', [name, curdir, [], []], 'SAReportUI'];
endfunction

// ------------------------- MOLECULE OPEN FUNCTIONS -----------------------

// open_Op_ReadFile: Read molecule file and create molecule in MOE
//	Returns: chain keys of newly-created molecules
//	(return value is needed by open_OpDBAdd)

function ReadPDB;

function fread_Maestro, fread_MacroModel;
function fread_XTL;
function mdl_fread_SDF;

function MDLSKC_CTABCreate;
function SketchPanel;
function qtab_IsQuery, qtab_ExpandSuperAtoms;

local function open_molecule [name, fcode, options]
    const FCN_TBL = tag tr [
	[MOE_MOL,	'fread_MOE'],
	[MOEOLD,	'ReadOldMOE'],
	[MDL_MOL,	'ReadMDLMOL'],
	[MDL_SKC,	'fread_MDLSKC'],
	[TRIPOS,	'ReadTriposMOL2'],
	[PDB_MOL,	'ReadPDB']
    ];

    if fcode == MDL_SDF or fcode == MAESTRO or fcode == MACMOD then
	local mol, mlist = [], ct = []; // ct => connection table for MAESTRO
	local fh = [], exe_key = [];

	if isscalartok name then
	    if indexof tolower [fext name, GZIP_EXT] then
		exe_key = exe_open_hidden tok_cat [
		    MOE, '/bin-', MOE_ARCH, '/gzip.exe -dc ',
		    '"', fabsname name, '"'
		];
		fh = exe_stdout exe_key;
	    else
		fh = fopenr name;
	    endif
	else
	    fh = fopenr name;
	endif

	const ULIMIT = 500;
	local upper_limit = ULIMIT;

	function NextMol []
	    if fcode == MDL_SDF then
		 return first mdl_fread_SDF fh;
	    elseif fcode == MACMOD then
		return fread_MacroModel fh;
	    elseif fcode == MAESTRO then
		return first fread_Maestro [fh, ct];
	    endif
	    return [];
	endfunction

	while length mlist < upper_limit
	while length (mol = NextMol[])
	loop
	    if allfalse options.quiet and length mlist == 10 then
		OKCancel
		    'Warning! There are more than 10 molecules to load.\n'
		    'Proceed?';
	    endif

	    mlist = append [mlist, mol];

	    if allfalse options.quiet and mod [length mlist, ULIMIT] == 0 then
		OKCancel twrite [
		    'Warning! {} molecules have been found.  Continue?',
		    length mlist
		];
		upper_limit = upper_limit + ULIMIT;
	    endif
	endloop

	if anytrue exe_key then
	    if exe_status exe_key then
		freadb [fh, 'line', INT_MAX];
	    endif
	    loop sleep 0.05; until not exe_status exe_key endloop
	    exe_close exe_key;
	endif

	fclose fh;

	if isnull mlist then return []; endif

	mlist = split [mlist, 100];
	local i;
	for i = 1, length mlist loop
	    mlist(i) = mol_Create mol_Cat mlist(i);
	endloop
	return cat mlist;
    endif

    if fcode == XTL_MOL then
	return mol_Create first fread_XTL name;
    endif

    if isnull FCN_TBL.(fcode) then
	write ['Open Error: Can\'t open file {} of type {}\n', name, fcode];
	return [];
    endif

    local result = task_call [
	FCN_TBL.(fcode), name, [master:'parent', errmsg:'ignore']
    ];
    if second result == 'error' then
	write ['Open Error {}: {}\n', name, first result];
	return [];
    endif

    local newchains = [];
    if fcode == MDL_SKC then
	if orE indexof [['molq', 'molq3d'], result(1)(2)] then
	    if qtab_IsQuery first qtab_ExpandSuperAtoms first result then
		local title = [];
		if isscalartok name then
		    title = ftail name;
		endif
		SketchPanel [result(1)(1), result(1)(2), title];
	    else
		MDLSKC_CTABCreate keep [first result, 2];
	    endif
	else
	    MDLSKC_CTABCreate keep [first result, 2];
	endif
    else
	newchains = first result;
    endif
    View [];

/*
	// !!! FUTURE USE
    if anytrue options.select then
	aSetSelected [cat oAtoms newchains, 1];
	rSetSelected [cat oChildren newchains, 1];	// residues
	cSetSelected [newchains, 1];
    endif
*/
    return newchains;
endfunction

global function open_Op_ReadFile arg
    const INFO_STR = 'Add molecule to current\nmolecular system.';
    const OPTIONS = [[ defwin:'default', mult:0, bubbleHelp:INFO_STR]];

    if isnull arg then
	local op = tr [
	    [MOEOLD, MDL_MOL, MDL_SKC, TRIPOS, MACMOD, MAESTRO],
	    OPENMOL, 'Open Molecule', OPTIONS
	];
	op = append [ op,
	    [MDL_SDF, OPENMOL, 'Open Molecule', [mult:0, bubbleHelp: INFO_STR]]
	];
	op = append [ op,
	    [PDB_MOL, OPENMOL, 'Open Molecule', [mult:0, bubbleHelp: INFO_STR]]
	];
	op = append [ op,
	    [XTL_MOL, OPENMOL, 'Open Molecule', [mult:0, bubbleHelp: INFO_STR]]
	];
	return op;
    endif
    return open_molecule arg;
endfunction

// open_Op_DBAdd: Append an entry to a MOE database

global function open_Op_DBAdd arg
    const OPT = [
	defwin: 'DatabaseViewer', mult:1,
	bubbleHelp: 'Create new entry in database.'
    ];
    if arg === [] then
	return [
	    [ MOE_MOL,	DBADD, 'Append to Database', OPT ],
	    [ MOEOLD,	DBADD, 'Append to Database', OPT ],
	    [ MDL_MOL,	DBADD, 'Append to Database', OPT ]
	];
    endif

    local [fnames, fcodes, options] = arg;

    local mdb = dbv_DefaultView[];
    if mdb === [] then return; endif

    if db_nEntries mdb == 0 then	// empty database, create a new field
	db_CreateField [mdb, 'mol', 'molecule'];
    endif
    local molfield = first db_RequireFieldType [mdb, 'molecule'];

    local psys = SystemPush[];
    local i;
    for i = 1, length fnames loop
	local chains = call ['open_Op_ReadFile', [fnames(i), fcodes(i)]];
	db_Write [mdb, 0, tag [molfield, [mol_Extract chains]]];
	oDestroy chains;

	const IMPORT_FMT = 'Open {}: Added entry to database {}\n';
	write [IMPORT_FMT, fnames(i), db_Filename mdb];
    endloop
    SystemPop psys;
endfunction

// -------------------------------- MDL FILES --------------------------------

global function io_Is_MDL arg
    if arg === [] then
	return [
	    [MDL_MOL, '*.mol', [readertype:'line', nchars:4*82, prio:1]],
	    [MDL_SDF, '*.sdf', [readertype:'line', nchars:400*82, prio:1]],
	    [MDL_RGF, '*.rgf', [readertype:'line', nchars:4*82, prio:3]],
	    [MDL_RXN, '*.rxn', [readertype:'line', nchars:4*82, prio:3]],
	    [MDL_RDF, '*.rdf', [readertype:'line', nchars:4*82, prio:3]]
	];
    endif

    if arg(2) == QUICKCHECK or arg(2) == FULLCHECK then
	local [lines, mode, filetype] = arg;

	const RDF_LINE1 = "$RDFILE", RDF_LINE2 = "$DATM";
	const RXN_LINE1 = "$RXN";
	const RGF_LINE1 = "$MDL", RGF_LINE2 = "$MOL", RGF_LINE3 = "$HDR";

	if      keep [lines(1), length RDF_LINE1] === RDF_LINE1
	    and keep [lines(2), length RDF_LINE2] === RDF_LINE2
	then
	    return MDL_RDF;
	endif

	if      keep [lines(1), length RXN_LINE1] === RXN_LINE1
	    and andE not isspace lines(2)
	then
	    return MDL_RXN;
	endif

	if      keep [lines(1), length RGF_LINE1] === RGF_LINE1
	    and keep [lines(2), length RGF_LINE2] === RGF_LINE2
	    and keep [lines(3), length RGF_LINE3] === RGF_LINE3
	then
	    return MDL_RGF;
	endif

	    // SD files and MOL files look exactly the same if only the
	    // first few characters are read.  The only difference is that
	    // SD files can have multiple molecules separated by $$$$
	    // and data items (lines starting with '>').  We make sure
	    // the the mol file looks reasonable and then go by extension.

	    // Check for multiple '$$$$' lines.

	local eomol = apt eqL [lines, ["$$$$"]];
	if add eomol > 1 then return MDL_SDF; endif

	const FMT = '[ 0-9][ 0-9][0-9]'		// aaa: #atoms
		    '[ 0-9][ 0-9][0-9]'		// bbb: #bonds
		    '[ 0-9][ 0-9][ 0-9]'	// lll: #atom lists
		    '[ 0-9][ 0-9][ 0-9]'	// fff: obsolete
		    '[ 0][ 0][ 01]'		// ccc: chiral flag
		    '[ 0-9][ 0-9][ 0-9]'	// sss:
		    '[ 0-9][ 0-9][ 0-9]'	// xxx:
		    '[ 0-9][ 0-9][ 0-9]'	// rrr:
		    '[ 0-9][ 0-9][ 0-9]'	// ppp:
		    '[ 0-9][ 0-9][ 0-9]'	// iii:
		    '[ 0-9][ 0-9][ 0-9]'	// mmm:
		    ' V[0-9][0-9][0-9][0-9]'	// version
	;
	if length lines(4) < 39 then return '???'; endif
	lines = keep [lines(4), 39];
	if not m_findmatch [FMT, token lines] then return '???'; endif

	return select [MDL_SDF, MDL_MOL, mode === 0 and filetype === MDL_SDF];
    endif
endfunction

global function io_Is_MDLSKC arg
    if arg === [] then
	return [
	    [MDL_SKC, '*.skc', [readertype:'bin', nchars:4, prio:3]]
	];

    elseif arg(2) == QUICKCHECK or arg(2) == FULLCHECK then
	const SKC_MAGIC_V4 = 0x04000301;
	const SKC_MAGIC_V3 = 0x03000301;

	local header = sreadb [arg(1), 'int', 1];
	if header === SKC_MAGIC_V4 or header === SKC_MAGIC_V3 then
	    return MDL_SKC;
	endif
	return '???';
    endif
endfunction

// ----------------------------- TRIPOS FILES ---------------------------------

global function io_Is_TRIPOS arg	// also a molecule file format
    const ID = "@<TRIPOS>MOLECULE";

    if arg === [] then
	return [
	    [TRIPOS, '*.mol2', [readertype:'line',nchars:2048,prio:1]]
	];
    endif

    local [data, mode, filetype] = arg;

    if mode == QUICKCHECK or mode == FULLCHECK then
	data = data | app length data;			// strip blank lines
	data = data | app first data <> "#";		// strip comments
	if isnull data then return '???'; endif
	return select [TRIPOS, '???', keep [first data, length ID] === ID];
    endif
endfunction

//------------------------------ PDB FILES -------------------------------------

global function io_Is_PDB arg
    if arg === [] then
	return [
	    [PDB_MOL, ['*.pdb','*.ent'], [readertype:'line',prio:1,nchars:2048]]
	];
    endif

    local [data, mode] = arg;

    if mode === GIVEINFO then
	return "Protein Data Bank file";
    endif

    const FIELD_WIDTH = 6;
    local fields = app token apt keep [data, FIELD_WIDTH];

    if length fields == 0 then
	return NOT_THIS_TYPE;
    endif

    const ACCEPT = ['COMPND', 'SEQRES', 'CRYST1', 'SEQADV', 'HETNAM'];
    const MAYBE  = [
	'TITLE ', 'SOURCE', 'KEYWDS', 'REMARK', 'EXPDTA', 'NUMMDL',
	'MDLTYP', 'AUTHOR', 'REVDAT', 'SPRSDE', 'JRNL  ', 'REMARK',
	'HELIX ', 'SHEET ', 'SSBOND', 'MODEL ',
	'ATOM  ' , 'HETATM'
    ];

    local retval = NOT_THIS_TYPE;

    local accept = indexof [fields, ACCEPT];
    local maybe  = indexof [fields, MAYBE];

    if anytrue accept then
	return PDB_MOL;
    elseif anytrue maybe then
	if first fields == 'HEADER' then
	    retval = PDB_MOL;
	else
	    retval = NOT_SURE;
	endif
    endif

    if mode == QUICKCHECK then return retval; endif

	// If no ACCEPT present, we still might be PDB. Check that first ATOM
	// line does not obviously conflict with PDB format.
	// _atom_s & _entry. checks exclude mmcif files.

    local l = first (data | indexof [fields, ['HETATM', 'ATOM  ']]);
    if length l >= 54 and not indexof ['_atom_s', fields] then
	if l(12) == " " and l(21) == " " then
	    l = keep [drop [l, 30], 35];
	    if orE isdigit l and
		andE m_join [l, "0123456789-. "] and 3 <= add (l == ".") then
		retval = PDB_MOL;
	    endif
	endif
    elseif not indexof ['_entry.', fields] then
	const REMARK_PATTERNS = [
	    'PDB *',			// xfit
	    'Written by CNX *',		// CNX
	    'PHENIX refinement*',	// PHENIX
	    'refinement resolution *',	// CNX
	    '  3 REFINEMENT*'
	];
	l = app token apt drop [(data | fields == 'REMARK'), FIELD_WIDTH+1];
	if orE m_findmatch [REMARK_PATTERNS, l] then retval = PDB_MOL; endif
    endif

    if retval <> PDB_MOL then retval = NOT_THIS_TYPE; endif
    return retval;
endfunction

const SYMMETRY_OPTIONS = [
  'None',
  'Asymmetric Unit',
  'Biomolecule',
  'Contacts (4.5)',
  'Contacts (10)',
  'Enable PBC'
];

const PDB_OPEN_WINDOW = [
    extendH: 1,
    Option: [
	name: 'symmetry_policy', title: 'Symmetry:',
	onTrigger: 'return',
	text : SYMMETRY_OPTIONS
    ],
    Pager: [
	name:'symmetry_help',
	flushLeft:1,
	Label:[text:
	    'Create only atoms with explicit coordinates. Update\n'
	    'the crystal parameters if the system is empty.'
	],
	Label:[text:
	    'Apply non-crystallographic transforms to create the\n'
	    'asymmetric unit. Update the crystal parameters.'
	],
	Label:[text:
	    'Apply BIOMT transforms (if any) to create the\n'
	    'biomolecule. Reset the crystal parameters and\n'
	    'disable the periodic system.'
	],
	Label:[text:
	    'Create symmetry-related atoms within 4.5A of the\n'
	    'asymmetric unit. Place clashes in the set\n'
	    '\'PDB_CrystalContacts\'. Reset the crystal parameters\n'
	    'and disable the periodic system.'
	],
	Label:[text:
	    'Create symmetry-related atoms within 10A of the\n'
	    'asymmetric unit. Place clashes in the set\n'
	    '\'PDB_CrystalContacts\'. Reset the crystal parameters\n'
	    'and disable the periodic system.'
	],
	Label:[text:
	    'Update the crystal parameters. Create the asymmetric\n'
	    'unit if necessary. Enable the periodic system.'
	]
    ],
    Hbox: [
	title: 'Load All:',
	Checkbox: [ name:'multi_model', text:'Models',
	    bubbleHelp:
		'If on, all models in multiple model files\n'
		'will be read into MOE. Each model will be\n'
		'assigned a distinct chain tag. If not on,\n'
		'then only the first model will be loaded.'

	],
	Checkbox: [ name:'multi_entry', text:'Entries',
	     bubbleHelp:
		'If on, all molecules in multiple entry\n'
		'("catenated") files will be read. Each\n'
		'entry will be assigned a distinct chain\n'
		'tag. If not on, then only the first entry\n'
		'will be loaded.'
	]
    ],
    Checkbox: [
	title: 'Sequence:',
        name:'collate_res', text:'Integrate SEQRES Records',
        bubbleHelp:
	    'If on, align amino and nucleic acid residues to\n'
	    'those in the corresponding SEQRES records\n'
	    '(if any) and create any implied empty residues\n'
	    'for display in the Sequence Editor.'
    ],
    Checkbox: [
	title: 'Connect:',
	name:'auto_connect', text:'Enable Auto-connect',
	bubbleHelp:
	    'If on, automatic bond detection will\n'
	    'be enabled. Standard residue bonding\n'
	    'and (if enabled) CONECT records are\n'
	    'always applied first.'
    ],
    Checkbox: [
        name:'ignore_conect', text:'Ignore CONECT Records',
        bubbleHelp:
	    'If on, CONECT records will not\n'
	    'be used in bond assignment.'
    ],
    Radio: [
	title: 'Alternates:',
        name:'altloc_policy', text:['Show', 'Hide', 'Ignore'],
	bubbleHelp:
	    'Specifies the treatment of alternate atom locations. If "Ignore"\n'
	    'is chosen, only the highest occupancy positions will be read\n'
	    'into MOE. Otherwise, all alternative positions will also'
		' be read.\n'
	    'Inert atoms will be created at these alternative positions, and\n'
	    'then collected into atom collections named PDB_ALTLOC_?,\n'
	    'where "?" is replaced by the alternate location character.\n'
	    'Choosing "Show" will display these inert atoms, otherwise\n'
	    'they will be hidden.'
    ],
    Hbox: [
	title: 'Ignore:',
	Checkbox: [
	    name:'ignore_hoh', text:'Waters',
	    bubbleHelp: 'If on, ignore water residues in the file.'
	],
	Checkbox: [
	    name:'ignore_hetero', text:'Hetero',
	    bubbleHelp: 'If on, ignore hetero residues in the file.'
	]
    ],
    Separator: [ extendH: 1, flushLeft: 1],
    Hbox: [
	title: 'New Chains:',
	Checkbox: [
	    name:'center', text:'Center Atoms',
	    bubbleHelp: 'If on, the atoms loaded from the file\n'
			'will be centered in the MOE Window.'
	],
	Checkbox: [
	    name:'select_new', text:'Select Chains',
	    bubbleHelp: 'If on, the chains loaded from the file will\n'
			'be selected in the MOE Sequence Editor.'
	]
    ],
    Checkbox: [
	name:'close_system', text:'Close Current System',
	bubbleHelp: 'If on, the current system will be closed\n'
		    'before the molecules are loaded.'
    ]
];

const PDB_OPEN_WIDGETS = [
    'center', 'select_new', 'close_system',
    'multi_model', 'multi_entry',
    'altloc_policy', 'symmetry_policy',
    'auto_connect', 'ignore_conect', 'collate_res',
    'ignore_hoh', 'ignore_hetero'
];

const PDB_READ_OPTIONS = [
    multi_model:	0,	// read all models in NMR (eg) files
    multi_entry:	1,	// read all entries in catenated PDB file
    collate_res:	1,	// align SEQRES to ATOMs
    altloc_policy:	'Ignore',
    auto_connect:	1,
    ignore_conect:	1,
    symmetry_policy:	'Enable PBC'
];

const PDB_OPEN_PROMPT = [
    title: 'Load PDB File',
    name: 'shell',
    text: ['OK', 'Cancel'],
    onTrigger: [ 'return', 'exit'],
    Vbox: PDB_OPEN_WINDOW
];

const PDB_OPEN_DEFAULTS = cat [
    PDB_READ_OPTIONS,
    [ close_system:0, center:1, select_new:0 ]
];

local function PDB_Prompter []
    local t, trigger, vals = [];
    for t in PDB_OPEN_WIDGETS loop
	vals.(t) = GetRCNumber cat [    // Someday, we will allow RC setting...
	    tok_cat ['PDB_read.open.', t], PDB_OPEN_DEFAULTS.(t), 0
	];
    endloop
    local wkey = WindowCreate PDB_OPEN_PROMPT;
    WindowSetData [wkey, vals];
    WindowShow wkey;
    loop
	[vals, trigger] = WindowWait wkey;
	if trigger == 'symmetry_policy' then
	    local i = indexof [vals.symmetry_policy, SYMMETRY_OPTIONS];
	    if i then
		WindowSetData [wkey, [symmetry_help:i]];
	    endif
	elseif trigger == 'shell' and vals.shell == 'OK' then
	    break;
	endif
    endloop
    WindowDestroy wkey;
    return vals;
endfunction

function ReadPDB;

global function open_Op_PDB_READ arg
    if isnull arg then
	return [[ PDB_MOL, OPENPDB, 'Load PDB File', [
	    defwin:'default', mult:1, bubbleHelp:'Load PDB file(s) into MOE.'
	]]];
    endif

    local opt = PDB_Prompter[];

    if opt.close_system === 1 then Close[force:1]; endif
    if nChains[] == 0 and isnull GKeyList[] then opt.view_new = 1; endif;

    opt.alt_loc = opt.altloc_policy <> 'Ignore';

    opt.crystal_contacts = opt.gen_symm =
    opt.biomol = opt.install_cryst = opt.cell_enable = 0;

    if  opt.symmetry_policy == 'None' then
	opt.install_cryst = 0 == nChains[];
    elseif  opt.symmetry_policy == 'Asymmetric Unit' then
	opt.gen_symm = opt.install_cryst = 1;
    elseif  opt.symmetry_policy == 'Biomolecule' then
	opt.biomol = 1;
    elseif  opt.symmetry_policy == 'Contacts (4.5)' then
	opt.crystal_contacts = 1;
	opt.crystal_contact_rad = 4.5;
    elseif  opt.symmetry_policy == 'Contacts (10)' then
	opt.crystal_contacts = 1;
	opt.crystal_contact_rad = 10;
    elseif opt.symmetry_policy == 'Enable PBC' then
	opt.gen_symm = opt.install_cryst = opt.cell_enable = 1;
    endif

    local filename, chains = [];
    for filename in first arg loop
	chains = cat [chains, ReadPDB [filename, opt]];
    endloop

    if opt.altloc_policy == 'Hide' then
	local atoms = cat cAtoms chains;
	aSetHidden [atoms, aInert atoms];
    endif

    if anytrue opt.select_new	then cSetSelected [chains, 1];	endif
    if anytrue opt.cell_enable and not anytrue opt.biomol then
	CellEnable 1;
    endif;
endfunction

// ------------------------------ QUASAR-CLASSIFY -----------------------------

const MOE_BCT = 'moe_bct';

global function io_Is_MOE_BCT arg
    if arg === [] then
	return nest [MOE_BCT, '*.bct', [readertype:'bin', nchars:4, prio:1]];
    elseif arg(2) == QUICKCHECK or arg(2) == FULLCHECK then
	const MAGIC = 0x020314;
	return select [MOE_BCT, '???', sreadb [arg(1), 'int4m', 1] === MAGIC ];
    endif
endfunction

global function open_Op_MOE_OpenBCT arg
    if arg === [] then
	return [[ MOE_BCT, 'moe_openbct', 'Edit BC Tree', [
	    defwin:'default',
	    bubbleHelp: 'Open QuaSAR-Classify panel with tree loaded.'
	]]];
    endif

    run ['qbct.svl', [treefile:arg(1)]];
endfunction

// -------------------------------- MOE MENUS ---------------------------------

// io_Is_MOE_Menu detects MOE menu files which are identified
// by the #moe:menu first line prefix.

const MOE_MENU = 'moe_menu';

global function io_Is_MOE_Menu arg
    const ID = "#moe:menu";

    if arg === [] then
	return nest [MOE_MENU, '*menu*', [
	    readertype:	'stream',
	    nchars:	length ID,
	    prio:	5
	]];
    elseif arg(2) == QUICKCHECK or arg(2) == FULLCHECK then
	return select [ MOE_MENU, '???', keep [arg(1), length ID] === ID ];
    endif
endfunction

// open_Op_LoadForcefield loads the force field via the file open system
// (fid is a single file identifier)

global function open_Op_LoadMenu arg
    if arg === [] then
	return [[MOE_MENU, 'load_menu', 'Load Menu File', [defwin:'default']]];
    endif
    ReadMenuFile first arg;		// arg = [name, fcode, options]
endfunction

// ----------------------------- MOE FORCEFIELD ------------------------------

// io_Is_MOE_ForceField detects MOE forcefield files which are identified
// by the #moe:forcefield first line prefix.

const MOE_FF = 'moe_ff';

global function io_Is_MOE_ForceField arg
    const ID = "#moe:forcefield";

    if arg === [] then
	return nest [MOE_FF, '*.ff', [
	    readertype:	'stream',
	    nchars:	length ID,
	    prio:	1
	]];
    elseif arg(2) == QUICKCHECK or arg(2) == FULLCHECK then
	return select [ MOE_FF, '???', keep [arg(1), length ID] === ID ];
    endif
endfunction

// open_Op_LoadForcefield loads the force field via the file open system
// (fid is a single file identifier)

global function open_Op_LoadForcefield arg
    if arg === [] then
	return nest [
	    MOE_FF, 'load_ff', 'Load Forcefield', [defwin:'default']
	];
    endif
    pot_Load first arg;			// arg = [name, fcode, options]
endfunction

#eof

#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

//    pwdpanel.svl    User-interface entrypoint to QB-PWD calculations

#set title   'QuantumBio PWD'
#set class   'QuantumBio'
#set version '2010.02'
#set main    'qb_QBPWDSetupPanel'

function grid_isoidx_emit;
function msurf_MolecularSurface;
function pboltz_AtomParameters;

function qb_CoreHandler;
function qb_GetCoreEnv;
function qb_GetCorePanel;
function qb_GetDefaultsCore;
function qb_GetDefaultsStatus;
function qb_GetEnvApp;
function qb_GetEnvTag;
function qb_GetPoseFields;
function qb_GetWhich;
function qb_InitCorePanel;
function qb_LoadCoreScoreDB;
function qb_SaveDivconStatus;
function qb_SetUpScoreDB;
function qb_SplitComplex;
function qb_TagCoreVals;
function qb_UpdateCorePanel;
function qb_VerifyDivcon;

function qb_HeatMapSetupPanel;

const MAT_TRANS_MIN = 0x80;

const QBPWD_OPT_DEFAULTS =
    [
    ['cutoff',       2.0           ],
    ['mapncolors',  15             ],
    ['mapnticks',    5             ]
    ];

const HEADER = 
    [
    name: 'panel', 
    title: 'QB-PWD',
    windowName: 'QB-PWDPanel',
    text: ['Run', 'Save', 'Load', 'Close'],
    onTrigger: ['validate', 'validate', 'return', 'return'],
    bubbleHelp: ['Execute QB-PWD from MOE Window.',
        'Save run parameters in database\n'
        'for later execution on cluster.', 
        'Load run parameters from a QB-PWD database.', 
        '']
    ];

const PANEL =
    [
    Vbox :
        [
        Hbox :
            [
            extendH: 1,
            Button :
                [
                name: 'heatmap', text: 'Heat Map', // onTrigger: 'validate',
                bubbleHelp:
                    ''
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Vbox :
                [
                Text :
                    [
                    name: 'cutoff', len: 7, extendH: 1, title: 'Cutoff:',
                    type: 'real', allowBlank: 0,
                    shortcut: ['1.0', '2.0', '3.0', '4.0', '5.0', '6.0'],
                    bubbleHelp: 'Number of standard deviations used to\n'
                        'calculate the minimum and maximum cutoffs.'
                    ]
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Vbox :
                [
                Text :
                    [
                    name: 'mapncolors', len: 7, extendH: 1, 
                    title: 'Number of Colors:',
                    type: 'int', allowBlank: 0,
                    shortcut: ['3', '7', '15', '31'],
                    bubbleHelp: 'Number of distinct colors.'
                    ],
                Text :
                    [
                    name: 'mapnticks', len: 7, extendH: 1, 
                    title: 'Number of Ticks:',
                    type: 'int', allowBlank: 0,
                    shortcut: ['3', '5', '7', '9'],
                    bubbleHelp: 'Number of labeled ticks on color scale.'
                    ]
                ]
            ]
        ],
    Separator : [flushLeft:1, extendH:1, margin:1]
    ];

//  Global Variables

    global G_surface;                     // Callback function needs access

//  Local Functions

/****************************************************************************
 *
 *                          BreakResidueNames
 *
 *  Insert a line break between the residue name and number for better
 *  formatting of heat map.
 *
 ****************************************************************************/
local function BreakResidueNames [names]
    local n, broken = [];
    for n in names loop
        broken = append [broken, cat [keep [n,3], "\n", drop [n,3]]];
    endloop
    return broken;
endfunction

/****************************************************************************
 *
 *                          CalcDist
 *
 *  Determine a distance that include all residues in heat map.
 *
 ****************************************************************************/
local function CalcDist [restokens, recatoms, ligatoms]

    local atom, dist = 10.0;
    for atom in recatoms loop
        local residue = aResidue atom;
        local restok = twrite ['{}\n{}', rName residue, rNumber residue];
        local idx = indexof [restok, restokens];
        if idx > 0 then
            dist = max append [aDist [atom, ligatoms], dist];
        endif
    endloop

    return dist;

endfunction

/****************************************************************************
 *
 *                          ClearSurfaceMap
 *
 *  Clear the surface map of the pocket.
 *
 *  Acknowledgement:  borrowed heavily from surfmap.svl.
 *
 ****************************************************************************/
local function ClearSurfaceMap [title]
    local gobjs = GKeyList [];
    GDestroy (gobjs | m_findmatch [tok_cat [title,'*'], GTitle gobjs]);

endfunction

/****************************************************************************
 *
 *                          ColorAtoms
 *
 *  Determine the color of the residue atoms based on its interaction with
 *  the ligand.  If ligidx is zero, return all white.
 *
 ****************************************************************************/
local function ColorAtoms [data, ligidx, residx, recatoms, 
        mincut, maxcut, colors]

write ['Rec len:  {}\n', length recatoms];//DEBUG

    if ligidx === 0 then
        return rep [0xFFFFFF, length recatoms];
    endif

    local step = (maxcut - mincut) / (length colors);
    local [restokens, rowdata] = data;
write ['ResTokens:  {}\n', restokens];//DEBUG
    local rowvals = second rowdata (ligidx);
    local atom, atomcolors = [];
    for atom in recatoms loop
        local residue = aResidue atom;
        local restok = twrite ['{}\n{}', rName residue, rNumber residue];
        local idx = indexof [restok, restokens];
//write ['Token:  {}, Idx: {}\n', restok, idx];//DEBUG
        if idx > 0 and (residx === 0 or residx === idx) then
            local cidx = ceil ((rowvals (idx) - mincut) / step);
            atomcolors = append [atomcolors, colors (cidx)];
        else
            atomcolors = append [atomcolors, 0xFFFFFF];  // White
        endif
    endloop

    return atomcolors;

endfunction

/****************************************************************************
 *
 *                          CreateSurfaceMap
 *
 *  Create a surface map of the pocket.
 *
 *  Acknowledgement:  borrowed heavily from surfmap.svl.
 *
 ****************************************************************************/
local function CreateSurfaceMap [restokens]

    const CLASS = 1;  // Connolly
    const RDIST = 10;

    local [recatoms, ligatoms, errmess] = qb_SplitComplex [];
    if recatoms === [] or ligatoms === [] then
        Warning errmess;
        return [];
    endif

print 'G_rectatoms set.';//DEBUG

    local dist = CalcDist [restokens, recatoms, ligatoms];

write ['Dist:  {}\n', dist];//DEBUG

    local [vdwR, vdwE] = pboltz_AtomParameters recatoms;
    local opt = [type: 'Connolly', probe_vdwR: 1.4000, spacing: 0.5, 
        clipmode: 0];

    G_surface =
        [
        title   : 'QB Heat Map',
        class   : CLASS,
        colorby : 'Constant',
        colconst: 0xFFFFFF,            // White
        surfdim : 3,
        trans_f : 96,
        trans_b : 96,
        rec     : recatoms,
        lig     : ligatoms,
        ligidx  : 0,
        ligmols : [],
        recpos  : aPos recatoms,
        ligpos  : aPos ligatoms,
        dist    : dist,
        rad     : vdwR,
        eps     : vdwE,
        opt     : opt,
        gvtx    : [],
        origidx : [],  
        gobj    : []
        ];

    G_surface.gvtx = msurf_MolecularSurface [G_surface.recpos, 
        G_surface.rad, G_surface.eps, G_surface.ligpos, G_surface.dist, 
        G_surface.opt];

    local [s_idx, s_color, s_vpt, s_vnorm] = G_surface.gvtx;
    G_surface.origidx = s_idx;
    s_idx = grid_isoidx_emit [s_idx, G_surface.surfdim, -1];
    G_surface.gvtx = poke [G_surface.gvtx, 1, s_idx];

    if add GKey G_surface.gobj then
        GSetTitle [G_surface.gobj, G_surface.title];
        G_surface.gobj = GCreateUnique G_surface.gobj;
    else
        G_surface.gobj = GCreateUnique G_surface.title;
    endif

    local trans = [G_surface.trans_f, G_surface.trans_b];
    GSetTransparency [G_surface.gobj, trans];
    local mat = peek [GMaterial 0, inc alltrue (trans >= MAT_TRANS_MIN)];
    GSetMaterial [G_surface.gobj, mat];
    GVertex [G_surface.gobj, G_surface.surfdim, s_idx, G_surface.colconst,
      s_vpt, s_vnorm];

    aSetNucleusLook [G_surface.lig, 'sphere'];
    View G_surface.lig;

endfunction

/****************************************************************************
 *
 *                          GenerateData
 *
 *  Return data formatted for the heat map.
 *
 ****************************************************************************/
local function GenerateData [pivot, numres, numlig]

    local resnames = [], ligdata = [];
    randseed 101;

    //  Residue labels
    const RESLIST = ['ARG', 'MET', 'THR', 'GLY', 'PHE', 'GLU', 'ALA', 'LEU',
        'LYS', 'PRO', 'VAL', 'SER', 'GLN', 'ASN', 'ASP'];

    local res_i, lig_i;
    for res_i = 1, numres, 1 loop
        resnames = append [resnames, twrite ['{}\n{}',
            RESLIST (mod [res_i, length resnames - 1] + 1), rand 999]];
    endloop

    //  ligand labels and values
    for lig_i = 1, numlig, 1 loop
        local ligname, ligvals = [];
        ligname = twrite ['lig{}', lig_i];
        for res_i = 1, numres, 1 loop
            ligvals = append [ligvals, randN pivot];
        endloop

        ligdata = append [ligdata, [ligname, ligvals]];
    endloop

    return [resnames, ligdata];
endfunction

/****************************************************************************
 *                          LoadDB
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
local function LoadDB [dbpath]

    local [dbkey, recset, ligand, status, coreopts, c, mess] = 
        qb_LoadCoreScoreDB [dbpath, 'qb-pwd'];
    if dbkey === 0 and status === [] and coreopts === [] then
        Warning mess;
        exit [];
    endif

    local pwdopts = qb_GetEnvApp [dbkey];
    pwdopts = tagcat [pwdopts, tag tr QBPWD_OPT_DEFAULTS];

    return [dbkey, recset, ligand, status, coreopts, pwdopts];

endfunction

/****************************************************************************
 *                          LoadLigs
 *
 *  Load the ligands from the PWD database.
 *
 *
 ****************************************************************************/
local function LoadLigs [pwdfilename]

    if MOE_BATCH then return []; endif

    if neL [ftype pwdfilename, 'file'] or neL [fext pwdfilename, 'mdb'] then
        Warning 'The PWD database doesn\'t exist.';
        exit [];
    endif



    local dbkey = db_Open [pwdfilename, 'read'];
    local ligmols = [];
    local rowkey = 0;
    local ligflds = qb_GetPoseFields [dbkey];

    while rowkey = db_NextEntry [dbkey, rowkey] loop
        local [ligmol, ligchg] = db_ReadFields [dbkey, rowkey, ligflds];
        ligmols = append [ligmols, ligmol];
    endloop

    G_surface.ligmols = ligmols;
    db_Close dbkey;


endfunction

/****************************************************************************
 *
 *                          NearestAtomColor
 *
 *  Computes the surface colors as the closest atom colors to the
 *  surface points (weighted by distance).
 *
 *  Local function copied from surfmap.svl (ask CCG to change it to global?).
 *  Note:  the atom colors are based on the interaction between its residue
 *  and the ligand.
 *
 ****************************************************************************/
local function NearestAtomColor [pos, rad, acolor, spos]
    const NAC_BUCKET_SIZE = 4.0;
    const NAC_MAX_POINTS  = 100000;

    const ALPHA = 2.5;
    local maxrad = max [1, max rad];
    local argb = bitand [0xFF, bitshr [[acolor],[16,8,0]]];
    local r = rep [0, l_length spos], g = r, b = r;
    local vsum = rep [0, l_length spos];

    // Do a proximity check to determine the minimum distance
    // that will associate a point with an atom.  NAC_BUCKET_SIZE
    // is the bin size for the search, and so the maximum distance
    // allowed.  We'll use at most NAC_MAX_POINT gridpoints for
    // the check.

    local pprox = prox_open [NAC_BUCKET_SIZE, pos, NAC_BUCKET_SIZE];
    local Upts;

    if length first spos > NAC_MAX_POINTS then
    Upts = apt keep [spos, NAC_MAX_POINTS];
    else
    Upts = spos;
    endif

    local [seg, idx, r2] = prox_find [pprox, Upts, 0];
    local d_ndx          = split [idx, seg];
    local min_dist       = max app min apt get [[r2], d_ndx];

    prox_close pprox;

    // Use the larger of the caller's and 'found' distances

    maxrad      = max [maxrad, sqrt min_dist - 1];
    local sprox = prox_open [1 + maxrad, spos, 1 + maxrad];

local f = fopenw '/tmp/pwddebug.txt';//DEBUG

    local i;
    for i = 1, l_length pos loop
    [seg, idx, r2] = prox_find [sprox, apt peek [pos, i], 0];
    if not length idx then continue; endif
    local w = exp (-ALPHA * maxE [0, sqrt r2 - 0.95 * rad(i)] );
    vsum[idx] = vsum[idx] + w;

fwrite [f, 'I {}, Idx {}, Len A {}, lLen A {}, Len R {}\n',i, last idx,
length argb, l_length argb, length r];//DEBUG

    r[idx] = r[idx] + w * argb(1)(i);
    g[idx] = g[idx] + w * argb(2)(i);
    b[idx] = b[idx] + w * argb(3)(i);
    endloop

fclose f;//DEBUG

    prox_close sprox;

    local vrgb = [r,g,b] * [invz vsum];
    vrgb = maxE [0, minE [0xFF, vrgb]];
    return bitor bitshl [vrgb,[16,8,0]];

endfunction

/****************************************************************************
 *
 *                          ReadData
 *
 *  Return data formatted for the heat map.
 *
 ****************************************************************************/
local function ReadData [filename]

    local f = fopenr filename;
    local lines = freadb [f, 'line', INT_MAX];
    local line = first lines;
    local m = line == ",";
    local strings = split [line | not m, dec mtoc prepend [m, 1]];
    strings = BreakResidueNames [strings];
    local resnames = app token strings;
    lines = dropfirst lines;

    //  ligand labels and values
    local ligdata = [];
    for line in lines loop
        m = line == ",";
        strings = split [line | not m, dec mtoc prepend [m, 1]];
        local ligname = token first strings;
        strings = dropfirst strings;
        local ligvals = atof app token strings;
        ligdata = append [ligdata, [ligname, ligvals]];
    endloop

    fclose f;

    return [resnames, ligdata];
endfunction

/****************************************************************************
 *
 *                          UpdateComplex
 *
 *  Replace the ligand in the MOE window with the given ligand.
 *
 ****************************************************************************/
local function UpdateComplex [lignum]

    if G_surface.ligidx === lignum then return; endif

    oDestroy G_surface.lig;
    local ligchn = mol_Create G_surface.ligmols (lignum);
    G_surface.lig = cat cAtoms ligchn;

    oSetCollection ['QB_LIGAND', G_surface.lig];
    G_surface.ligidx = lignum;

endfunction

//  Global Functions

/****************************************************************************
 *
 *                          qb_QBPWDSelectHandler
 *
 ****************************************************************************/
global function qb_QBPWDSelectHandler [data, selrow, selcol, mincut, maxcut,
        colors]
    
    ClearSurfaceMap G_surface.title;
    UpdateComplex selrow;
    local atomcolors = ColorAtoms [data, selrow, selcol, G_surface.rec, 
        mincut, maxcut, colors];

write ['recl: {}, posl: {}, rad: {}, acl: {}, gvtxl: {}, l_gvtx {}\n', 
length G_surface.rec, length G_surface.recpos,
length G_surface.rad, length atomcolors, length G_surface.gvtx(3),
l_length G_surface.gvtx(3)];//DEBUG

	local vcolor = NearestAtomColor [G_surface.recpos, G_surface.rad, atomcolors,
        G_surface.gvtx(3)];

    local [s_idx, s_color, s_vpt, s_vnorm] = G_surface.gvtx;
    if add GKey G_surface.gobj then
        GSetTitle [G_surface.gobj, G_surface.title];
        G_surface.gobj = GCreateUnique G_surface.gobj;
    else
        G_surface.gobj = GCreateUnique G_surface.title;
    endif

    local trans = [G_surface.trans_f, G_surface.trans_b];
    GSetTransparency [G_surface.gobj, trans];
    local mat = peek [GMaterial 0, inc alltrue (trans >= MAT_TRANS_MIN)];
    GSetMaterial [G_surface.gobj, mat];
    GVertex [G_surface.gobj, G_surface.surfdim, s_idx, vcolor,
      s_vpt, s_vnorm];

    aSetNucleusLook [G_surface.lig, 'sphere'];
    View G_surface.lig;

    if selrow === 0 and selcol === 0 then
        write ['Selected empty cell!\n'];//DEBUG
    elseif selrow === 0 then
        local resnames = first data;
        local str = string resnames (selcol);
        str = str | str <> "\n";
        write ['Selected residue: {}\n', str];//DEBUG
    elseif selcol === 0 then
        local row = second data;
        write ['Selected ligand: {}\n', first row (selrow)];//DEBUG
    else
        resnames = first data;
        str = string resnames (selcol);
        str = str | str <> "\n";

        row = second data;
        local rowvals = second row (selrow);
        write ['Selected ligand: {}, residue: {}, interaction: {}\n', 
            first row (selrow), str, rowvals (selcol)];//DEBUG
    endif
endfunction

/****************************************************************************
 *
 *                          qb_QBPWDSetupPanel
 *
 ****************************************************************************/
global function qb_QBPWDSetupPanel []

    const INITLIG = 1;
    const SIGNIFRES = 5;

    static status;                     //  Shared with child tasks.
    static pwdkey;
    static pwdfilename;

    if MOE_BATCH then return; endif
    if WindowShow ['QB-PWDPanel', 1] then return; endif

//    local data = GenerateData [2.5, 30, 40];
    local data = ReadData ['~daren/dev/MOEDivcon/heatmapdata3.csv'];

    local coreopts = [], pwdopts = [], browsetasks = [];
    status = qb_GetDefaultsStatus [];
    local coredflts = qb_GetDefaultsCore [];
    local appdflts = tag tr QBPWD_OPT_DEFAULTS;
    coredflts = tagpoke [coredflts, 'scoredb', 'qb_pwd.mdb'];

    local wkey = WindowCreate cat [HEADER, qb_GetCorePanel [], PANEL];
    status = qb_InitCorePanel [wkey, status, coredflts];
    pwdkey = 0;
    pwdfilename = '';
    G_surface = [];

    WindowSetData [wkey, appdflts];
    WindowShow [wkey, 1];

    loop
        local [vals, trig] = WindowWait wkey;

       if trig === 'panel' then
            if vals.panel === 'Close' then 
                break;

            elseif vals.panel === 'Load' then 
                if second task_fork [master: 'parent',
                        statics:'share'] === 'child' then
                    task_prio 0;

                    local dbpath = FilePrompt [title: 'Load Database', 
                        filter: '*.mdb', allowEmptyList: 0];
                    if not isnull dbpath then
                        local [ldkey, ldrec, ldlig, ldsts, ldcoreopts,
                            ldpwdopts] = LoadDB [dbpath];

                        if neL [ldcoreopts.mode, 'Many-to-Many'] then
                            Close [force:1];
                            if neL [ldrec, []] and neL [ldlig, []] then
                                local ldligmol = mol_Create ldlig;
                                local ldligatoms = cat oAtoms ldligmol;
                                oSetCollection ['QB_LIGAND', ldligatoms];
                                aSetNucleusLook [ldligatoms, 'small-sphere'];
                                aSetBondLook [ldligatoms, 'cylinder'];
                                mol_Create ldrec;
                                View [];
                            endif
                        endif

                        status = qb_UpdateCorePanel [wkey, ldsts, ldcoreopts];
                        pwdkey = ldkey;
                        pwdfilename = db_Filename pwdkey;
                        dbv_Open pwdfilename;
                        db_Close ldkey;
                        WindowSetData [wkey, ldpwdopts];
                    endif

                    exit [];
                endif

            elseif vals.panel === 'Run' then

                if second task_fork [statics:'share'] === 'child' then
/*
                    status = qb_VerifyDivcon [wkey, status, vals];
                    if not status.verified then exit []; endif

                    coreopts = qb_TagCoreVals [vals];
                    pwdopts = tag [first tr QBPWD_OPT_DEFAULTS, [
                        vals.cutoff, vals.mapncolors, vals.mapnticks]];
                    pwdkey = qb_SetUpScoreDB [status, coreopts, pwdopts, 
                        [], [/*fields*/], 'qb-pwd', 0];
                    pwdfilename = db_Filename pwdkey;

                    if vals.mode === 'One-to-One' then
                        RunCalc [pwdkey];
                    else
                        RunOneToManyCalc [pwdkey];
                    endif

                    dbv_Open db_Filename pwdkey;
                    db_Close pwdkey;
*/
                    exit [];
                else
                    break;
                endif

            elseif vals.panel === 'Save' then

                if second task_fork [statics:'share'] === 'child' then

                    status = qb_VerifyDivcon [wkey, status, vals];
                    if not status.verified then exit []; endif

                    coreopts = qb_TagCoreVals [vals];
                    pwdopts = tag [first tr QBPWD_OPT_DEFAULTS, [
                        vals.cutoff, vals.mapncolors, vals.mapnticks]];
                    pwdkey = qb_SetUpScoreDB [status, coreopts, pwdopts,
                        [], [/*fields*/], 'qb-pwd', 1];
                    pwdfilename = db_Filename pwdkey;
                    dbv_Open pwdfilename;
                    db_Close pwdkey;
                    exit [];
                endif
            endif

        elseif trig === 'heatmap' then

            if second task_fork [statics:'share', 
                    master:'parent'] === 'child' then

                if isnull G_surface then
                    local msgkey = Message [0, 'Calculating surface ...'];
                    CreateSurfaceMap [first data];
                    msgkey = Message [msgkey, ''];
                endif

                //  Make sure ligand atoms sets are loaded.
                if isnull G_surface.ligmols then
                    LoadLigs [pwdfilename];
                endif

                //  Make sure first ligand is in MOE Window
                UpdateComplex INITLIG;

                qb_HeatMapSetupPanel [data, vals.cutoff, SIGNIFRES, 
                    vals.mapncolors, vals.mapnticks, 
                    'qb_QBPWDSelectHandler', INITLIG];

                exit [];
            endif

        else
           [status, browsetasks] = qb_CoreHandler [wkey, trig, status, vals,
               browsetasks, pwdkey];
        endif
    endloop

    ClearSurfaceMap G_surface.title;
    G_surface = [];
    task_kill browsetasks;
    WindowDestroy wkey;

endfunction

#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

//    pwdpanel.svl    User-interface entrypoint to QB-PWD calculations

#set title   'QuantumBio PWD'
#set class   'QuantumBio'
#set version '2010.02'
#set main    'qb_QBPWDSetupPanel'

function grid_isoidx_emit;
function msurf_MolecularSurface;
function pboltz_AtomParameters;

function qb_CoreHandler;
function qb_GetCoreEnv;
function qb_GetCorePanel;
function qb_GetDefaultsCore;
function qb_GetDefaultsStatus;
function qb_GetEnvApp;
function qb_GetEnvTag;
function qb_GetPoseFields;
function qb_GetWhich;
function qb_InitCorePanel;
function qb_LoadCoreScoreDB;
function qb_SaveDivconStatus;
function qb_SetUpScoreDB;
function qb_SplitComplex;
function qb_TagCoreVals;
function qb_UpdateCorePanel;
function qb_VerifyDivcon;

function qb_HeatMapSetupPanel;

const MAT_TRANS_MIN = 0x80;

const QBPWD_OPT_DEFAULTS =
    [
    ['cutoff',       2.0           ],
    ['mapncolors',  15             ],
    ['mapmono',      1             ],
    ['mapnticks',    5             ]
    ];

const HEADER = 
    [
    name: 'panel', 
    title: 'QB-PWD',
    windowName: 'QB-PWDPanel',
    text: ['Load', 'Close'],
    onTrigger: ['return', 'return'],
    bubbleHelp: ['Load QB-PWD analysis results from a QMScore database.', 
            '']
    ];

const PANEL =
    [
    Vbox :
        [
        Hbox :
            [
            extendH: 1,
            Button :
                [
                name: 'heatmap', text: 'Heat Map',
                bubbleHelp:
                    ''
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Vbox :
                [
                Text :
                    [
                    name: 'cutoff', len: 7, extendH: 1, title: 'Cutoff:',
                    type: 'real', allowBlank: 0,
                    shortcut: ['1.0', '2.0', '3.0', '4.0', '5.0', '6.0'],
                    bubbleHelp: 'Number of standard deviations used to\n'
                        'calculate the minimum and maximum cutoffs.'
                    ]
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Vbox :
                [
                Hbox :
                    [
                    Text :
                        [
                        name: 'mapncolors', len: 7, extendH: 1, 
                        title: 'Number of Colors:',
                        type: 'int', allowBlank: 0,
                        shortcut: ['3', '7', '15', '31'],
                        bubbleHelp: 'Number of distinct colors.'
                        ],
                    Separator : 
                        [
                        vertical:0, shadow:'noline', extendH: 0, margin:1
                        ],
                    Checkbox :
                        [
                        name: 'mapmono', text: 'Monochrome',
                        bubbleHelp:
                            'Use a monochrome color scheme.'
                        ]
                    ],
                Text :
                    [
                    name: 'mapnticks', len: 7, extendH: 1, 
                    title: 'Number of Ticks:',
                    type: 'int', allowBlank: 0,
                    shortcut: ['3', '5', '7', '9'],
                    bubbleHelp: 'Number of labeled ticks on color scale.'
                    ]
                ]
            ]
        ],
    Separator : [flushLeft:1, extendH:1, margin:1]
    ];

//  Global Variables

    global G_surface;                     // Callback function needs access

//  Local Functions

/****************************************************************************
 *
 *                          CalcDist
 *
 *  Determine a distance that include all residues in heat map.
 *
 ****************************************************************************/
local function CalcDist [restokens, recatoms, ligatoms]

    local atom, dist = 10.0;
    for atom in recatoms loop
        local residue = aResidue atom;
        local restok = twrite ['{}{}', rName residue, rUID residue];
        local idx = indexof [restok, restokens];
        if idx > 0 then
            dist = max [max aDist [atom, ligatoms], dist];
        endif
    endloop

    return dist;

endfunction

function FindResidue;

/****************************************************************************
 *
 *                          CheckResidues
 *
 *  Check whether the residue names and numbers match those present
 *  in the receptor in the MOE Window.
 *
 *  Returns the list of residues tokens not found in the receptor.
 *
 ****************************************************************************/
local function CheckResidues [restoks]

    if MOE_BATCH then return restoks; endif

    local res, missing = [];
    for res in restoks loop
        local [residx, ra] = FindResidue res;
        if residx === 0 then
            missing = append [missing, res];
        endif
    endloop

    return missing;

endfunction

/****************************************************************************
 *
 *                          ClearSurfaceMap
 *
 *  Clear the surface map of the pocket and the residue label.
 *
 *  Acknowledgement:  borrowed heavily from surfmap.svl.
 *
 ****************************************************************************/
local function ClearSurfaceMap [title]

    local gobjs = GKeyList [];
    GDestroy (gobjs | m_findmatch [tok_cat [title,'*'], GTitle gobjs]);

endfunction

/****************************************************************************
 *
 *                          ColorAtoms
 *
 *  Determine the color of the residue atoms based on its interaction with
 *  the ligand.  If ligidx is zero, return all white.
 *
 ****************************************************************************/
local function ColorAtoms [data, ligidx, residx, recatoms, 
        mincut, maxcut, colors]

    if ligidx === 0 then
        return rep [0xFFFFFF, length recatoms];
    endif

    local step = (maxcut - mincut) / (length colors);
    local [restokens, resabbrevs, rowdata] = data;
    local rowvals = third rowdata (ligidx);
    local atom, atomcolors = [];
    for atom in recatoms loop
        local residue = aResidue atom;
        local restok = twrite ['{}{}', rName residue, rUID residue];
        local idx = indexof [restok, restokens];
        if idx > 0 and (residx === 0 or residx === idx) then
            local cidx, value = rowvals (idx);
            if value <= mincut then
                cidx = 1;
            elseif value >= maxcut then
                cidx = length colors;
            else
                cidx = ceil ((value - mincut) / step);
            endif

            atomcolors = append [atomcolors, colors (cidx)];
        else
            atomcolors = append [atomcolors, 0xFFFFFF];  // White
        endif
    endloop

    return atomcolors;

endfunction

/****************************************************************************
 *
 *                          CreateSurfaceMap
 *
 *  Create a surface map of the pocket.
 *
 *  Acknowledgement:  borrowed heavily from surfmap.svl.
 *
 ****************************************************************************/
local function CreateSurfaceMap [restokens]

    const CLASS = 1;  // Connolly
    const RDIST = 10;

    local [recatoms, ligatoms, errmess] = qb_SplitComplex [];
    if recatoms === [] or ligatoms === [] then
        Warning errmess;
        return [];
    endif

    local dist = CalcDist [restokens, recatoms, ligatoms];
    dist = dist / 2;
write ['Dist:  {}\n', dist];//DEBUG

    local [vdwR, vdwE] = pboltz_AtomParameters recatoms;
    local gridopt = [type: 'Connolly', probe_vdwR: 1.4000, spacing: 0.5, 
        clipmode: 0];

    G_surface =
        [
        title   : 'QB Heat Map',
        class   : CLASS,
        colorby : 'Constant',
        colconst: 0xFFFFFF,            // White
        surfdim : 3,
        trans_f : 96,
        trans_b : 96,
        rec     : recatoms,
        recpos  : aPos recatoms,
        lig     : ligatoms,
        ligpos  : aPos ligatoms,
        ligidx  : 0,
        ligmols : [],
        restok  : '',
        resatms : [],
        dist    : dist,
        rad     : vdwR,
        eps     : vdwE,
        gridopt : gridopt,
		fix     : 0,
        gvtx    : [],
        gobj    : []
        ];

    G_surface.gvtx = msurf_MolecularSurface [G_surface.recpos, 
        G_surface.rad, G_surface.eps, G_surface.ligpos, G_surface.dist, 
        G_surface.gridopt];

    local [s_idx, s_color, s_vpt, s_vnorm] = G_surface.gvtx;
    s_idx = grid_isoidx_emit [s_idx, G_surface.surfdim, -1];
    G_surface.gvtx = poke [G_surface.gvtx, 1, s_idx];

    if add GKey G_surface.gobj then
        GSetTitle [G_surface.gobj, G_surface.title];
        G_surface.gobj = GCreateUnique G_surface.gobj;
    else
        G_surface.gobj = GCreateUnique G_surface.title;
    endif

    local trans = [G_surface.trans_f, G_surface.trans_b];
    GSetTransparency [G_surface.gobj, trans];
    local mat = peek [GMaterial 0, inc alltrue (trans >= MAT_TRANS_MIN)];
    GSetMaterial [G_surface.gobj, mat];
    GVertex [G_surface.gobj, G_surface.surfdim, s_idx, G_surface.colconst,
      s_vpt, s_vnorm];

    aSetNucleusLook [G_surface.lig, 'sphere'];
    View G_surface.lig;

endfunction

/****************************************************************************
 *
 *                          FindResidue
 *
 *  Find the residue with the given name and number in the receptor 
 *  in the MOE Window.
 *
 *  Returns the index of the residue and its atom set.
 *
 ****************************************************************************/
local function FindResidue [restok]

    if MOE_BATCH then return [0, []]; endif

    local residx = 0, resatms = []; 
    local residues = Residues [];
    local resnames = rName residues;
    local rname = tok_keep [restok, 3];
    local [indices] = indicesof [rname, resnames];
    if length indices > 0 then
        local rnum = atoi tok_drop [restok, 3];
        local idx_i = indexof [rnum, rUID residues [indices]];
        if idx_i > 0 then
            residx = indices (idx_i);
            resatms = cat oChildren residues (residx);
        endif
    endif

    return [residx, resatms];

endfunction

/****************************************************************************
 *                          LoadDB
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
local function LoadDB [dbpath]

    local [dbkey, recset, ligand, status, coreopts, c, mess] = 
        qb_LoadCoreScoreDB [dbpath, 'qb-pwd'];
    if dbkey === 0 and status === [] and coreopts === [] then
        Warning mess;
        exit [];
    endif

    local pwdopts = qb_GetEnvApp [dbkey];
    pwdopts = tagcat [pwdopts, tag tr QBPWD_OPT_DEFAULTS];

    return [dbkey, recset, ligand, status, coreopts, pwdopts];

endfunction

/****************************************************************************
 *                          LoadLigs
 *
 *  Load the ligands from the PWD database.
 *
 *
 ****************************************************************************/
local function LoadLigs [pwdfilename]

    if MOE_BATCH then return []; endif

    if neL [ftype pwdfilename, 'file'] or neL [fext pwdfilename, 'mdb'] then
        Warning 'The PWD database doesn\'t exist.';
        exit [];
    endif

    local dbkey = db_Open [pwdfilename, 'read'];
    local ligmols = [];
    local rowkey = 0;
    local ligflds = qb_GetPoseFields [dbkey];

    while rowkey = db_NextEntry [dbkey, rowkey] loop
        local [ligmol, ligchg] = db_ReadFields [dbkey, rowkey, ligflds];
        ligmols = append [ligmols, ligmol];
    endloop

    G_surface.ligmols = ligmols;
    db_Close dbkey;

endfunction

/****************************************************************************
 *
 *                          NearestAtomColor
 *
 *  Computes the surface colors as the closest atom colors to the
 *  surface points (weighted by distance).
 *
 *  Local function copied from surfmap.svl (ask CCG to change it to global?).
 *  Note:  the atom colors are based on the interaction between its residue
 *  and the ligand.
 *
 ****************************************************************************/
local function NearestAtomColor [pos, rad, acolor, spos]
    const NAC_BUCKET_SIZE = 4.0;
    const NAC_MAX_POINTS  = 100000;

    const ALPHA = 2.5;
    local maxrad = max [1, max rad];
    local argb = bitand [0xFF, bitshr [[acolor],[16,8,0]]];
    local r = rep [0, l_length spos], g = r, b = r;
    local vsum = rep [0, l_length spos];

    // Do a proximity check to determine the minimum distance
    // that will associate a point with an atom.  NAC_BUCKET_SIZE
    // is the bin size for the search, and so the maximum distance
    // allowed.  We'll use at most NAC_MAX_POINT gridpoints for
    // the check.

    local pprox = prox_open [NAC_BUCKET_SIZE, pos, NAC_BUCKET_SIZE];
    local Upts;

    if length first spos > NAC_MAX_POINTS then
    Upts = apt keep [spos, NAC_MAX_POINTS];
    else
    Upts = spos;
    endif

    local [seg, idx, r2] = prox_find [pprox, Upts, 0];
    local d_ndx = split [idx, seg];
    local min_dist = max app min apt get [[r2], d_ndx];

    prox_close pprox;

    // Use the larger of the caller's and 'found' distances

    maxrad = max [maxrad, sqrt min_dist - 1];
    local sprox = prox_open [1 + maxrad, spos, 1 + maxrad];
    local i;
    for i = 1, l_length pos loop
    [seg, idx, r2] = prox_find [sprox, apt peek [pos, i], 0];
    if not length idx then continue; endif
    local w = exp (-ALPHA * maxE [0, sqrt r2 - 0.95 * rad(i)] );
    vsum[idx] = vsum[idx] + w;
    r[idx] = r[idx] + w * argb(1)(i);
    g[idx] = g[idx] + w * argb(2)(i);
    b[idx] = b[idx] + w * argb(3)(i);
    endloop

    prox_close sprox;

    local vrgb = [r,g,b] * [invz vsum];
    vrgb = maxE [0, minE [0xFF, vrgb]];
    return bitor bitshl [vrgb,[16,8,0]];

endfunction

/****************************************************************************
 *
 *                          ReadData
 *
 *  Return data formatted for the heat map.
 *
 ****************************************************************************/
local function ReadData [filename]

    //TODO:  change to use fieldsplit
    local f = fopenr filename;
    local lines = freadb [f, 'line', INT_MAX];
    local line = first lines;
    local m = line == ",";
    local strings = split [line | not m, dec mtoc prepend [m, 1]];
    local resnames = app token strings;
    lines = dropfirst lines;

    //  ligand labels and values
    local ligdata = [];
    for line in lines loop
        m = line == ",";
        strings = split [line | not m, dec mtoc prepend [m, 1]];
        local ligname = token first strings;
        strings = dropfirst strings;
        local ligvals = atof app token strings;
        ligdata = append [ligdata, [ligname, ligvals]];
    endloop

    fclose f;

    return [resnames, ligdata];
endfunction

/****************************************************************************
 *
 *                          UpdateComplex
 *
 *  Replace the ligand in the MOE window with the given ligand.
 *
 ****************************************************************************/
local function UpdateComplex [lignum]

    if G_surface.ligidx === lignum then return; endif
    if length G_surface.lig === 0 then return; endif

    local lignuc = aNucleusLook G_surface.lig (1);
    oDestroy uniq oChains G_surface.lig;
    local ligchn = mol_Create G_surface.ligmols (lignum);

    G_surface.lig = cat cAtoms ligchn;
    G_surface.ligidx = lignum;

    oSetCollection ['QB_LIGAND', G_surface.lig];
    aSetNucleusLook [G_surface.lig, lignuc];

endfunction

/****************************************************************************
 *
 *                          UpdateResidue
 *
 *  Name highlight, and shift the view towards the selected residue.
 *
 *  Acknowledgement:  labeling the residue was borrowed from LabelResidue
 *                    in menu.svl.
 *
 ****************************************************************************/
local function UpdateResidue [restok, row, col, zoom]

    if col === 0 then
        aSetLabelRes [G_surface.resatms, 0];
        G_surface.resatms = [];
        G_surface.restok = '';
        return;
    endif

    if G_surface.restok === restok and row > 0 then return; endif

    aSetLabelRes [G_surface.resatms, 0];

    local [residx, resatms] = FindResidue restok;
    if residx === 0 then return; endif

    G_surface.restok = restok;
    G_surface.resatms = resatms;

	local [idx, m] = sam graph_ccomponent BondGraph resatms;
    local aa;
	for aa in split [resatms [idx], mtoc m] loop
	    aSetLabelRes [sample [aa | graph_center BondGraph aa, 1], 1];
	endloop

    if zoom then
        View resatms;
    endif

endfunction

//  Global Functions

/****************************************************************************
 *
 *                          qb_QBPWDSelectHandler
 *
 ****************************************************************************/
global function qb_QBPWDSelectHandler [data, selrow, selcol, mincut, maxcut,
        colors]
    
    local [resnames, resabbrevs, rowdata] = data;
    local restok = '', ligtok = '', ligabbrev = '', ligdata = [];
    if selrow === 0 and selcol === 0 then
        return;
    elseif selrow === 0 then
        restok = resnames (selcol);
        if selcol > 0 then
            UpdateResidue [restok, selrow, selcol, 1];
            return;
        endif
    elseif selcol === 0 then
        [ligtok, ligabbrev, ligdata] = rowdata (selrow);
    else
        restok = resnames (selcol);
        [ligtok, ligabbrev, ligdata] = rowdata (selrow);
    endif

    ClearSurfaceMap G_surface.title;
    UpdateComplex selrow;
    local atomcolors = ColorAtoms [data, selrow, selcol, G_surface.rec, 
        mincut, maxcut, colors];

	local vcolor = NearestAtomColor [G_surface.recpos, G_surface.rad,
        atomcolors, G_surface.gvtx(3)];

    local [s_idx, s_color, s_vpt, s_vnorm] = G_surface.gvtx;
    if add GKey G_surface.gobj then
        GSetTitle [G_surface.gobj, G_surface.title];
        G_surface.gobj = GCreateUnique G_surface.gobj;
    else
        G_surface.gobj = GCreateUnique G_surface.title;
    endif

    local trans = [G_surface.trans_f, G_surface.trans_b];
    GSetTransparency [G_surface.gobj, trans];
    local mat = peek [GMaterial 0, inc alltrue (trans >= MAT_TRANS_MIN)];
    GSetMaterial [G_surface.gobj, mat];
    GVertex [G_surface.gobj, G_surface.surfdim, s_idx, vcolor,
      s_vpt, s_vnorm];

    UpdateResidue [restok, selrow, selcol, 0];

    if not G_surface.fix then
        View G_surface.lig;
        G_surface.fix = 1;
    endif

endfunction

/****************************************************************************
 *
 *                          qb_QBPWDSetupPanel
 *
 ****************************************************************************/
global function qb_QBPWDSetupPanel []

    const INITLIG = 1;
    const SIGNIFRES = 5;

    static pwdkey;                     //  Shared with child tasks.
    static pwdfilename;
    static data;

    if MOE_BATCH then return; endif
    if WindowShow ['QB-PWDPanel', 1] then return; endif

    local [resnames, ligdata] = ReadData ['~daren/dev/MOEDivcon/heatmapdata3.csv'];
    local resabbrevs = apt tok_drop [resnames, 3];
    local lignames = app first ligdata;
    local ligabbrevs = apt tok_keep [lignames, -3];
    local ligvals = app second ligdata;
    data = [resnames, resabbrevs, tr [lignames, ligabbrevs, ligvals]];

    local missing = CheckResidues first data;
    if length missing > 0 then
        Warning twrite ['The following residues are not present\n'
            'in receptor in MOE Window:\n{v}\n', missing];
        return;
    endif

    local appdflts = tag tr QBPWD_OPT_DEFAULTS;

    local wkey = WindowCreate cat [HEADER, PANEL];
    pwdkey = 0;
    pwdfilename = '';
    G_surface = [];

    WindowSetData [wkey, appdflts];
    WindowShow [wkey, 1];

    loop
        local [vals, trig] = WindowWait wkey;

       if trig === 'panel' then
            if vals.panel === 'Close' then 
                break;

            elseif vals.panel === 'Load' then 
                if second task_fork [master: 'parent',
                        statics:'share'] === 'child' then
                    task_prio 0;

//TODO:  message and disable window while loading

                    local dbpath = FilePrompt [title: 'Load Database', 
                        filter: '*.mdb', allowEmptyList: 0];
                    if not isnull dbpath then
                        local [ldkey, ldrec, ldlig, ldsts, ldcoreopts,
                            ldpwdopts] = LoadDB [dbpath];

                        if neL [ldcoreopts.mode, 'Many-to-Many'] then
                            Close [force:1];
                            if neL [ldrec, []] and neL [ldlig, []] then
                                local ldligmol = mol_Create ldlig;
                                local ldligatoms = cat oAtoms ldligmol;
                                oSetCollection ['QB_LIGAND', ldligatoms];
                                aSetNucleusLook [ldligatoms, 'small-sphere'];
                                aSetBondLook [ldligatoms, 'cylinder'];
                                mol_Create ldrec;
                                View [];
                            endif
                        endif

                        pwdkey = ldkey;
                        pwdfilename = db_Filename pwdkey;
                        db_Close ldkey;
                        WindowSetData [wkey, ldpwdopts];
                    endif

                    exit [];
                endif
            endif

        elseif trig === 'heatmap' then

            if second task_fork [statics:'share', 
                    master:'parent'] === 'child' then

                if isnull G_surface then
                    local msgkey = Message [0, 'Calculating surface ...'];
                    CreateSurfaceMap [first data];
                    msgkey = Message [msgkey, ''];
                endif

                //  Make sure ligand atoms sets are loaded.
                if isnull G_surface.ligmols then
                    LoadLigs [pwdfilename];
                endif

                //  Make sure first ligand is in MOE Window
                UpdateComplex INITLIG;
                qb_HeatMapSetupPanel [data, vals.cutoff, SIGNIFRES, 
                    vals.mapncolors, vals.mapmono, vals.mapnticks, 
                    'qb_QBPWDSelectHandler', INITLIG, 1];

                exit [];
            endif
        endif
    endloop

    ClearSurfaceMap G_surface.title;
    aSetLabelRes [G_surface.resatms, 0];
    G_surface = [];
    WindowDestroy wkey;

endfunction

#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2011 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

	//    pwdpanel.svl    User-interface entrypoint to QB-PWD calculations

#set title   'QuantumBio PWD Panel'
#set class   'QuantumBio'
#set version '2011.03'
#set main    'qb_QBPWDSetupPanel'

function grid_isoidx_emit;
function msurf_MolecularSurface;
function pboltz_AtomParameters;

function qb_CreateMessWin;
function qb_GetAnalysisData;
function qb_GetCoreOpts;
function qb_GetEnvAnal;
function qb_GetPoseFields;
function qb_GetRecFields;
function qb_IsModeManyToMany;
function qb_LoadCoreScoreDB;
function qb_ResNameCanonical;
function qb_ResNameEquivSet;
function qb_RMSD;
function qb_SaveEnvAnal;
function qb_SplitComplex;
function qb_GetCoreEnv;

function qb_HeatMapSetupPanel;

function qb_PWDAnalysis;

function qb_PWDAnalysisTmp;   // DELME

function pro_Join;
function pro_Align;

const PWD_EXPACT_HDR = 'QMScore';

const RMSD_MAX = 0.1;
const MAT_TRANS_MIN = 0x80;
const INITDIST = 7.5;
const INITSEL = 1;

const QBPWD_OPT_DEFAULTS =
    [
    ['title',        'PWD Analysis'],
    ['analysis',     1             ],
    ['sf_e_ab',      1             ],
    ['sf_e_abp',     0             ],
    ['sf_e_abc',     0             ],
    ['sf_e_r6',      1             ],
    ['sf_e_r12',     0             ],
    ['sf_e_ele',     0             ],
    ['prune_zero',   95            ],
    ['prune_sd',     0.05          ],
    ['expact_hdr',   PWD_EXPACT_HDR],
    ['numtopres',    25            ],
    ['numcomps',     10            ],
    ['trainingset',  0             ]
    ];

const ANALYSIS =
    [
    'Interaction Heat Map',
    'SAR Heat Map',
    'Activities Table',
    'PLS Results Table'
    ];

const ANALOPTLV = 5;
const ANALKEYS =
    [
    'inter',
    'sar',
    'act',
    'pls',
    'optlv'
    ];

const HEADER = 
    [
    name: 'panel', 
    title: 'QB-PWD',
    windowName: 'QB-PWDPanel',
    text: ['Apply', 'Load', 'Close'],
    onTrigger: ['return', 'return', 'return'],
    bubbleHelp: ['Perform QB-PWD analysis.',
            'Load QB-PWD data from a QMScore database.', 
            '']
    ];

const PANEL =
    [
    Vbox :
        [
        name: 'analbox',
        Hbox :
            [
            title: 'Title       ',
            extendH: 1,
            Text :
                [
                name: 'title', allowBlank: 0,
                type: 'char', len: 40,
                bubbleHelp:
                    'The title is used to label heat maps\n'
                    'and tables, and to form filenames.'
                ]
            ],

        Separator : [flushLeft:1, extendH:1, margin:1],

        Hbox :
            [
            title: 'Scoring     ',
            extendH: 1,
            Checkbox :
                [
                name: 'sf_e_ab', text: 'E_AB', title: 'QM:',
                bubbleHelp:
                    'E_AB is the exchange between atoms.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Checkbox :
                [
                name: 'sf_e_abp', text: 'E_ABp',
                bubbleHelp:
                    'E_ABp is the electron-electron repulsion.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Checkbox :
                [
                name: 'sf_e_abc', text: 'E_ABc',
                bubbleHelp:
                    'E_ABc is the core-electron interaction.'
                ]
            ],

        Hbox :
            [
            title: 'Function    ',
            extendH: 1,
            Checkbox :
                [
                name: 'sf_e_r6', text: 'E_R6', title: 'MM:',
                bubbleHelp:
                    'E_R6 is the van der Waals repulsive component.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Checkbox :
                [
                name: 'sf_e_r12', text: 'E_R12',
                bubbleHelp:
                    'E_R12 is the van der Waals attractive component.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Checkbox :
                [
                name: 'sf_e_ele', text: 'E_ELE',
                bubbleHelp:
                    'E_ELE is the electrostatic component.'
                ]
            ],

        Separator : [flushLeft:1, extendH:1, margin:1],

        Hbox :
            [
            title: 'Activities  ',
            extendH: 1,
            Text :
                [
                name: 'expact_hdr', allowBlank: 0, title: 'Field:',
                type: 'char', len: 40,
                bubbleHelp:
                    'The MOE database field name for\n'
                    'the experimental activity values.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Button :
                [
                name: 'loadact', text: 'Load',
                bubbleHelp:
                    'Load in the experimental activity data\n'
                    'from a csv file using the given field name.'
                ]
            ],

        Separator : [flushLeft:1, extendH:1, margin:1],

        Hbox :
            [
            title: 'Residues    ',
            extendH: 1,
            Label :
                [
                font: 'mediumBold', text: 'Pruning:'
                ],
            Text :
                [
                name: 'prune_zero', allowBlank: 0,
                title: 'Maximum percent zero:',
                type: 'int', len: 5,
                bubbleHelp:
                    'Prune residues which have greater than the\n'
                    'specified % of zero values for the selected\n'
                    'energies for the ligands in the training set;\n'
                    'that is; those distant from the pocket with\n'
                    'very little interaction with the ligands.'
                ],
            Label :
                [
                font: 'mediumBold', text: '%'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Text :
                [
                name: 'prune_sd', allowBlank: 0, title: 'Minimum SD:',
                type: 'real', len: 5,
                bubbleHelp:
                    'Prune residues which have a smaller standard\n'
                    'deviation over the values of the selected energies\n'
                    'for the ligands in the training set than the\n'
                    'specified SD; that is, exclude those that do have\n'
                    'not distinguishing characteristic.'
                ]
            ],

        Hbox :
            [
            title: '            ',
            extendH: 1,
            Text :
                [
                name: 'numtopres', allowBlank: 0,
                title: 'Number of top scorers:',
                type: 'int', len: 5,
                bubbleHelp:
                    'Keep only the specified number of top scoring\n'
                    'residues to show in the Heat Map (max 30).'
                ]
            ],

        Separator : [flushLeft:1, extendH:1, margin:1],

        Hbox :
            [
            title: 'PLS         ',
            extendH: 1,
            Text :
                [
                name: 'numcomps', allowBlank: 0,
                title: 'Number of components:',
                type: 'int', len: 5,
                bubbleHelp:
                    'Number of components to include in\n'
                    'the model during PLS analysis.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Text :
                [
                name: 'trainingset', title: 'Training set size:',
                len: 5, extendH: 0, 
                type: 'int', allowBlank: 0,
                bubbleHelp:
                    'Size of the training set (the first N ligands\n'
                    'or receptors/ligand pairs are treated as\n'
                    'the training set during PLS analysis).'
                ]
            ]
        ],

        
    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        name: 'selbox',
        title: 'Analysis    ',
        extendH: 1,
        Option :
            [
            name: 'analysis', text: ANALYSIS,
            type: 'int', minWidth: 8,
            bubbleHelp:
                'Chose an analysis data set to view and/or save.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 0, margin:1
            ],
        Button :
            [
            name: 'analview', text: 'View',
            bubbleHelp:
                'View the analytic results (table or heat map).'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 0, margin:1
            ],
        Button :
            [
            name: 'analsave', text: 'Save',
            bubbleHelp:
                'Save the analytic results in a csv file.'
            ]
        ],
        
    Separator : [flushLeft:1, extendH:1, margin:1]
    ];

	//  Global Variables

    global G_surface;                     // Callback function needs access

	//  Local Functions

function FindResidue;

/****************************************************************************
 *
 *                          CheckResidues
 *
 *  Check whether the residue names and numbers match those present
 *  in the receptor in the MOE Window.
 *
 *  Returns the list of residues tokens not found in the receptor.
 *
 ****************************************************************************/
local function CheckResidues [restoks]

    local res, missing = [];
    for res in restoks loop
        local [residx, ra] = FindResidue res;
        if residx === 0 then
            missing = append [missing, res];
        endif
    endloop

    return missing;

endfunction

function MatchResidue;

/****************************************************************************
 *
 *                          ColorAtoms
 *
 *  Determine the color of the residue atoms based on its interaction with
 *  the ligand.  If ligidx is zero, return all white.
 *
 ****************************************************************************/
local function ColorAtoms [data, ligidx, residx, recatoms, 
        mincut, maxcut, colors]

    if ligidx === 0 then
        return rep [G_surface.colconst, length recatoms];
    endif

    local step = (maxcut - mincut) / (length colors);
    local [titles, sequence, resabbrevs, rowdata] = data;
    local rowvals = third rowdata (ligidx);
    local restokens = last rowdata (ligidx);
    local atom, atomcolors = [];
    for atom in recatoms loop
        local residue = aResidue atom;
        local restok = twrite ['{}{}', rName residue, rUID residue];
        local idx = MatchResidue [restok, restokens];
        if idx > 0 and (residx === 0 or residx === idx) then
            local cidx, value = rowvals (idx);
            if value <= mincut then
                cidx = 1;
            elseif value >= maxcut then
                cidx = length colors;
            else
                cidx = ceil ((value - mincut) / step);
            endif

            atomcolors = append [atomcolors, colors (cidx)];
        else
            atomcolors = append [atomcolors, G_surface.colconst];
        endif
    endloop

    return atomcolors;

endfunction

/****************************************************************************
 *
 *                          CreatePockets
 *
 *  Create a pockets for each receptor/ligand pair using the given distance.
 *
 *  Returns the list of pocket mols with the heavy atoms only.
 *
 ****************************************************************************/
local function CreatePockets [dist]

    G_surface.pockets = rep [[], G_surface.numgrids];
 
    local ith, rec, recpos, pocket;
    if isnull G_surface.recmols then
        rec = G_surface.rec | aElement G_surface.rec <> 'H';
        recpos = aPos rec;
    endif

    for ith = 1, G_surface.numgrids, 1 loop
        if not isnull G_surface.recmols then
            rec = mol_Heavy G_surface.recmols (ith);
            recpos = mol_aPos rec;
        endif

        local lig = mol_Heavy G_surface.ligmols (ith);
        local ligpos = mol_aPos lig;

        local proxkey = prox_open [dist, ligpos, dist/2];
        local recmap = first prox_find [proxkey, recpos, dist/2];
        prox_close proxkey;

        //  Expand pocket atoms to residue
        if not isnull  G_surface.recmols then
            local reslens = rec(3)(MOL_RES_NATOMS);
            local resmaps = split [recmap, reslens];
            local rith;
            for rith = 1, length resmaps, 1 loop
                local rmap = resmaps (rith);
                if anytrue rmap then
                    rmap = one rmap;
                    resmaps = poke [resmaps, rith, rmap];
                endif
            endloop

            pocket = mol_aMask [rec, cat resmaps];
        else
            local resatoms = rec | recmap;
            local residues = uniq oResidues resatoms;
            resatoms = cat oAtoms residues;
            pocket = mol_Extract resatoms;
        endif

        G_surface.pockets = poke [G_surface.pockets, ith, pocket];
    endloop
endfunction

function LoadMols;
function UpdateComplex;
function UpdateSurfaceMap;

/****************************************************************************
 *
 *                          InitG_surface
 *
 *  Initialize G_surface object.
 *
 ****************************************************************************/
local function InitG_surface []

    local gridopt = [type: 'Connolly', probe_vdwR: 1.4000, spacing: 0.5, 
        clipmode: 0];

    G_surface =
        [
        gobj     : [],
        title    : 'QB Heat Map Surface',
        colconst : 0xFFFFFF,            // White
        surfdim  : 3,
        trans_f  : 96,
        trans_b  : 96,
        gridopt  : gridopt,
        numgrids : 0,
        grids    : [],
        dist     : 0,
        rad      : [],
        eps      : [],
        init     : 1,
        molidx   : 0,
        recmols  : [],
        ligmols  : [],
        recChains: [],
        ligChains: [],
        lignames : [],
        pockets  : [],
        prevrow  : 0,
        prevcol  : 0,
        rec      : [],
        lig      : [],
        restok   : '',
        resatms  : []
        ];

endfunction

/****************************************************************************
 *
 *                          CreateSurfaceMap
 *
 *  Create a surface map of the pocket.
 *
 *  Acknowledgement:  borrowed heavily from surfmap.svl.
 *
 ****************************************************************************/
local function CreateSurfaceMap [radius, ligtok, restoks, pwdfilename]
	if isnull G_surface then
		InitG_surface [];
		LoadMols [pwdfilename];
	endif
	
	if G_surface.init === 1 then
		UpdateComplex [ligtok, radius];
	
		local missing = CheckResidues [restoks];
		if length missing > 0 then
			Warning twrite ['The following residues are not \n'
				'present in the receptor in the MOE Window:\n{v}\n',
				missing];
		endif
	
		G_surface.grids = rep [[], G_surface.numgrids];
		G_surface.gobj = GCreateUnique G_surface.title;
		local trans = [G_surface.trans_f, G_surface.trans_b];
		GSetTransparency [G_surface.gobj, trans];
		local mat = peek [GMaterial 0, inc alltrue (trans >= MAT_TRANS_MIN)];
		GSetMaterial [G_surface.gobj, mat];
		UpdateSurfaceMap [radius, 1, []];
		G_surface.init = 0;
    endif

endfunction

/****************************************************************************
 *
 *                          FindResidue
 *
 *  Find the residue with the given name and number in the receptor 
 *  in the MOE Window.  Check to make sure MOE or bio3d didn't rename it.
 *
 *  Returns the index of the residue and its atom set.
 *
 ****************************************************************************/
local function FindResidue [restok]

    if MOE_BATCH then exit ['Should only be run from MOE.']; endif

    local rnidx = indexof ["1234567890", string restok];
    rnidx = rnidx | rnidx <> 0;
    rnidx = (min rnidx) - 1;
    local residx = 0, resatms = []; 
    local residues = Residues [];
    local resnames = rName residues;
    local rname = tok_keep [restok, rnidx];
    local equivset = qb_ResNameEquivSet rname;
    if isnull equivset then equivset = rname; endif

    local indices = cat indicesof [equivset, resnames];
    if length indices > 0 then
        local rnum = atoi tok_drop [restok, rnidx];
        local idx_i = indexof [rnum, rUID residues [indices]];
        if idx_i > 0 then
            residx = indices (idx_i);
            resatms = cat oChildren residues (residx);
        endif
    endif

    return [residx, resatms];
endfunction

/****************************************************************************
 *
 *                          FindSurface
 *
 *  Find the index of an existing surface that matches the pocket of the 
 *  current receptor in G_surface.
 *
 *  Returns true if a match was found; false, otherwise.
 *
 ****************************************************************************/
local function FindSurface []

    if isnull G_surface then return 0; endif

    local pocketpos = cat mol_aPos G_surface.pockets (G_surface.molidx);

    local m = not (app isscalarnum G_surface.grids 
        or app isnull G_surface.grids);
    local indices = igen length G_surface.grids | m;
    local molidx, found = 0;
    for molidx in indices loop
        if molidx === G_surface.molidx then continue; endif

        local nextpos = cat mol_aPos G_surface.pockets (molidx);
        local rmsd = qb_RMSD [pocketpos, nextpos];
        found = ltL [rmsd, RMSD_MAX];
        if found then
             break;
         endif
    endloop

    if found then
        G_surface.grids = poke [G_surface.grids, G_surface.molidx, molidx];
    endif

    return found;
endfunction

/****************************************************************************
 *                          TruncateAnalData
 *
 *  Data provided by MOE/DivCon includes all data (even less significant data).
 *    Need to cut this down to only the most significant data using the following criteria:
 *
 *      (1) If max and min are equal (probably zero) the residue is not interesting.
 *      (2) After this, only the top 30 residues with the greatest max/min will be shown.
 *          (the assumption here is that the user is less interested when the data
 *              is less varied.)
 *          @todo: add others perhaps but certainly provide some options to the user.
 *
 ****************************************************************************/
local function TruncateAnalData [ligvals, resnames, sequence]
    local idx;
    local mask;
    local differenceVector;

    if length ligvals < 1 then
        return;
    endif
	//      (1) If max and min are equal (probably zero) the residue is not interesting.
    if length ligvals > 1 then
        for idx = 1, length ligvals(1), 1 loop
            differenceVector(idx) = maxE apt peek [ligvals, idx] - minE apt peek [ligvals, idx];
        endloop
    else
        differenceVector = app abs ligvals(1);
    endif
    local tmpSorted = sortuniq differenceVector;
    idx = 0;
    loop
        idx = idx + 1;
        mask = differenceVector >= tmpSorted(idx);
        until (length ( differenceVector | mask ) <= min [length differenceVector, 30] or
            length tmpSorted == idx) 
    endloop
    local outVals, outNames;
    local tmpVals, tmpNames;
    for tmpVals in ligvals loop
        outVals = append [outVals, tmpVals | mask];
    endloop
    for tmpNames in resnames loop
        outNames = append [outNames, tmpNames | mask];
    endloop
    
    return [outVals, outNames, sequence | mask];
    
endfunction


/****************************************************************************
 *                          GetAnalData
 *
 *  Get the analysis data and repackage the tables for heat map.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
 ****************************************************************************/
local function GetAnalData [dbpath, title]

    local function trim [t]
        local i = indexof ["=", string t];
        if i > 0 then return tok_keep [t, i - 1]; else return t; endif
   endfunction
    local function where [r]
        local rnidx = indexof ["1234567890", string r];
        rnidx = rnidx | rnidx <> 0;
        return  (min rnidx) - 1;
    endfunction

    local function abbreviate [rn, ln]
        local idx = app where rn;
        local arn = apt tok_drop [rn, idx];
        arn = apt tok_keep [arn, -3];
        local aln = app trim ln;
        aln = apt tok_drop [aln, 3];
        aln = apt tok_keep [aln, -3];
        return [arn, aln];
    endfunction

    if MOE_BATCH then exit ['Should only be run from MOE.']; endif

    if neL [fext dbpath, 'mdb'] then
        Warning twrite ['{}\n is not a MOE database.', dbpath];
        exit [];
    endif

    if neL [ftype dbpath, 'file'] then
        Warning twrite ['Unable to find the QMScore/PWD database:\n'
            '    {}', dbpath];
        exit [];
    endif

    local dbkey = db_Open [dbpath, 'read'];
    local interdata = qb_GetAnalysisData [dbkey, 'pwd', 'inter'];
    local sardata = qb_GetAnalysisData [dbkey, 'pwd', 'sar'];
    local actdata = qb_GetAnalysisData [dbkey, 'pwd', 'act'];
    local plsdata = qb_GetAnalysisData [dbkey, 'pwd', 'pls'];
    local lvdata = qb_GetAnalysisData [dbkey, 'pwd', 'optlv'];
    db_Close dbkey;
    local fulltitle, resnames, sequence, resabbrevs;
    local ligdata, lignames, ligabbrevs, ligvals;
    if not isnull interdata then
        fulltitle = twrite ['{} Interaction Map', title];
        [sequence, ligdata] = interdata;
        lignames = app first ligdata;
        ligvals = app second ligdata;
        resnames = app third ligdata;
        [ligvals,resnames,sequence]=TruncateAnalData [ligvals, resnames, sequence];
        [resabbrevs, ligabbrevs] = abbreviate [resnames, lignames];
	// @todo: remove the double reference to sequence. This will require structural change to 'data' and therefore
	//          should come when we change to tagged vectors (or XML).
        interdata = [[fulltitle, 'Ligands', 'Residues'], sequence, sequence,
            tr [lignames, ligabbrevs, ligvals, resnames]];
    endif

    if not isnull sardata then
        fulltitle = twrite ['{} SAR Map', title];
        [resnames, ligdata] = sardata;
        lignames = app first ligdata;
        ligvals = app second ligdata;
        [resabbrevs, ligabbrevs] = abbreviate [resnames, lignames];
        sardata = [[fulltitle, 'Ligands', 'Residues'], resnames, resabbrevs,
            tr [lignames, ligabbrevs, ligvals]];
    endif

    if not isnull actdata then
        fulltitle = twrite ['{} Activities Table', title];
        actdata = [fulltitle, actdata];
    endif

    if not isnull plsdata then
        fulltitle = twrite ['{} PLS Results Table', title];
        plsdata = [fulltitle, plsdata];
    endif

    return [interdata, sardata, actdata, plsdata, lvdata];

endfunction

/****************************************************************************
 *                          LoadDB
 *
 *  Get the core enviroment and application environment.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
 ****************************************************************************/
local function LoadDB [dbpath]

    local [dbkey, receptor, ligand, s, coreopts, c, mess] = 
        qb_LoadCoreScoreDB [dbpath, 'qmscore'];
    if dbkey === 0 then
        Warning mess;
        exit [];
    endif

    local pwdopts = qb_GetEnvAnal [dbkey];
    pwdopts = tagcat [pwdopts, tag tr QBPWD_OPT_DEFAULTS];

    return [dbkey, receptor, ligand, coreopts, pwdopts];
endfunction

/****************************************************************************
 *                          LoadMols
 *
 *  Load the ligands (and receptors, if necessary) from the PWD database.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
****************************************************************************/
local function LoadMols [pwdfilename]

    if MOE_BATCH then exit ['Should only be run from MOE.']; endif

    if neL [fext pwdfilename, 'mdb'] then
        Warning twrite ['{}\n is not a MOE database.', pwdfilename];
        exit [];
    endif

    if neL [ftype pwdfilename, 'file'] then
        Warning twrite ['Unable to find the QMScore/PWD database:\n'
            '    {}', pwdfilename];
        exit [];
    endif

    local dbkey = db_Open [pwdfilename, 'read'];
    local [recmol, ligmol, s, coreopts, c] = qb_GetCoreEnv [dbkey];

    local recmols = [];
    local ligmols = [];
    local lignames = [];
    local rowkey = 0;
    local ligflds = qb_GetPoseFields [];
    local lc;

    while rowkey = db_NextEntry [dbkey, rowkey] loop
        [ligmol, lc] = db_ReadFields [dbkey, rowkey, ligflds];
        ligmols = append [ligmols, ligmol];
        lignames = append [lignames, ligmol(1)(MOL_NAME)];
    endloop
    
    if qb_IsModeManyToMany [coreopts] then
        local recflds = qb_GetRecFields [];
        recmols = db_ReadColumn [dbkey, first recflds];
    else
        recmols = append [recmols,recmol];
    endif

    G_surface.recmols = recmols;
    G_surface.ligmols = ligmols;
    G_surface.lignames = lignames;
    G_surface.numgrids = length ligmols;

    db_Close dbkey;
    
    oDestroy Chains[];

	// The following two loops will go through and make sure that the new G_surface has the aligned proteins.   
    local idx;
    local targ_chainsList = [], lig_chainsList = [];
    local allLigAtms = [];
    for idx = 1, length G_surface.recmols, 1 loop
        targ_chainsList(idx) = mol_Create G_surface.recmols(idx);
        pro_Join targ_chainsList(idx);
        targ_chainsList(idx) = targ_chainsList(idx)(1);
        aSetHidden [oAtoms targ_chainsList(idx),1];
		cSetName [targ_chainsList(idx), G_surface.recmols(idx)(1)(MOL_NAME)];
    endloop
    aSetHidden [oAtoms targ_chainsList(1), 0];
    for idx = 1, length G_surface.ligmols, 1 loop
        lig_chainsList(idx) = mol_Create G_surface.ligmols(idx);
        allLigAtms = cat [allLigAtms, cat cAtoms lig_chainsList(idx)];
        oSetCollection ['QB_LIGAND', allLigAtms];
        aSetHidden [oAtoms lig_chainsList(idx),1];
		cSetName [lig_chainsList(idx), G_surface.ligmols(idx)(1)(MOL_NAME)];
    endloop
    aSetHidden [oAtoms lig_chainsList(1), 0];
    if length Chains [] > 0 then
        pro_Align [Chains []];
    endif
    View [];
    local tmpRecMols = [];
    local tmpLigMols = [];
    for idx = 1, length G_surface.recmols, 1 loop
        tmpRecMols(idx) = mol_Extract [targ_chainsList(idx)];
    endloop
    for idx = 1, length G_surface.ligmols, 1 loop
        tmpLigMols(idx) = mol_Extract [lig_chainsList(idx)];
    endloop
    G_surface.recmols = tmpRecMols;
    G_surface.ligmols = tmpLigMols; 

    G_surface.recChains = targ_chainsList;
    G_surface.ligChains = lig_chainsList; 
endfunction

/****************************************************************************
 *                          MatchResidue
 *
 *  Look up the residue by NameUID token.  If not found, check to make sure
 *  MOE or bio3d didn't rename it.
 *
 ****************************************************************************/
local function MatchResidue [restok, restokset]

    local residx = indexof [restok, restokset];
    if residx === 0 then
        local rnidx = indexof ["1234567890", string restok];
        rnidx = rnidx | rnidx <> 0;
        rnidx = (min rnidx) - 1;

        local rname = tok_keep [restok, rnidx];
        local rnum = atoi tok_drop [restok, rnidx];
        local canonical = qb_ResNameCanonical rname;
        if isnull canonical then canonical = rname; endif
        restok = twrite ['{}{}', canonical, rnum];
        residx = indexof [restok, restokset];
    endif

    return residx;
endfunction

/****************************************************************************
 *
 *                          NearestAtomColor
 *
 *  Computes the surface colors as the closest atom colors to the
 *  surface points (weighted by distance).
 *
 *  Local function copied from surfmap.svl (ask CCG to change it to global?).
 *  Note:  the atom colors are based on the interaction between its residue
 *  and the ligand.
 *
 ****************************************************************************/
local function NearestAtomColor [pos, rad, acolor, spos]
    const NAC_BUCKET_SIZE = 4.0;
    const NAC_MAX_POINTS  = 100000;

    const ALPHA = 2.5;
    local maxrad = max [1, max rad];
    local argb = bitand [0xFF, bitshr [[acolor],[16,8,0]]];
    local r = rep [0, l_length spos], g = r, b = r;
    local vsum = rep [0, l_length spos];

    // Do a proximity check to determine the minimum distance
    // that will associate a point with an atom.  NAC_BUCKET_SIZE
    // is the bin size for the search, and so the maximum distance
    // allowed.  We'll use at most NAC_MAX_POINT gridpoints for
    // the check.

    local pprox = prox_open [NAC_BUCKET_SIZE, pos, NAC_BUCKET_SIZE];
    local Upts;

    if length first spos > NAC_MAX_POINTS then
    Upts = apt keep [spos, NAC_MAX_POINTS];
    else
    Upts = spos;
    endif

    local [seg, idx, r2] = prox_find [pprox, Upts, 0];
    local d_ndx = split [idx, seg];
    local min_dist = max app min apt get [[r2], d_ndx];

    prox_close pprox;

    // Use the larger of the caller's and 'found' distances

    maxrad = max [maxrad, sqrt min_dist - 1];
    local sprox = prox_open [1 + maxrad, spos, 1 + maxrad];
    local i;
    for i = 1, l_length pos loop
    [seg, idx, r2] = prox_find [sprox, apt peek [pos, i], 0];
    if not length idx then continue; endif
    local w = exp (-ALPHA * maxE [0, sqrt r2 - 0.95 * rad(i)] );
    vsum[idx] = vsum[idx] + w;
    r[idx] = r[idx] + w * argb(1)(i);
    g[idx] = g[idx] + w * argb(2)(i);
    b[idx] = b[idx] + w * argb(3)(i);
    endloop

    prox_close sprox;

    local vrgb = [r,g,b] * [invz vsum];
    vrgb = maxE [0, minE [0xFF, vrgb]];
    return bitor bitshl [vrgb,[16,8,0]];

endfunction

/****************************************************************************
 *
 *                          ReadExpActData
 *
 *  Read experimental activity data, separated by white space, from the file 
 *  and store it in the given QMScore database in the ExpAct field.  It is
 *  assumed that the orderings are consistent.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
 ****************************************************************************/
local function ReadExpActData [expactfn, qmsdbfn, header]
    if neL [fext qmsdbfn, 'mdb'] then
        Warning twrite ['{}\n is not a MOE database.', qmsdbfn];
        exit [];
    endif

    if neL [ftype qmsdbfn, 'file'] then
        Warning twrite ['Unable to find the QMScore/PWD database:\n    {}',
            qmsdbfn];
        exit [];
    endif

    if neL [ftype expactfn, 'file'] then
        Warning twrite ['Unable to find the file\n    {}', expactfn];
        exit [];
    endif

    local qdbkey = db_Open [qmsdbfn, 'read-write'];
    local eaf = fopenr expactfn;

    db_EnsureField [qdbkey, header, 'double'];
    local rowkey = 0;
    while rowkey = db_NextEntry [qdbkey, rowkey] loop
        local val = fread [eaf, '{n:}'];
        db_Write [qdbkey, rowkey, tag [header, val]];
    endloop

    fclose eaf;
    db_Close qdbkey;

endfunction

/****************************************************************************
 *
 *                          ReadMatrixData
 *
 *  Return data formatted for the heat map.
 *
 ****************************************************************************/
local function ReadMatrixData [filename]

    local f = fopenr filename;
    local lines = freadb [f, 'line', INT_MAX];
    local line = first lines;
    local strings = wordsplit [line, ","];
    local colnames = app token strings;
    lines = dropfirst lines;

    //  row labels and values
    local rowdata = [];
    for line in lines loop
        strings = wordsplit [line, ","];
        local rowname = token first strings;
        strings = dropfirst strings;
        local rowvals = atof app token strings;
        rowdata = append [rowdata, [rowname, rowvals]];
    endloop

    fclose f;

    return [colnames, rowdata];
endfunction

/****************************************************************************
 *
 *                          SaveMatrixData
 *
 *  Save the matrix data in csv format.
 *
 ****************************************************************************/
local function SaveMatrixData [filename, matrixdata, type]

    local title, rowlbl, collbl, colnames, colabbrevs, rowdata;
    if type === 'sar' or type === 'inter' then
        [[title, rowlbl, collbl], colnames, colabbrevs, rowdata] = matrixdata;
    elseif type === 'act' or type === 'pls' then
        [title, [colnames, rowdata]] = matrixdata;
    else
        Warning ['Unknown analysis data type.'];
        return [];
    endif

    filename = FilePrompt [
	title :	'title',
	mode  :	'saveAs',
	path  :	'directory',
	filter:	'*.csv',
	name  :	filename,
	multi :	0,
	allowEmptyList : 0,
	allowDuplicates: 0
    ];

	if not isnull filename then
		local f = fopenw filename;
	
		local cname;
		for cname in colnames loop
			fwrite [f, ',{t:}', cname];          // first column name empty
		endloop
	
		fwrite [f, '\n'];
	
		local row;
		for row in rowdata loop
			local rowname, rowabbrev, rowvals;
			if type === 'sar' or type === 'inter' then
				[rowname, rowabbrev, rowvals] = row;
			elseif type === 'act' or type === 'pls' then
				[rowname, rowvals] = row;
			endif
	
			fwrite [f, '{t:}', rowname];
			local val;
			for val in rowvals loop
				fwrite [f, ',{n:f}', val];
			endloop
	
			fwrite [f, '\n'];
		endloop
	
		fclose f;
	endif
    return;
endfunction

/****************************************************************************
 *                          SaveOptions
 *
 *  Save the analysis options in the QMScore database.
 *
 ****************************************************************************/
local function SaveOptions [dbpath, options]

    if MOE_BATCH then exit ['Should only be run from MOE.']; endif

    if neL [fext dbpath, 'mdb'] then
        Warning twrite ['{}\n is not a MOE database.', dbpath];
        return;
    endif

    if neL [ftype dbpath, 'file'] then
        Warning twrite ['Unable to find the QMScore/PWD database:\n'
            '    {}', dbpath];
        return;
    endif

    local dbkey = db_Open [dbpath, 'read-write'];
    qb_SaveEnvAnal [dbkey, options];
    db_Close dbkey;

endfunction

/****************************************************************************
 *                          ShowTable
 *
 *  Format the table data and display it in the message window.
 *
 *
 ****************************************************************************/
local function ShowTable [data, postscript]

    local function writeNfield [nf]
        return twrite ['{n:15.5f}', nf];
    endfunction

    local function writeTfield [tf]
        return twrite ['{t:15}', tf];
    endfunction

    local [title, [colNames, rowdata]] = data;
    local buffer = twrite ['{t:50}\n\n', title];
    buffer = tok_cat [buffer, writeTfield ' '];
    buffer = tok_cat [buffer, tok_cat app writeTfield colNames, '\n'];

    local row;
    for row in rowdata loop
        local [lbl, values] = row;
        buffer = tok_cat [buffer, writeTfield lbl];
        buffer = tok_cat [buffer, tok_cat app writeNfield values, '\n'];
    endloop

    if neL [postscript, ''] then
        buffer = tok_cat [buffer, postscript];
    endif

    qb_CreateMessWin [string buffer, 40, 80];

endfunction


/****************************************************************************
 *
 *                          UpdateComplex
 *
 *  Replace the ligand/receptor in the MOE window with those corresponding
 *  to the given ligand name.  Returns true if the surface needs to be
 *  created.
 *
 ****************************************************************************/
local function UpdateComplex [ligtok, radius]
    if ligtok === '' then return 0; endif
    if isnull G_surface then return 0; endif
    if isnull G_surface.ligmols then return 0; endif
    local molidx = indexof [ligtok, G_surface.lignames];
    if G_surface.molidx === molidx then return 0; endif

    G_surface.molidx = molidx;
    
    if isnull G_surface.molidx then
	//    @todo: this fixes an error when empty, however we should provide an improved error.
        return;
    endif

    local redosurf = 0, vdwR = [], vdwE = [];
    if not isnull G_surface.recmols then
        if G_surface.init then
            Close [force:1];
        else
            oDestroy uniq oChains G_surface.rec;
        endif
        local recidx = G_surface.molidx;
        if length G_surface.recmols === 1 then
            recidx = 1;
        endif
        local recchn = mol_Create G_surface.recmols (recidx);
        G_surface.rec = cat cAtoms recchn;
        [vdwR, vdwE] = pboltz_AtomParameters G_surface.rec;
        G_surface.rad = vdwR;
        G_surface.eps = vdwE;
        G_surface.resatms = [];
        G_surface.restok = '';

    elseif G_surface.init then
        local [recatoms, ligatoms, errmess] = qb_SplitComplex [0];
        if recatoms === [] then
            Warning errmess;
            return [];
        endif

        [vdwR, vdwE] = pboltz_AtomParameters recatoms;
        G_surface.rec = recatoms;
        G_surface.rad = vdwR;
        G_surface.eps = vdwE;
        G_surface.resatms = [];
        G_surface.restok = '';

        G_surface.lig = ligatoms;
    endif

    local lignuc, ligbnd;
    if isnull G_surface.lig then
        lignuc = 'small-sphere';
        ligbnd = 'cylinder';
    else
        lignuc = aNucleusLook G_surface.lig (1);
        ligbnd = aBondLook G_surface.lig (1);
        oDestroy uniq oChains G_surface.lig;
    endif

    local ligchn = mol_Create G_surface.ligmols (G_surface.molidx);
    G_surface.lig = cat cAtoms ligchn;
    oSetCollection ['QB_LIGAND', G_surface.lig];
    aSetNucleusLook [G_surface.lig, lignuc];
    aSetBondLook [G_surface.lig, ligbnd];

    if gtL [length G_surface.ligmols, 1]  
            and (G_surface.init or neL [G_surface.dist, radius]) then
        CreatePockets [radius];
    endif

    if isnull G_surface.grids (G_surface.molidx) then
        redosurf = not FindSurface [];
    endif

    if G_surface.init then
        View G_surface.lig;
    endif

    return redosurf;
endfunction

/****************************************************************************
 *
 *                          UpdateResidue
 *
 *  Name highlight, and shift the view towards the selected residue.
 *
 *  Acknowledgement:  labeling the residue was borrowed from LabelResidue
 *                    in menu.svl.
 *
 ****************************************************************************/
local function UpdateResidue [restok, row, col, zoom]

    if col === 0 then
        aSetLabelRes [G_surface.resatms | oValid G_surface.resatms, 0];
        G_surface.resatms = [];
        G_surface.restok = '';
        return;
    endif

    if G_surface.restok === restok and row > 0 then return; endif

    aSetLabelRes [G_surface.resatms | oValid G_surface.resatms, 0];

    local [residx, resatms] = FindResidue restok;
    if residx === 0 then
        G_surface.resatms = [];
        G_surface.restok = '';
        return;
    endif

    G_surface.restok = restok;
    G_surface.resatms = resatms;

	local [idx, m] = sam graph_ccomponent BondGraph resatms;
    local aa;
	for aa in split [resatms [idx], mtoc m] loop
	    aSetLabelRes [sample [aa | graph_center BondGraph aa, 1], 1];
	endloop

    if zoom then
        View resatms;
    endif

endfunction

/****************************************************************************
 *
 *                          UpdateSurfaceMap
 *
 *  Update the surface map of the pocket.
 *
 *  Acknowledgement:  borrowed heavily from surfmap.svl.
 *
 ****************************************************************************/
local function UpdateSurfaceMap [radius, redogrid, atomcolors]

    if isnull G_surface then return; endif

    GClearVertexData G_surface.gobj;
    local gvtx = [];
    if G_surface.numgrids === 1 then
        gvtx = G_surface.grids(1);
    else
        gvtx = G_surface.grids(G_surface.molidx);
        while isscalarnum gvtx loop
            gvtx = G_surface.grids(gvtx);
        endloop
    endif

    local [s_idx, s_color, s_vpt, s_vnorm] = gvtx;

    if G_surface.init or neL [radius, G_surface.dist]
            or (redogrid and isnull gvtx) then
        local msgkey = Message [0, 'Calculating surface ...'];
        if G_surface.init or neL [radius, G_surface.dist] then
            local grids = rep [[], G_surface.numgrids];
            G_surface.grids = grids;
            G_surface.dist = radius;
        endif

        gvtx = msurf_MolecularSurface [aPos G_surface.rec, 
            G_surface.rad, G_surface.eps, aPos G_surface.lig, G_surface.dist, 
            G_surface.gridopt];
        [s_idx, s_color, s_vpt, s_vnorm] = gvtx;
        s_idx = grid_isoidx_emit [s_idx, G_surface.surfdim, -1];
        gvtx = poke [gvtx, 1, s_idx];

        G_surface.grids = poke [G_surface.grids, 
            select [1, G_surface.molidx, G_surface.numgrids === 1], gvtx];
        Message [msgkey, ''];
    endif

    if isnull gvtx then
        Warning 'Unable to generate surface.';
    endif

    local vcolor;
    if isnull atomcolors then
        vcolor = G_surface.colconst;
    else
	    vcolor = NearestAtomColor [aPos G_surface.rec, G_surface.rad,
            atomcolors, s_vpt];
    endif

    GVertex [G_surface.gobj, G_surface.surfdim, s_idx, vcolor,
      s_vpt, s_vnorm];

endfunction


	//  Global Functions

/****************************************************************************
 *
 *                          qb_QBPWDCloseHandler
 *
 ****************************************************************************/
global function qb_QBPWDCloseHandler []

    if not isnull G_surface then
        GDestroy G_surface.gobj;
        aSetLabelRes [(G_surface.resatms | oValid G_surface.resatms), 0];
        G_surface = [];

    endif

endfunction

/****************************************************************************
 *
 *                          qb_QBPWDGetDefaults
 *
 ****************************************************************************/
global function qb_QBPWDGetDefaults []

   return tag tr QBPWD_OPT_DEFAULTS;
endfunction

/****************************************************************************
 *
 *                          qb_QBPWDSelectHandler
 *
 ****************************************************************************/
global function qb_QBPWDSelectHandler [data, selrow, selcol, radius,
        mincut, maxcut, colors]

    if MOE_BATCH then exit ['Should only be run from MOE.']; endif
    if isnull G_surface then return; endif
    if allfalse eqE [G_surface.gobj, GKeyList []] then return; endif
    if isnull Atoms [] then return; endif

	// lmw: the selection of the sequence no longer makes sense.
	//      @todo: make it so that the sequence is no longer selectable.
    if selrow === 0 then
        return;
    endif

    local [t, sequence, ra, rowdata] = data;
    local [ligtok, la, ld, resnames] = rowdata (selrow);
    local restok = '';

    if selrow === 0 and selcol === 0 then
        return;
    elseif selcol > 0 then
        restok = resnames (selcol);
    endif

    local redosurf = UpdateComplex [ligtok, radius];
    local atomcolors = ColorAtoms [data, selrow, selcol, G_surface.rec, 
        mincut, maxcut, colors];
    UpdateSurfaceMap [radius, redosurf, atomcolors];
    UpdateResidue [restok, selrow, selcol, 0];

endfunction

/****************************************************************************
 *
 *                          qb_QBPWDSetupPanel
 *
 ****************************************************************************/
global function qb_QBPWDSetupPanel []

    const SHOWHELP = 1;
    const SIGNIFRES = 5;

    static pwdfilename;                     //  Shared with child tasks.
    static pwddata;
    static heatmaptask;

    if MOE_BATCH then exit ['Should only be run from MOE.']; endif
    if WindowShow ['QB-PWDPanel', 1] then return; endif

    pwdfilename = '';
    pwddata = [[], [], [], [], []];
    heatmaptask = 0;

    local msgkey, heatmapkey;
    local appdflts = tag tr QBPWD_OPT_DEFAULTS;
    local pwdopts = [];
    local wkey = WindowCreate cat [HEADER, PANEL];

    G_surface = [];

    WindowSetData [wkey, appdflts];
    WindowSetAttr [wkey, [analbox: [sensitive: 0], selbox: [sensitive: 0],
        panel: [sensitive: [0,1,1]]]];

    WindowShow [wkey, 1];

    loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'analview' then
            if second task_fork [statics:'share', 
                master:'parent'] === 'child' then

                // Load and setup data
                local data = pwddata (vals.analysis);
                if isnull data then
                    Warning 'No analysis data to view.';
                    exit [];
                endif

                if ANALKEYS (vals.analysis) === 'pls' then
                    ShowTable [data,
                        twrite ['\nOptimal LV:  {}\n', pwddata (ANALOPTLV)]];
                    exit [];
                endif

                if ANALKEYS (vals.analysis) === 'act' then
                    ShowTable [data, ''];
                    exit [];
                endif

                //  Otherwise, Heat Map
                //  Destroy current surface if necessary
                heatmapkey = WindowKey 'QB Heat Map';
                if heatmapkey > 0 then
                    GDestroy G_surface.gobj;
                    G_surface = [];
                    WindowDestroy heatmapkey;

                    //  And child task.
                    if heatmaptask > 0 then
                        task_kill heatmaptask;
                        heatmaptask = 0;
                    endif
                endif

                local rowdata = last data;
                CreateSurfaceMap [INITDIST, first rowdata (INITSEL), 
                    last rowdata(INITSEL), pwdfilename];

                heatmaptask = task_key -1;
                qb_HeatMapSetupPanel [data,  SIGNIFRES, 
                    'qb_QBPWDSelectHandler', INITDIST, SHOWHELP,
                    'qb_QBPWDCloseHandler'];
                exit [];
            endif

        elseif trig === 'analsave' then

            if second task_fork [statics:'share'] === 'child' then
                task_prio 0;

                // Load and setup data
                if isnull peek [pwddata, vals.analysis] then
                    Warning 'No analysis data to save.';
                    exit [];
                endif

                local savefile = twrite ['{} {}.csv', vals.title, 
                    ANALYSIS(vals.analysis)];
                SaveMatrixData [savefile, pwddata (vals.analysis), 
                    ANALKEYS(vals.analysis)];
                exit [];
            endif

        elseif trig === 'loadact' then

            if second task_fork [master: 'parent',
                    statics:'share'] === 'child' then
                task_prio 0;

                if neL [ftype pwdfilename, 'file']
                        or neL [fext pwdfilename, 'mdb'] then
                    Warning 
                        twrite ['Cannot find the QMScore/PWD database:\n{}.',
                            pwdfilename];
                    exit [];
                endif

                local actfile = first FilePrompt [title: 'Load Activities File',
                    filter: '*.csv', allowEmptyList: 0];
                if not isnull actfile then
                    ReadExpActData [actfile, pwdfilename, vals.expact_hdr];
                endif

                exit [];
            endif

        elseif trig === 'panel' then

            if vals.panel === 'Close' then
                task_prio 0;

	            if tok_length pwdfilename > 0 then
                    pwdopts = tag [first tr QBPWD_OPT_DEFAULTS, [
                        vals.title,
                        vals.analysis, vals.sf_e_ab, vals.sf_e_abp,
                        vals.sf_e_abc, vals.sf_e_r6,
                        vals.sf_e_r12, vals.sf_e_ele, vals.prune_zero,
                        vals.prune_sd, vals.expact_hdr,
                        vals.numtopres, vals.numcomps, vals.trainingset]];
                    SaveOptions [pwdfilename, pwdopts];
                endif
                break;

            elseif vals.panel === 'Apply' then

                if second task_fork [statics:'share', 
                        master:'parent'] === 'child' then
                    task_prio 3;
                    task_settitle [-1, 'MOEDivCon PWD Analysis'];

                    //  Destroy current surface
                    heatmapkey = WindowKey 'QB Heat Map';
                    if heatmapkey > 0 then
                       qb_QBPWDCloseHandler [];
                       WindowDestroy heatmapkey;

                        //  Kill child task.
                        if heatmaptask > 0 then
                            task_kill heatmaptask;
                            heatmaptask = 0;
                        endif
                    endif

                    if neL [ftype pwdfilename, 'file']
                            or neL [fext pwdfilename, 'mdb'] then
                        Warning 
                            twrite ['Can\'t find the QMScore/PWD database: {}.',
                            pwdfilename];
                        exit [];
                    endif
                    local acts = db_ReadColumn [pwdfilename, vals.expact_hdr];
                    if isnull acts then
                        Warning twrite ['Missing activities in database: {}.',
                            pwdfilename];
                        exit [];
                    endif

                    pwdopts = tag [first tr QBPWD_OPT_DEFAULTS, [
                        vals.title,
                        vals.analysis, vals.sf_e_ab, vals.sf_e_abp,
                        vals.sf_e_abc, vals.sf_e_r6,
                        vals.sf_e_r12, vals.sf_e_ele, vals.prune_zero,
                        vals.prune_sd, vals.expact_hdr,
                        vals.numtopres, vals.numcomps, vals.trainingset]];
                    SaveOptions [pwdfilename, pwdopts];

                    msgkey = Message [0, 'PWD Analysis is running ...'];
                    local errmess = qb_PWDAnalysis [pwdfilename, G_surface];
                    Message [msgkey, 'PWD Analysis is done.'];
                    if length errmess > 0 then
                        qb_CreateMessWin [errmess, 10, 160];
                    else
                        sleep 2;
                    endif

                    Message [msgkey, []];
                    pwddata = GetAnalData [pwdfilename, vals.title];
                    local dmap = app isnull pwddata;
                    if alltrue dmap then
                        Warning ['PWD Analysis failed.'];
                        WindowSetAttr [wkey, [selbox: [sensitive: 0]]];
                    else
                        dmap = not droplast dmap;
                        WindowSetAttr [wkey, [selbox: [sensitive: 1],
                            analysis: [text: (ANALYSIS | dmap)]]];
                    endif

                    exit [];
                endif

            elseif vals.panel === 'Load' then

                if second task_fork [master: 'parent',
                        statics:'share'] === 'child' then
                    task_prio 0;

                    local tempfile = first FilePrompt [title: 'Load Database', 
                        filter: '*.mdb', allowEmptyList: 0];
                    if not isnull tempfile then
                        if neL [ftype tempfile, 'file']
                                or neL [fext tempfile, 'mdb'] then
                            Warning 
                                twrite ['{}\nis not a QMScore/PWD database.',
                                tempfile];
                            exit [];
                        endif
                        pwdfilename = tempfile;
                        local [ldkey, ldrecs, ldligs, ldcoreopts, ldpwdopts]
                            = LoadDB [pwdfilename];
                        db_Close ldkey;
                        Close [force:1];
                        local idx = 1;
                        
	InitG_surface [];
    //  Make sure initial receptor/ligand is in MOE Window
    LoadMols [pwdfilename];
                        
                                aSetNucleusLook [cat cAtoms G_surface.ligChains, 'small-sphere'];
                                aSetBondLook [cat cAtoms G_surface.ligChains, 'cylinder'];
                                oSetCollection ['QB_LIGAND', cat cAtoms G_surface.ligChains];
                        pro_Align [Chains []];
                        View [];
                        WindowSetData [wkey, ldpwdopts];
                        pwddata = GetAnalData [pwdfilename, vals.title];
                        local datam = app isnull pwddata;
                        if alltrue datam then
                            WindowSetAttr [wkey, [selbox: [sensitive: 0],
                                analbox: [sensitive: 1],
                                panel: [sensitive: [1,1,1]]]];
                        else
                            datam = not droplast datam;
                            WindowSetAttr [wkey, [selbox: [sensitive: 1],
                                analysis: [text: (ANALYSIS | datam)],
                                analbox: [sensitive: 1],
                                panel: [sensitive: [1,1,1]]]];
                        endif

WindowSetAttr [wkey, [sf_e_r12: [sensitive: 0], //DEBUG
sf_e_ele: [sensitive: 0]]];//DEBUG
                    endif

                    exit [];
                endif
            endif
        endif
    endloop

    qb_QBPWDCloseHandler [];
    WindowDestroy wkey;

endfunction

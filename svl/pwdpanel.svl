#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

//    pwdpanel.svl    User-interface entrypoint to QB-PWD calculations

#set title   'QuantumBio PWD'
#set class   'QuantumBio'
#set version '2010.02'
#set main    'qb_QBPWDSetupPanel'

function grid_isoidx_emit;
function msurf_MolecularSurface;
function pboltz_AtomParameters;

function qb_GetAnalysisData;
function qb_GetEnvAnal;
function qb_GetPoseFields;
function qb_LoadCoreScoreDB;
function qb_SaveEnvAnal;
function qb_SplitComplex;

function qb_HeatMapSetupPanel;

const PWD_EXPACT_HDR = 'Exp Act';

const MAT_TRANS_MIN = 0x80;

const QBPWD_OPT_DEFAULTS =
    [
    ['analysis',     1             ],
    ['sf-e-ab',      1             ],
    ['sf-e-abp',     0             ],
    ['sf-e-abc',     0             ],
    ['sf-e-vdw',     0             ],
    ['sf-e-r6',      0             ],
    ['sf-e-r12'      0             ],
    ['sf-e-ele',     0             ],
    ['trainingset',  0             ],
    ['numcomps',     10            ],
    ['numscramble',  10            ],
    ['optLV',        0             ],
    ['optLVval',     0             ],
    ['prune-zero',   0.95          ],
    ['prune-sd',     0.05          ],
    ['numtopres',    25            ]
    ];

const ANALYSIS =
    [
    'PLS Results',
    'SAR',
    'Interaction'
    ];

const ANALKEYS =
    [
    'pls',
    'sar',
    'inter'
    ];

const HEADER = 
    [
    name: 'panel', 
    title: 'QB-PWD',
    windowName: 'QB-PWDPanel',
    text: ['Apply', 'Load', 'Close'],
    onTrigger: ['validate', 'return', 'return'],
    bubbleHelp: ['Generate surface and heat map.',
            'Load QB-PWD analysis results from a QMScore database.', 
            '']
    ];

const PANEL =
    [
    Vbox :
        [
        Hbox :
            [
            Text :
                [
                name: 'trainingset', title: 'Training set size:',
                len: 5, extendH: 0, 
                type: 'int', allowBlank: 0,
                bubbleHelp:
                    'Size of the training set (the first N\n'
                    'receptors and/or ligands are treated\n'
                    'as the training set during PLS analysis.'
                ]
            ]
        ],

        
    Separator : [flushLeft:1, extendH:1, margin:1],

    Vbox :
        [
        Hbox :
            [
            extendH: 1,
            Option :
                [
                name: 'analysis', title: 'Analysis:', text: ANALYSIS,
                type: 'int', minWidth: 8,
                bubbleHelp:
                    ''
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Button :
                [
                name: 'analview', text: 'View',
                bubbleHelp:
                    'View the analytic results (table or heat map).'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Button :
                [
                name: 'analsave', text: 'Save',
                bubbleHelp:
                    'Save the analytic results in a csv file.'
                ]
            ]
        ],
        
    Separator : [flushLeft:1, extendH:1, margin:1],

    Vbox :
        [
        title: 'Heat Map:     ',
        ],

    Separator : [flushLeft:1, extendH:1, margin:1]
    ];

//  Global Variables

    global G_surface;                     // Callback function needs access

//  Local Functions

/****************************************************************************
 *
 *                          CalcDist
 *
 *  Determine a distance that include all residues in heat map.
 *
 ****************************************************************************/
local function CalcDist [restokens, recatoms, ligatoms]

    local atom, dist = 10.0;
    for atom in recatoms loop
        local residue = aResidue atom;
        local restok = twrite ['{}{}', rName residue, rUID residue];
        local idx = indexof [restok, restokens];
        if idx > 0 then
            dist = max [max aDist [atom, ligatoms], dist];
        endif
    endloop

    return dist;

endfunction

function FindResidue;

/****************************************************************************
 *
 *                          CheckResidues
 *
 *  Check whether the residue names and numbers match those present
 *  in the receptor in the MOE Window.
 *
 *  Returns the list of residues tokens not found in the receptor.
 *
 ****************************************************************************/
local function CheckResidues [restoks]

    if MOE_BATCH then return restoks; endif

    local res, missing = [];
    for res in restoks loop
        local [residx, ra] = FindResidue res;
        if residx === 0 then
            missing = append [missing, res];
        endif
    endloop

    return missing;

endfunction

/****************************************************************************
 *
 *                          ClearSurfaceMap
 *
 *  Clear the surface map of the pocket and the residue label.
 *
 *  Acknowledgement:  borrowed heavily from surfmap.svl.
 *
 ****************************************************************************/
local function ClearSurfaceMap [title]

    local gobjs = GKeyList [];
    GDestroy (gobjs | m_findmatch [tok_cat [title,'*'], GTitle gobjs]);

endfunction

/****************************************************************************
 *
 *                          ColorAtoms
 *
 *  Determine the color of the residue atoms based on its interaction with
 *  the ligand.  If ligidx is zero, return all white.
 *
 ****************************************************************************/
local function ColorAtoms [data, ligidx, residx, recatoms, 
        mincut, maxcut, colors]

    if ligidx === 0 then
        return rep [0xFFFFFF, length recatoms];
    endif

    local step = (maxcut - mincut) / (length colors);
    local [titles, restokens, resabbrevs, rowdata] = data;
    local rowvals = third rowdata (ligidx);
    local atom, atomcolors = [];
    for atom in recatoms loop
        local residue = aResidue atom;
        local restok = twrite ['{}{}', rName residue, rUID residue];
        local idx = indexof [restok, restokens];
        if idx > 0 and (residx === 0 or residx === idx) then
            local cidx, value = rowvals (idx);
            if value <= mincut then
                cidx = 1;
            elseif value >= maxcut then
                cidx = length colors;
            else
                cidx = ceil ((value - mincut) / step);
            endif

            atomcolors = append [atomcolors, colors (cidx)];
        else
            atomcolors = append [atomcolors, 0xFFFFFF];  // White
        endif
    endloop

    return atomcolors;

endfunction

/****************************************************************************
 *
 *                          CreateSurfaceMap
 *
 *  Create a surface map of the pocket.
 *
 *  Acknowledgement:  borrowed heavily from surfmap.svl.
 *
 ****************************************************************************/
local function CreateSurfaceMap [restokens]

    const CLASS = 1;  // Connolly
    const RDIST = 10;

    local [recatoms, ligatoms, errmess] = qb_SplitComplex [0];
    if recatoms === [] or ligatoms === [] then
        Warning errmess;
        return [];
    endif

    local dist = CalcDist [restokens, recatoms, ligatoms];
    dist = dist / 2;
write ['Dist:  {}\n', dist];//DEBUG

    local [vdwR, vdwE] = pboltz_AtomParameters recatoms;
    local gridopt = [type: 'Connolly', probe_vdwR: 1.4000, spacing: 0.5, 
        clipmode: 0];

    G_surface =
        [
        title   : 'QB Heat Map',
        class   : CLASS,
        colorby : 'Constant',
        colconst: 0xFFFFFF,            // White
        surfdim : 3,
        trans_f : 96,
        trans_b : 96,
        rec     : recatoms,
        recpos  : aPos recatoms,
        lig     : ligatoms,
        ligpos  : aPos ligatoms,
        ligidx  : 0,
        ligmols : [],
        restok  : '',
        resatms : [],
        dist    : dist,
        rad     : vdwR,
        eps     : vdwE,
        gridopt : gridopt,
		fix     : 0,
        gvtx    : [],
        gobj    : []
        ];

    G_surface.gvtx = msurf_MolecularSurface [G_surface.recpos, 
        G_surface.rad, G_surface.eps, G_surface.ligpos, G_surface.dist, 
        G_surface.gridopt];

    local [s_idx, s_color, s_vpt, s_vnorm] = G_surface.gvtx;
    s_idx = grid_isoidx_emit [s_idx, G_surface.surfdim, -1];
    G_surface.gvtx = poke [G_surface.gvtx, 1, s_idx];

    if add GKey G_surface.gobj then
        GSetTitle [G_surface.gobj, G_surface.title];
        G_surface.gobj = GCreateUnique G_surface.gobj;
    else
        G_surface.gobj = GCreateUnique G_surface.title;
    endif

    local trans = [G_surface.trans_f, G_surface.trans_b];
    GSetTransparency [G_surface.gobj, trans];
    local mat = peek [GMaterial 0, inc alltrue (trans >= MAT_TRANS_MIN)];
    GSetMaterial [G_surface.gobj, mat];
    GVertex [G_surface.gobj, G_surface.surfdim, s_idx, G_surface.colconst,
      s_vpt, s_vnorm];

    aSetNucleusLook [G_surface.lig, 'sphere'];
    View G_surface.lig;

endfunction

/****************************************************************************
 *
 *                          FindResidue
 *
 *  Find the residue with the given name and number in the receptor 
 *  in the MOE Window.
 *
 *  Returns the index of the residue and its atom set.
 *
 ****************************************************************************/
local function FindResidue [restok]

    if MOE_BATCH then return [0, []]; endif

    local residx = 0, resatms = []; 
    local residues = Residues [];
    local resnames = rName residues;
    local rname = tok_keep [restok, 3];
    local [indices] = indicesof [rname, resnames];
    if length indices > 0 then
        local rnum = atoi tok_drop [restok, 3];
        local idx_i = indexof [rnum, rUID residues [indices]];
        if idx_i > 0 then
            residx = indices (idx_i);
            resatms = cat oChildren residues (residx);
        endif
    endif

    return [residx, resatms];

endfunction

/****************************************************************************
 *                          GetAnalData
 *
 *  Get the analysis and repackage for heat map.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
 ****************************************************************************/
local function GetAnalData [dbpath, type]

    if MOE_BATCH then return []; endif

    if neL [ftype dbpath, 'file'] or neL [fext dbpath, 'mdb'] then
        Warning 'The PWD database doesn\'t exist.';
        exit [];
    endif

    local dbkey = db_Open [dbpath, 'read'];
    local data = qb_GetAnalysisData [dbkey, 'pwd', type];
    db_Close dbkey;

    local [resnames, ligdata] = data;
    local resabbrevs = apt tok_drop [resnames, 3];
    local lignames = app first ligdata;
    local ligabbrevs = apt tok_keep [lignames, -3];
    local ligvals = app second ligdata;
    data = [['SAR Map', 'Ligands', 'Residues'], resnames, resabbrevs,
        tr [lignames, ligabbrevs, ligvals]];

    local missing = CheckResidues [second data];
    if length missing > 0 then
        Warning twrite ['The following residues are not \n'
            'present in receptor in MOE Window:\n{v}\n',
            missing];
        exit [];
    endif

    return data;

endfunction

function ReadExpActData;

/****************************************************************************
 *                          LoadDB
 *
 *  Get the core enviroment and application environment.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
 ****************************************************************************/
local function LoadDB [dbpath]

    local [dbkey, recset, ligand, s, coreopts, c, mess] = 
        qb_LoadCoreScoreDB [dbpath, 'qmscore'];
    if dbkey === 0 then
        Warning mess;
        exit [];
    endif

    local pwdopts = qb_GetEnvAnal [dbkey];
    pwdopts = tagcat [pwdopts, tag tr QBPWD_OPT_DEFAULTS];

    ReadExpActData ['~daren/dev/MOEDivcon/data/trypsin-activity-88.txt', dbpath];

    return [dbkey, recset, ligand, coreopts, pwdopts];

endfunction

/****************************************************************************
 *                          LoadLigs
 *
 *  Load the ligands from the PWD database.
 *
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
****************************************************************************/
local function LoadLigs [pwdfilename]

    if MOE_BATCH then return []; endif

    if neL [ftype pwdfilename, 'file'] or neL [fext pwdfilename, 'mdb'] then
        Warning 'The PWD database doesn\'t exist.';
        exit [];
    endif

    local dbkey = db_Open [pwdfilename, 'read'];

    local ligmols = [];
    local rowkey = 0;
    local ligflds = qb_GetPoseFields [dbkey];

    while rowkey = db_NextEntry [dbkey, rowkey] loop
        local [ligmol, ligchg] = db_ReadFields [dbkey, rowkey, ligflds];
        ligmols = append [ligmols, ligmol];
    endloop

    G_surface.ligmols = ligmols;
    db_Close dbkey;

endfunction

/****************************************************************************
 *
 *                          NearestAtomColor
 *
 *  Computes the surface colors as the closest atom colors to the
 *  surface points (weighted by distance).
 *
 *  Local function copied from surfmap.svl (ask CCG to change it to global?).
 *  Note:  the atom colors are based on the interaction between its residue
 *  and the ligand.
 *
 ****************************************************************************/
local function NearestAtomColor [pos, rad, acolor, spos]
    const NAC_BUCKET_SIZE = 4.0;
    const NAC_MAX_POINTS  = 100000;

    const ALPHA = 2.5;
    local maxrad = max [1, max rad];
    local argb = bitand [0xFF, bitshr [[acolor],[16,8,0]]];
    local r = rep [0, l_length spos], g = r, b = r;
    local vsum = rep [0, l_length spos];

    // Do a proximity check to determine the minimum distance
    // that will associate a point with an atom.  NAC_BUCKET_SIZE
    // is the bin size for the search, and so the maximum distance
    // allowed.  We'll use at most NAC_MAX_POINT gridpoints for
    // the check.

    local pprox = prox_open [NAC_BUCKET_SIZE, pos, NAC_BUCKET_SIZE];
    local Upts;

    if length first spos > NAC_MAX_POINTS then
    Upts = apt keep [spos, NAC_MAX_POINTS];
    else
    Upts = spos;
    endif

    local [seg, idx, r2] = prox_find [pprox, Upts, 0];
    local d_ndx = split [idx, seg];
    local min_dist = max app min apt get [[r2], d_ndx];

    prox_close pprox;

    // Use the larger of the caller's and 'found' distances

    maxrad = max [maxrad, sqrt min_dist - 1];
    local sprox = prox_open [1 + maxrad, spos, 1 + maxrad];
    local i;
    for i = 1, l_length pos loop
    [seg, idx, r2] = prox_find [sprox, apt peek [pos, i], 0];
    if not length idx then continue; endif
    local w = exp (-ALPHA * maxE [0, sqrt r2 - 0.95 * rad(i)] );
    vsum[idx] = vsum[idx] + w;
    r[idx] = r[idx] + w * argb(1)(i);
    g[idx] = g[idx] + w * argb(2)(i);
    b[idx] = b[idx] + w * argb(3)(i);
    endloop

    prox_close sprox;

    local vrgb = [r,g,b] * [invz vsum];
    vrgb = maxE [0, minE [0xFF, vrgb]];
    return bitor bitshl [vrgb,[16,8,0]];

endfunction

/****************************************************************************
 *
 *                          ReadExpActData
 *
 *  Read experimental activity data, separated by white space, from the file 
 *  and store it in the given QMScore database in the ExpAct field.  It is
 *  assumed that the orderings are consistent.
 *
 ****************************************************************************/
local function ReadExpActData [expactfn, qmsdbfn]

    local qdbkey = db_Open [qmsdbfn, 'read-write'];
    local eaf = fopenr expactfn;

    db_EnsureField [qdbkey, PWD_EXPACT_HDR, 'double'];
    local rowkey = 0;
    while rowkey = db_NextEntry [qdbkey, rowkey] loop
        local val = fread [eaf, '{n:}'];
        db_Write [qdbkey, rowkey, tag [PWD_EXPACT_HDR, val]];
    endloop

    fclose eaf;
    db_Close qdbkey;

endfunction

/****************************************************************************
 *                          SaveOptions
 *
 *  Save the analysis data.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
 ****************************************************************************/
local function SaveOptions [dbpath, options]

    if MOE_BATCH then return []; endif

    if neL [ftype dbpath, 'file'] or neL [fext dbpath, 'mdb'] then
        Warning 'The PWD database doesn\'t exist.';
        exit [];
    endif

    local dbkey = db_Open [dbpath, 'read-write'];
    local data = qb_SaveEnvAnal [dbkey, options];
    db_Close dbkey;

endfunction

/****************************************************************************
 *
 *                          UpdateComplex
 *
 *  Replace the ligand in the MOE window with the given ligand.
 *
 ****************************************************************************/
local function UpdateComplex [lignum]

    if G_surface.ligidx === lignum then return; endif
    if length G_surface.lig === 0 then return; endif

    local lignuc = aNucleusLook G_surface.lig (1);
    oDestroy uniq oChains G_surface.lig;
    local ligchn = mol_Create G_surface.ligmols (lignum);

    G_surface.lig = cat cAtoms ligchn;
    G_surface.ligidx = lignum;

    oSetCollection ['QB_LIGAND', G_surface.lig];
    aSetNucleusLook [G_surface.lig, lignuc];

endfunction

/****************************************************************************
 *                          UpdateCutoff
 *
 *  Update the window based on new cutoff value.
 *
 ****************************************************************************/
local function UpdateCutoff [wkey, cutoff]

    if cutoff === 0 then
        WindowSetAttr [wkey, [sigma: [sensitive: 0, allowBlank: 1]]];
    else
        WindowSetAttr [wkey, [sigma: [sensitive: 1, allowBlank: 0]]];
    endif
endfunction

/****************************************************************************
 *
 *                          UpdateResidue
 *
 *  Name highlight, and shift the view towards the selected residue.
 *
 *  Acknowledgement:  labeling the residue was borrowed from LabelResidue
 *                    in menu.svl.
 *
 ****************************************************************************/
local function UpdateResidue [restok, row, col, zoom]

    if col === 0 then
        aSetLabelRes [G_surface.resatms, 0];
        G_surface.resatms = [];
        G_surface.restok = '';
        return;
    endif

    if G_surface.restok === restok and row > 0 then return; endif

    aSetLabelRes [G_surface.resatms, 0];

    local [residx, resatms] = FindResidue restok;
    if residx === 0 then return; endif

    G_surface.restok = restok;
    G_surface.resatms = resatms;

	local [idx, m] = sam graph_ccomponent BondGraph resatms;
    local aa;
	for aa in split [resatms [idx], mtoc m] loop
	    aSetLabelRes [sample [aa | graph_center BondGraph aa, 1], 1];
	endloop

    if zoom then
        View resatms;
    endif

endfunction

//  Global Functions

/****************************************************************************
 *
 *                          qb_QBPWDSelectHandler
 *
 ****************************************************************************/
global function qb_QBPWDSelectHandler [data, selrow, selcol, mincut, maxcut,
        colors]
    
    local [titles, resnames, resabbrevs, rowdata] = data;
    local restok = '', ligtok = '', ligabbrev = '', ligdata = [];
    if selrow === 0 and selcol === 0 then
        return;
    elseif selrow === 0 then
        restok = resnames (selcol);
        if selcol > 0 then
            UpdateResidue [restok, selrow, selcol, 1];
            return;
        endif
    elseif selcol === 0 then
        [ligtok, ligabbrev, ligdata] = rowdata (selrow);
    else
        restok = resnames (selcol);
        [ligtok, ligabbrev, ligdata] = rowdata (selrow);
    endif

    ClearSurfaceMap G_surface.title;
    UpdateComplex selrow;
    local atomcolors = ColorAtoms [data, selrow, selcol, G_surface.rec, 
        mincut, maxcut, colors];

	local vcolor = NearestAtomColor [G_surface.recpos, G_surface.rad,
        atomcolors, G_surface.gvtx(3)];

    local [s_idx, s_color, s_vpt, s_vnorm] = G_surface.gvtx;
    if add GKey G_surface.gobj then
        GSetTitle [G_surface.gobj, G_surface.title];
        G_surface.gobj = GCreateUnique G_surface.gobj;
    else
        G_surface.gobj = GCreateUnique G_surface.title;
    endif

    local trans = [G_surface.trans_f, G_surface.trans_b];
    GSetTransparency [G_surface.gobj, trans];
    local mat = peek [GMaterial 0, inc alltrue (trans >= MAT_TRANS_MIN)];
    GSetMaterial [G_surface.gobj, mat];

    GVertex [G_surface.gobj, G_surface.surfdim, s_idx, vcolor,
      s_vpt, s_vnorm];

    UpdateResidue [restok, selrow, selcol, 0];

    if not G_surface.fix then
        View G_surface.lig;
        G_surface.fix = 1;
    endif

endfunction

/****************************************************************************
 *
 *                          qb_QBPWDSetupPanel
 *
 ****************************************************************************/
global function qb_QBPWDSetupPanel []

    const INITLIG = 1;
    const SIGNIFRES = 5;

    static pwdkey;                     //  Shared with child tasks.
    static pwdfilename;
    static pwddata;

    if MOE_BATCH then return; endif
    if WindowShow ['QB-PWDPanel', 1] then return; endif

    local appdflts = tag tr QBPWD_OPT_DEFAULTS;
    local wkey = WindowCreate cat [HEADER, PANEL];
    pwdkey = 0;
    pwdfilename = '';
    pwddata = [[], []];
    G_surface = [];
    WindowSetData [wkey, appdflts];
    WindowShow [wkey, 1];

    loop
        local [vals, trig] = WindowWait wkey;

        if trig === 'cutoff' then
            UpdateCutoff [wkey, vals.cutoff];

        elseif trig === 'panel' then
            if vals.panel === 'Close' then
	            if tok_length pwdfilename > 0 then
                    local pwdopts = tag [first tr QBPWD_OPT_DEFAULTS, [
                            vals.analysis, vals.cutoff, vals.sigma,
                            vals.mapncolors, vals.mapmono, vals.mapnticks]];
                    SaveOptions [pwdfilename, pwdopts];
                endif
                break;

            elseif vals.panel === 'Apply' then

                if second task_fork [statics:'share', 
                        master:'parent'] === 'child' then

                    // Load and setup data
                    if isnull peek [pwddata, vals.analysis] then
                        pwddata = poke [pwddata, vals.analysis, 
                            GetAnalData [pwdfilename, 
                            ANALKEYS (vals.analysis)]];
                    endif

                    //  Create surface if necessary
                    if isnull G_surface then
                        local msgkey = Message [0, 'Calculating surface ...'];
                        CreateSurfaceMap [second pwddata (vals.analysis)];
                        msgkey = Message [msgkey, ''];
                    endif

                    //  Make sure ligand atoms sets are loaded.
                    if isnull G_surface.ligmols then
                        LoadLigs [pwdfilename];
                    endif

                    //  Make sure first ligand is in MOE Window
                    UpdateComplex INITLIG;
                    qb_HeatMapSetupPanel [pwddata (vals.analysis),
                        vals.cutoff, vals.sigma, SIGNIFRES, 
                        vals.mapncolors, vals.mapmono, vals.mapnticks, 
                        'qb_QBPWDSelectHandler', INITLIG, 1];

                    exit [];
                endif

            elseif vals.panel === 'Load' then 
                if second task_fork [master: 'parent',
                        statics:'share'] === 'child' then
                    task_prio 0;

//TODO:  message and disable window while loading

                    pwdfilename = FilePrompt [title: 'Load Database', 
                        filter: '*.mdb', allowEmptyList: 0];
                    if not isnull pwdfilename then
                        pwdfilename = first pwdfilename;
                        local [ldkey, ldrec, ldlig, ldcoreopts, ldpwdopts]
                            = LoadDB [pwdfilename];
                        if neL [ldcoreopts.mode, 'Many-to-Many'] then
                            Close [force:1];
                            if neL [ldrec, []] and neL [ldlig, []] then
                                local ldligmol = mol_Create ldlig;
                                local ldligatoms = cat oAtoms ldligmol;
                                oSetCollection ['QB_LIGAND', ldligatoms];
                                aSetNucleusLook [ldligatoms, 'small-sphere'];
                                aSetBondLook [ldligatoms, 'cylinder'];
                                mol_Create ldrec;
                                View [];
                            endif
                        endif

                        pwdkey = ldkey;
                        db_Close ldkey;
                        WindowSetData [wkey, ldpwdopts];
                    else
                        pwdfilename = '';
                    endif

                    exit [];
                endif
            endif
        endif
    endloop

    ClearSurfaceMap G_surface.title;
    aSetLabelRes [G_surface.resatms, 0];
    G_surface = [];
    WindowDestroy wkey;

endfunction

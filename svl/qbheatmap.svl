#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
	
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

//    qbheatmap.svl    Interactive Heap Map

#set title   'QuantumBio Heat Map'
#set class   'QuantumBio'
#set version '2010.01'

function gr_export;
function gr_print;

//  Colors
const NEG_RANGE_MAX = 896;
const POS_RANGE_MAX = 704;
const MONO_RANGE_MAX = 384;
const G_FACTOR = 256;
const R_FACTOR = 256 * 256;

//  Scale
const SCALE_BOX = 2;
const SCALE_PAD = 10;
const SCALE_CELL_WD = 10;
const SCALE_TICK_LEN = 5;
const SCALE_VAL_LEN = 40;

//  Cells
const CELL_WD = 20;
const CELL_HT = 10;

const MOE_PAD_W = 3.7;
const MOE_PAD_H = 3.0;

const MAX_ROWS = 40;
const MAX_COLS = 30;

//  Data
const DATA_TITLES = 1;
const DATA_COLNAMES = 2;
const DATA_COLABBR = 3;
const DATA_ROWDATA = 4;

//  Titles
const PAGETITLE_H = 16;
const PAGEFONT_H = 12;
const ROWCOLTITLE_H = 14;
const ROWCOLFONT_H = 10;

/******************************************************************************
 *    cutoff : boolean : if true, use the standard deviation to determine
 *          cutoffs; otherwise, use absolute min and max.
 *
 *    sigma : real : the number of standard deviations used to determine the
 *          minimum and maximum values of the color scale.  Values smaller
 *          than the minimum are assigned the same color as the minimum and
 *          values greater than the maximum are assigned the same color as
 *          the maximum.
 *
 *    numcolors : int : the number of different colors used to generate the
 *          color scale for the heat map.
 *
 *    monochrome : boolean : if true, use a single color (red for positive,
 *          blue for negative) to generate the color scale.  Otherwise,
 *          use a rainbow spectrum of colors.
 *
 *    ticks : int : the number of ticks to display on the color scale showing
 *          the values represented by the colors.
 *
 *****************************************************************************/
const OPT_DEFAULTS =
    [
    ['mapradio',     1             ],
    ['cutoff',       1             ],
    ['sigma',        2.0           ],
    ['ncolors',     15             ],
    ['mono',         1             ],
    ['nticks',       5             ]
    ];

//  Window GUI
const HEADER = 
    [
    name: 'panel', 
    title: 'QB Heat Map',
    windowName: 'QB Heat Map',
    text: ['Apply', 'Animate', 'Print', 'Save', 'Close'],
    onTrigger: ['return', 'return', 'return', 'return', 'return']
    ];

const PANEL =
    [
    Vbox :
        [
        Hbox :
            [
            extendH: 1,
            Label :
                [
                extendV: 1, centerV: 1, resizeV: 0, extendH: 0
                ],
            Label :
                [
                name: 'maptitle', shadow: 'none', centerH: 1, margin: 0
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Label :
                [
                extendV: 1, centerV: 1, resizeV: 0, extendH: 0
                ]
            ],
        Hbox :
            [
            extendH: 1,
            Label :
                [
                name: 'rowlbl', extendV: 1, centerV: 1, resizeV: 0,
                grScale: 'none'
                ],
            Radio :
                [
                name: 'mapradio', shadow: 'none', type: 'int',
                margin: 0, font: 'smallBold', onTrigger: 'return'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Label :
                [
                name: 'colorscale', extendV: 0, centerV: 1, resizeV: 0,
                grScale: 'none'
                ]
            ],
        Hbox :
            [
            extendH: 1,
            Label :
                [
                extendV: 1, centerV: 1, resizeV: 0, extendH: 0
                ],
            Label :
                [
                name: 'collbl', shadow: 'none', centerH: 1, margin: 0
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Label :
                [
                extendV: 1, centerV: 1, resizeV: 0, extendH: 0
                ]
            ],

        Separator : [flushLeft:1, extendH:1, margin:1],

        Hbox :
            [
            extendH: 1,
            Checkbox :
                [
                name: 'cutoff', text: 'Cutoff', onTrigger: 'return',
                bubbleHelp:
                    'Determine minimum and maximum cuts using the\n'
                    'standard deviation of a subset of the map data.\n'
                    'Otherwise, use absolute minimum and maximum.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Text :
                [
                name: 'sigma', len: 7,
                title: 'Number of sigmas:',
                type: 'real', allowBlank: 0,
                shortcut: ['1.0', '2.0', '3.0', '4.0', '5.0', '6.0'],
                bubbleHelp: 'Number of standard deviations used to\n'
                    'calculate the minimum and maximum cutoffs.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Text :
                [
                name: 'ncolors', len: 7,
                title: 'Number of colors:',
                type: 'int', allowBlank: 0,
                shortcut: ['3', '7', '15', '31'],
                bubbleHelp: 'Number of distinct colors.'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Checkbox :
                [
                name: 'mono', text: 'Monochromatic',
                bubbleHelp:
                    'Use a monochrome color scheme.'
                ],
            Text :
                [
                name: 'nticks', len: 7,
                title: 'Number of ticks:',
                type: 'int', allowBlank: 0,
                shortcut: ['3', '5', '7', '9'],
                bubbleHelp: 'Number of labeled ticks on color scale.'
                ]
            ],
        Separator : 
            [
            vertical:1, shadow:'noline', extendV: 0, margin:1
            ]
        ]
    ];

//  Local Functions

/****************************************************************************
 *
 *                          Animate
 *
 *  Automatically selects rows, columns or cells.
 *
 ****************************************************************************/
local function Animate [dir, data, numrows, numcols, selfun, mincut, 
        maxcut, colors];

    local selrow, selcol, errmess;
    if dir === 'row' then
        for selrow = 1, numrows, 1 loop
            errmess = call [selfun, [data, selrow, 0, mincut,
                maxcut, colors]];
            if not isnull errmess and neL [errmess, ''] then
                Warning errmess;
                return;
            endif

            sleep 0.5;
        endloop

    elseif dir === 'col' then
        for selcol = 1, numcols, 1 loop
            errmess = call [selfun, [data, 0, selcol, mincut,
                maxcut, colors]];
            if not isnull errmess and neL [errmess, ''] then
                Warning errmess;
                return;
            endif

            sleep 0.5;
        endloop

    elseif dir === 'cell' then
        for selrow = 1, numrows, 1 loop
            for selcol = 1, numcols, 1 loop
                errmess = call [selfun, [data, selrow, selcol, mincut,
                    maxcut, colors]];
                if not isnull errmess and neL [errmess, ''] then
                    Warning errmess;
                    return;
                endif

                sleep 0.5;
            endloop
        endloop
    endif

endfunction

function StandardDeviation;

/****************************************************************************
 *
 *                          CalculateCuts
 *
 *  Determine the minimum and maximum cuts.
 *
 ****************************************************************************/
local function CalculateCuts [data, numsigma, cols, num]

    local rowdata = data (DATA_ROWDATA);
    local row, numbers = [];
    for row in rowdata loop
        numbers = cat [numbers, keep [third row, cols]];
    endloop

    local minnum = min numbers;
    local maxnum = max numbers;
    local [avg, sigma] = StandardDeviation [numbers];

    local mincut, maxcut;
    if minnum === 0 and maxnum > 0 and num > 0 then
        mincut = 0;
        maxcut = 2 * (avg + (numsigma * sigma));
    elseif maxnum === 0 and minnum < 0 and num > 0 then
        mincut  = 2 * (avg - (numsigma * sigma));
        maxcut = 0;
    elseif minnum < 0 and maxnum > 0 and num > 0 then
        mincut = avg - (numsigma * sigma);
        maxcut = avg + (numsigma * sigma);

        //  Adjust so that 0 is in the middle of white
        local dist = maxcut - mincut;
        local step = dist / num;
        mincut = (ceil (mincut / step) - 0.5) * step;
        maxcut = mincut + dist;

    else
        return [[], [], twrite ['Cannot generate minimum and maximum cuts\n'
            'with number of sigmas {}, signifcant columns {}, and number {}\n',
            numsigma, cols, num]];
    endif

    return [mincut, maxcut, ''];

endfunction

/****************************************************************************
 *
 *                          CalculateMinMax
 *
 *  Determine the minimum and maximum cut without standard deviation.
 *
 ****************************************************************************/
local function CalculateMinMax [data, num]

    local rowdata = data (DATA_ROWDATA);
    local numbers = cat app third rowdata;
    local minnum = min numbers;
    local maxnum = max numbers;

    local mincut, maxcut;
    if minnum === 0 and maxnum > 0 and num > 0 then
        mincut = 0;
        maxcut = maxnum;
    elseif maxnum === 0 and minnum < 0 and num > 0 then
        mincut  = minnum;
        maxcut = 0;
    elseif minnum < 0 and maxnum > 0 and num > 0 then
        mincut = minnum;
        maxcut = maxnum;

        //  Adjust so that 0 is in the middle of white
        local dist = maxcut - mincut;
        local step = dist / num;
        mincut = (ceil (mincut / step) - 0.5) * step;
        maxcut = mincut + dist;

    else
        return [[], [], twrite ['Cannot generate minimum and maximum cuts\n'
            'with number {}\n', num]];
    endif

    return [mincut, maxcut, ''];

endfunction

/****************************************************************************
 *
 *                          DrawCell
 *
 *  Returns a graphics object with the appropriate background color
 *  representing its value.
 *
 *  NOTE:  calling function should call gr_destroy on key after using it.
 *
 ****************************************************************************/
local function DrawCell [colors, width, height, mincut, maxcut, value]

    local cidx;
    if value <= mincut then
        cidx = 1;
    elseif value >= maxcut then
        cidx = length colors;
    else
        local step = (maxcut - mincut) / (length colors);
        cidx = ceil ((value - mincut) / step);
    endif

    local key = gr_create [size: [width, height], units: 'pt'];
    gr_box [key, [0, [0, 0], [width , height],
        colors (cidx), 1, colors (cidx)]];

    return key;

endfunction

/****************************************************************************
 *
 *                          DrawCellLabel
 *
 *  Returns a graphics object with the formated text drawn.
 *
 *  NOTE:  calling function should call gr_destroy on key after using it.
 *
 ****************************************************************************/
local function DrawCellLabel [ftext, width, height]

    local key = gr_create [size: [width, height], units: 'pt'];
    gr_text [key, [0, [width/2 , height/2], ftext, 'sys-b', 
        icolor'black', 8, [position: 'middlecenter']]];

    return key;

endfunction

/****************************************************************************
 *
 *                          DrawColorScale
 *
 *  Draws a scale of colors starting with color that represents mincut (blue
 *  or white) at the bottom and ending with the color that represents maxcut
 *  (white or red) at the top.
 *
 *  NOTE:  calling function should call gr_destroy on key after using it.
 *
 ****************************************************************************/
local function DrawColorScale [colors, cell_w, cell_h, mincut, maxcut, ticks]

    local width = cell_w + 40;  // cell + ticks
    local height = cell_h * length colors;
    local key = gr_create [title: 'colorscale',
        size: [width, height  + 2 * SCALE_PAD], units: 'pt'];
    local ith;
    for ith = 1, length colors, 1 loop
        gr_box [key, [0, [0, (ith - 1) * cell_h + SCALE_PAD],
            [cell_w , ith * cell_h  + SCALE_PAD],
            colors (ith), 1, colors (ith)]];
    endloop

    local step = height / (ticks - 1);
    local delta = (maxcut - mincut) / (ticks - 1);
    for ith = 0, ticks - 1, 1 loop
        gr_line [key, [0, [cell_w, ith * step  + SCALE_PAD],
            [cell_w + SCALE_TICK_LEN, ith * step + SCALE_PAD],
            icolor'black', 1]];
        gr_text [key, [0, [cell_w + SCALE_TICK_LEN * 1.5,
            ith * step + SCALE_PAD],
            twrite ['{n:.2f}', mincut + (ith * delta)], 'sys', icolor'black',
            10, [position: 'middleleft']]];
    endloop

    return [key, width, height];

endfunction

/****************************************************************************
 *
 *                          DrawMap
 *
 *  Returns a graphics object containing the Heat Map for printing or
 *  saving to a file in one of the standard formats.
 *
 *  NOTE:  calling function should call gr_destroy on key after using it.
 *
 ****************************************************************************/
local function DrawMap [data, numrows, numcols, mincut, maxcut, colors, ticks]

    local [titles, colnames, colabbrevs, rowdata] = data;

    local colnmlen = (max app tok_length colnames) * 8 + 4;
    local rownmlen = (max app tok_length app first rowdata) * 8 + 4;

    local box_w = numcols * CELL_WD;
    local box_h = numrows * CELL_HT;
    local box_x = ROWCOLTITLE_H + rownmlen;
    local box_y = ROWCOLTITLE_H + colnmlen;

    local cs_h = floor ((box_h - 2 * SCALE_PAD) / length colors);
    local tcs_h = cs_h * length colors;
    local cs_w =  SCALE_CELL_WD;
    local tcs_w = SCALE_PAD + cs_w + SCALE_VAL_LEN;

    local page_w = ROWCOLTITLE_H + rownmlen + box_w + tcs_w;
    local page_h = PAGETITLE_H + box_h + colnmlen + ROWCOLTITLE_H;

    local key = gr_create [size: [page_w, page_h], units: 'pt'];

    //  Color map cells
    local row_i, col_i;
    for row_i = 1, numrows, 1 loop
        local [rowname, rowabbrev, rowvals] = rowdata (row_i);
        local c_y = box_y + (numrows - row_i) * CELL_HT;

        gr_text [key, [0, [ROWCOLTITLE_H + CELL_WD/2 , c_y + CELL_HT/2],
            rowname, 'sys-b', icolor'black', 8, [position: 'middlecenter']]];

        for col_i = 1, numcols, 1 loop
            local cidx, value = rowvals (col_i);
            if value <= mincut then
                cidx = 1;
            elseif value >= maxcut then
                cidx = length colors;
            else
                local step = (maxcut - mincut) / (length colors);
                cidx = ceil ((value - mincut) / step);
            endif

            local c_x = box_x + (col_i - 1) * CELL_WD;
            gr_box [key, [0, [c_x, c_y], [c_x + CELL_WD , c_y + CELL_HT],
                colors (cidx), 1, colors (cidx)]];
        endloop
    endloop

    //  Column labels
    //  HACK ALERT:  make pixmap images 4 times normal size to deal with
    //               anti-aliasing problems.
    local img, bg = rep [rep [0xFFFFFFFF, 4 * colnmlen], 4 * CELL_WD];
    for col_i = 1, numcols, 1 loop
        local colkey = gr_create [size: [4 * colnmlen, 4 * CELL_WD],
            units: 'pt'];
        gr_text [colkey, [0, [4 * 2, 2 * CELL_WD], colnames (col_i), 'sys-b', 
            icolor'black', 4 * 8, [position: 'middleleft']]];
        img = gr_render_pixmap [bg, colkey];
        gr_destroy colkey;
        gr_pixmap [key, [0, [box_x + (col_i - 1) * CELL_WD, box_y],
            [CELL_WD, colnmlen], app reverse tr img]];
    endloop


    //  Draw box
   gr_line [key, [0,
        [[box_x, box_x, box_x + box_w, box_x + box_w],
         [box_y, box_y + box_h, box_y + box_h, box_y]],
        [[box_x, box_x + box_w, box_x + box_w, box_x],
         [box_y + box_h, box_y + box_h, box_y, box_y]],
        icolor'black', 1]];

    //  Center the scale in its alloted space.
    local cs_x = box_x + box_w + SCALE_PAD;
    local cs_y = (box_h - 2 * SCALE_PAD - tcs_h) / 2 + box_y + SCALE_PAD;

    local ith;
    for ith = 1, length colors, 1 loop
        gr_box [key, [0, [cs_x, cs_y + (ith - 1) * cs_h],
            [cs_x + cs_w, ith * cs_h + cs_y],
            colors (ith), 1, colors (ith)]];
    endloop

    //  Draw box around scale
   gr_line [key, [0,
        [[cs_x, cs_x, cs_x + cs_w, cs_x + cs_w],
         [cs_y, cs_y + tcs_h, cs_y + tcs_h, cs_y]],
        [[cs_x, cs_x + cs_w, cs_x + cs_w, cs_x],
         [cs_y + tcs_h, cs_y + tcs_h, cs_y, cs_y]],
        icolor'black', 1]];

    local csstep = tcs_h / (ticks - 1);
    local delta = (maxcut - mincut) / (ticks - 1);


    for ith = 0, ticks - 1, 1 loop
        gr_line [key, [0, [cs_x + cs_w, cs_y + ith * csstep],
            [cs_x + cs_w + SCALE_TICK_LEN, cs_y + ith * csstep],
            icolor'black', 1]];
        gr_text [key, [0, [cs_x + cs_w + SCALE_TICK_LEN * 1.5,
            cs_y + ith * csstep], twrite ['{n:.2f}', mincut + (ith * delta)],
            'sys', icolor'black', 8, [position: 'middleleft']]];
    endloop

    //  Draw titles

    gr_text [key, [0, [box_x + box_w/2, box_y + box_h + PAGETITLE_H/2],
        titles (1), 'sys-b', icolor'black', PAGEFONT_H,
        [position: 'middlecenter']]];
/*
    local rowkey = gr_create [size: [box_h, ROWCOLTITLE_H], units: 'pt'];
    gr_text [rowkey, [0, [box_h/2, ROWCOLTITLE_H/2], titles (2), 'sys-b', 
        icolor'black', ROWCOLFONT_H, [position: 'middlecenter']]];
    bg = rep [rep [0xFFFFFFFF, box_h], ROWCOLTITLE_H];
    img = gr_render_pixmap [bg, rowkey];
    gr_destroy rowkey;
    gr_pixmap [key, [0, [0, box_y + box_h],
        [ROWCOLTITLE_H, box_h], app reverse tr img]];
*/
    //  HACK ALERT:  make pixmap images 4 times normal size to deal with
    //               anti-aliasing problems.
    local rowkey = gr_create [size: [4 * box_h, 4 * ROWCOLTITLE_H], units: 'pt'];
    gr_text [rowkey, [0, [2 * box_h, 2 * ROWCOLTITLE_H], titles (2), 'sys-b', 
        icolor'black', 4 * ROWCOLFONT_H, [position: 'middlecenter']]];
    bg = rep [rep [0xFFFFFFFF, 4 * box_h], 4 * ROWCOLTITLE_H];
    img = gr_render_pixmap [bg, rowkey];
    gr_destroy rowkey;
    gr_pixmap [key, [0, [0, box_y + box_h],
        [ROWCOLTITLE_H, box_h], app reverse tr img]];

    gr_text [key, [0, [box_x + box_w/2, ROWCOLTITLE_H/2], titles (3), 'sys-b', 
        icolor'black', ROWCOLFONT_H, [position: 'middlecenter']]];

    return key;

endfunction

function GetNegColors;
function GetPosColors;

/****************************************************************************
 *
 *                          GetColors
 *
 *  Returns a scale of num colors starting with the color that
 *  represent mincut (blue or white) and ending with the color that
 *  represents maxcut (white or red).
 *
 ****************************************************************************/
local function GetColors [mincut, maxcut, num]

    local colors = [];

    if mincut === 0 and maxcut > 0 and num > 0 then
        colors = GetPosColors [maxcut, num - 1];
    elseif maxcut === 0 and mincut < 0 and num > 0 then
        colors = GetNegColors [mincut, num - 1];
    elseif mincut < 0 and maxcut > 0 and num > 0 then
        local mid = max [1, floor ((num - 1) * (mincut / (mincut - maxcut)))];
        colors = GetNegColors [mincut, mid];
        colors = cat [colors, dropfirst  GetPosColors [maxcut, num - mid - 1]];
    else
        return [[], twrite ['Cannot generate colors with minimum {},\n'
            'maximum {}, and number {}\n', mincut, maxcut, num]];
    endif

    return [colors, ''];

endfunction

/****************************************************************************
 *
 *                          GetHelp
 *
 *  Returns a scale of num colors starting with the color that
 *  represent mincut (blue or white) and ending with the color that
 *  represents maxcut (white or red).
 *
 ****************************************************************************/
local function GetHelp [data]

    local [titles, colnames, ca, rowdata] = data;
    local numcols = length colnames;
    local numrows = length rowdata;

    local row_i, col_i, maphelp = [];
    for row_i = 1, numrows, 1 loop
        local [rowname, ra, rowvals] = rowdata (row_i);
        maphelp = append [maphelp, twrite ['row:  {}', rowname]];
        for col_i = 1, numcols, 1 loop
            maphelp = append [maphelp, twrite ['cell [{}, {}] = {}',
                rowname, colnames (col_i), rowvals (col_i)]];
        endloop
    endloop

    maphelp = append [maphelp, 'empty cell'];
    for col_i = 1, numcols, 1 loop
        maphelp = append [maphelp, twrite ['col:  {}', colnames (col_i)]];
    endloop

    return maphelp;
endfunction

/****************************************************************************
 *
 *                          GetNegColors
 *
 *  Return num number of scaled colors, plus white, ordered from blue to white.
 *
 ****************************************************************************/
local function GetNegColors [mincut, num]

    local colors = [], newcolor;
    local r, g, b;
    local delta = floor (NEG_RANGE_MAX / num);

    //  Blue
    r = 0; g = 0; b = 127;
    while b < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        b = b + delta;
    endloop

    //  Turquoise
    g = b - 256; r = 0; b = 255;
    while g < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        g = g + delta;
    endloop

    //  Aquamarine
    b = 256 - (g - 256); r = 0; g = 255;
    while b >= 0 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        b = b - delta;
    endloop

    //  Green
    r = -b; g = 255; b = 0;
    while r < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        r = r + delta;
    endloop

    if length colors > num then
        colors = drop [colors, num - length colors];
    endif

    //  White
    r = 255; g = 255; b = 255;
    newcolor = r * R_FACTOR + g * G_FACTOR + b;
    colors = append [colors, newcolor];

    return colors;

endfunction

/****************************************************************************
 *
 *                          GetPosColors
 *
 *  Return num number of scaled colors, plus white, ordered from white to red.
 *
 ****************************************************************************/
local function GetPosColors [maxcut, num]

    local colors = [], newcolor;
    local r, g, b;
    local delta = floor (POS_RANGE_MAX / num);

    //  Since we prefer darker colors, build red to white and then reverse.
    //  Maroon
    r = 95; g = 0; b = 95;
    while r < 128 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        r = r + delta;
        b = b + delta;
    endloop

    //  Red
     r = 127 + r - 128; g = 0; b = 0;
    while r < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        r = r + delta;
    endloop
    
    //  Orange
    g = r - 256; r = 255; b = 0;
    while g < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        g = g + delta;
    endloop

    //  Yellow
     b = g - 256; r = 255; g = 255;
    while b < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        b = b + delta;
    endloop

    if length colors > num then
        colors = drop [colors, num - length colors];
    endif

    //  White
    r = 255; g = 255; b = 255;
    newcolor = r * R_FACTOR + g * G_FACTOR + b;
    colors = append [colors, newcolor];

    return reverse colors;
endfunction

function GetMonoNegColors;
function GetMonoPosColors;

/****************************************************************************
 *
 *                          GetMonoColors
 *
 *  Returns a scale of num colors starting with the color that
 *  represent mincut (blue or white) and ending with the color that
 *  represents maxcut (white or red).
 *
 ****************************************************************************/
local function GetMonoColors [mincut, maxcut, num]

    local colors = [];

    if mincut === 0 and maxcut > 0 and num > 0 then
        colors = GetMonoPosColors [maxcut, num - 1];
    elseif maxcut === 0 and mincut < 0 and num > 0 then
        colors = GetMonoNegColors [mincut, num - 1];
    elseif mincut < 0 and maxcut > 0 and num > 0 then
        local mid = max [1, floor ((num - 1) * (mincut / (mincut - maxcut)))];
        colors = GetMonoNegColors [mincut, mid];
        colors = cat [colors, dropfirst  GetMonoPosColors [maxcut,
            num - mid - 1]];
    else
        return [[], twrite ['Cannot generate colors with minimum {},\n'
            'maximum {}, and number {}\n', mincut, maxcut, num]];
    endif

    return [colors, ''];

endfunction

/****************************************************************************
 *
 *                          GetMonoNegColors
 *
 *  Return num number of scaled colors, plus white, ordered from blue to white.
 *
 ****************************************************************************/
local function GetMonoNegColors [mincut, num]

    local colors = [], newcolor;
    local r, g, b;
    local delta = floor (MONO_RANGE_MAX / num);

    //  Dark Blue
    r = 0; g = 0; b = 127;
    while b < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        b = b + delta;
    endloop


    //  Light Blue
    g = b - 256; r = b - 256; b = 255;
    while g < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        g = g + delta;
        r = r + delta;
    endloop


    if length colors > num then
        colors = drop [colors, num - length colors];
    endif

    //  White
    r = 255; g = 255; b = 255;
    newcolor = r * R_FACTOR + g * G_FACTOR + b;
    colors = append [colors, newcolor];

    return colors;

endfunction

/****************************************************************************
 *
 *                          GetMonoPosColors
 *
 *  Return num number of scaled colors, plus white, ordered from white to red.
 *
 ****************************************************************************/
local function GetMonoPosColors [maxcut, num]

    local colors = [], newcolor;
    local r, g, b;
    local delta = floor (MONO_RANGE_MAX / num);

    //  Since we prefer darker colors, build red to white and then reverse.

    //  Dark Red
     r = 127; g = 0; b = 0;
    while r < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        r = r + delta;
    endloop
    
    //  Light Red
     g = r - 255; b = r - 255; r = 255; 
    while g < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        g = g + delta;
        b = b + delta;
    endloop
    
    if length colors > num then
        colors = drop [colors, num - length colors];
    endif

    //  White
    r = 255; g = 255; b = 255;
    newcolor = r * R_FACTOR + g * G_FACTOR + b;
    colors = append [colors, newcolor];

    return reverse colors;
endfunction

/****************************************************************************
 *
 *                          IndexToRowCol
 *
 *  Return the selected row and column numbers.  Selected rows have selcol = 0
 *  and selected columns have selrow = 0.  
 *
 ****************************************************************************/
local function IndexToRowCol [index, numrows, numcols]

    local selrow = ceil (index / (numcols + 1));
    if selrow === numrows + 1 then
        selrow = 0;
    endif

    local selcol = mod [index, numcols + 1] - 1;
    selcol = select [numcols, selcol, selcol === -1];

    return [selrow, selcol];

endfunction

/****************************************************************************
 *
 *                          RedrawMapScale
 *
 *  Redraw the Heat Map and Scale with new parameters.  
 *
 ****************************************************************************/
local function RedrawMapScale [data, opts, numsignifcols, mincut, maxcut,
        colors, force]

    static prevcutoff, prevsigma, prevncolors, prevmono, prevnticks;

    local drawmap = 0, drawscale = 0;
    local newmap = [], newscale = [];

    if force then
        drawmap = 1; drawscale = 1;
    elseif anytrue neE [[prevcutoff, prevsigma, prevncolors, prevmono],
        [opts.cutoff, opts.sigma, opts.ncolors, opts.mono]] then
        drawmap = 1; drawscale = 1;
    elseif neL [prevnticks, opts.nticks] then
        drawscale = 1;
    else
        return [newmap, newscale, mincut, maxcut, colors];
    endif

    local [titles, colnames, colabbrevs, rowdata] = data;
    local numcols = length colnames;
    local numrows = length rowdata;
    local page_w = (numcols + 1) * (CELL_WD + MOE_PAD_W) + MOE_PAD_W;
    local page_h = (numrows + 1) * (CELL_HT + MOE_PAD_H) + MOE_PAD_H;
    local errmess;

    if drawmap then
        if opts.cutoff then
            [mincut, maxcut, errmess] = CalculateCuts [data, opts.sigma, 
                numsignifcols, opts.ncolors];
            if mincut === [] or maxcut === [] then
                Warning errmess;
                return  [newmap, newscale, mincut, maxcut, colors];
            endif
        else
            [mincut, maxcut, errmess] = CalculateMinMax [data, opts.ncolors];
            if mincut === [] or maxcut === [] then
                Warning errmess;
                return  [newmap, newscale, mincut, maxcut, colors];
            endif
        endif

        if opts.mono then
            [colors, errmess] = GetMonoColors [mincut, maxcut, opts.ncolors];
        else
            [colors, errmess] = GetColors [mincut, maxcut, opts.ncolors];
        endif

        if colors === [] then
            Warning errmess;
            return [newmap, newscale, mincut, maxcut, colors];
        endif

        //  Color map cells and store row labels
        local row_i, col_i, bgraphics = [];
        for row_i = 1, numrows, 1 loop
            local [rowname, rowabbrev, rowvals] = rowdata (row_i);
            bgraphics = append [bgraphics, 
                DrawCellLabel [tok_keep [rowabbrev, 3], CELL_WD, CELL_HT]];
            for col_i = 1, numcols, 1 loop
                bgraphics = append [bgraphics, DrawCell [colors, 
                    CELL_WD, CELL_HT, mincut, maxcut, rowvals (col_i)]];
            endloop
        endloop

        //  Empty corner label
        bgraphics = append [bgraphics, 0];

        //  Column labels
        for col_i = 1, numcols, 1 loop
            bgraphics = append [bgraphics, 
                DrawCellLabel [tok_keep [colabbrevs (col_i), 3],
                    CELL_WD, CELL_HT]];
        endloop

        newmap = bgraphics;
    endif

    if drawscale then
        local scalecell_h = floor (page_h / opts.ncolors);
        local scalecell_w =  SCALE_CELL_WD;
        local [scalekey, s_w, s_h] = DrawColorScale [colors, scalecell_w,
            scalecell_h, mincut, maxcut, opts.nticks];
        newscale = scalekey;
    endif

    prevcutoff = opts.cutoff;
    prevsigma = opts.sigma;
    prevncolors = opts.ncolors;
    prevmono = opts.mono;
    prevnticks = opts.nticks;

    return [newmap, newscale, mincut, maxcut, colors];
endfunction

/****************************************************************************
 *
 *                          StandardDeviation
 *
 *  Return the average and standard deviation of the flat vector of numbers.
 *
 ****************************************************************************/
local function StandardDeviation [nums]

    local n = length nums;
    if n === 0 then
        return 0;
    endif
    local avg = (add nums) / n;
    local sigma = sqrt ((add (sqr (nums - avg))) / n);

    return [avg, sigma];

endfunction

/****************************************************************************
 *
 *                          TruncateCols
 *
 *  Return the data with only the first MAX_COLS columns of data.
 *
 ****************************************************************************/
local function TruncateCols [data]

    local [titles, resnames, resabbrevs, rowdata] = data;
    if length resnames <= MAX_COLS then
        return data;
    endif

    local truncresnames = keep [resnames, MAX_COLS];
    local truncresabbrevs = keep [resabbrevs, MAX_COLS];
    local row, trunclignames = [], truncligabbrevs = [], truncrowvals = [];
    for row in rowdata loop
        local [ligname, ligabbrev, rowvals] = row;
        trunclignames = append [trunclignames, ligname];
        truncligabbrevs = append [truncligabbrevs, ligabbrev];
        truncrowvals = append [truncrowvals, keep [rowvals, MAX_COLS]];
    endloop

    local truncdata = [titles, truncresnames, truncresabbrevs,
        tr [trunclignames, truncligabbrevs, truncrowvals]];

    return truncdata;

endfunction

/****************************************************************************
 *
 *                          TruncateRows
 *
 *  Return the data with only the first MAX_ROWS rows of data.
 *
 ****************************************************************************/
local function TruncateRows [data]

    local [titles, resnames, resabbrevs, rowdata] = data;
    return [titles, resnames, resabbrevs, keep [rowdata, MAX_ROWS]];

endfunction

/****************************************************************************
 *                          UpdateCutoff
 *
 *  Update the window based on new cutoff value.
 *
 ****************************************************************************/
local function UpdateCutoff [wkey, cutoff]

    if cutoff === 0 then
        WindowSetAttr [wkey, [sigma: [sensitive: 0, allowBlank: 1]]];
    else
        WindowSetAttr [wkey, [sigma: [sensitive: 1, allowBlank: 0]]];
    endif
endfunction


//  Global Functions

/****************************************************************************
 *
 *                          qb_HeatMapSetupPanel
 *
 *  Parameters:
 *
 *    data : vector : the data to display in heat map.  It has the format:
 *          [ 
 *            [mapTitle, rowTitle, colTitle], [colNames], [colAbbrevs], 
 *            [
 *              [rowName1, rowAbbrev1, [values1]],
 *              [rowName2, rowAbbrev2, [values2]],
 *              ... , 
 *              [rowNameN, rowAbbrevN, [valuesN]]
 *            ]
 *          ]
 *          where length colNames === length colAbbrevs === length values1
 *          ===  ... === length valuesN; the titles, names and abbreviations
 *          are tokens; and the values are numbers. Only the first three
 *          characters of the abbreviations are used for the labels.
 *
 *    numsignifcols : int : the number of significant columns used to
 *          calculate the standard deviation.
 *
 *    selfun : token : the name of the global function to call when the user
 *          selects a row, column or cell of the heat map.  The function is
 *          passed the following parameters: data, selrow, selcol, mincut,
 *          maxcut and colors.  Selected cells have selrow from 1 to numrows
 *          selcol from 1 to numcols.  Selected rows have selcol = 0 and
 *          selected columns have selrow = 0.  If the function returns an
 *          error message (token), it is displayed using Warning [].
 *
 *    initsel : int : the initial selection.  It is the index into the
 *          radio buttons generated using the above data.
 *
 *    help : boolean : if true, show in the bubble help for each button
 *          the full row label, full column label and cell value.
 *
 ****************************************************************************/
global function qb_HeatMapSetupPanel [data, numsignifcols, selfun, initsel,
        help, closefun]
    static selrow, selcol;

    if MOE_BATCH then return; endif
    if WindowShow ['QB Heat Map', 1] then return; endif

    local bgraphics = [], scalekey = [], mincut = [], maxcut = [], colors = [];
    local optdflts = tag tr OPT_DEFAULTS;
    optdflts.mapradio = initsel;
    selrow = initsel; selcol = 0;

    //  Currently, only 30 columns and 40 rows are allowed.
    data = TruncateCols [data];
    data = TruncateRows [data];
    local [titles, colnames, colabbrevs, rowdata] = data;
    local numcols = length colnames;
    local numrows = length rowdata;
    local page_w = (numcols + 1) * (CELL_WD + MOE_PAD_W) + MOE_PAD_W;
    local page_h = (numrows + 1) * (CELL_HT + MOE_PAD_H) + MOE_PAD_H;

    [bgraphics, scalekey, mincut, maxcut, colors]
        = RedrawMapScale [data, optdflts, numsignifcols, mincut, maxcut,
        colors, 1];

    local bhelp = [];
    if help then
        bhelp = GetHelp [data];
    endif

    //  Create title labels
    local mapkey = gr_create [size: [page_w, PAGETITLE_H], units: 'pt'];
    gr_text [mapkey, [0, [page_w/2, PAGETITLE_H/2], titles (1), 'sys-b', 
        icolor'black', PAGEFONT_H, [position: 'middlecenter']]];

    //  HACK ALERT:  make pixmap images 4 times normal size to deal with
    //               anti-aliasing problems.
    local rowkey = gr_create [size: [4 * page_h, 4 * ROWCOLTITLE_H],
        units: 'pt'];
    gr_text [rowkey, [0, [2 * page_h, 2 * ROWCOLTITLE_H], titles (2), 'sys-b', 
        icolor'black', 4 * ROWCOLFONT_H, [position: 'middlecenter']]];
    local bg = rep [rep [0xFFFFFFFF, 4 * page_h], 4 * ROWCOLTITLE_H];
    local img = gr_render_pixmap [bg, rowkey];
    gr_destroy rowkey;
    rowkey = gr_create [size: [ROWCOLTITLE_H, page_h], units: 'pt'];
    gr_pixmap [rowkey, [0, [0, page_h],
        [ROWCOLTITLE_H, page_h], app reverse tr img]];

    local colkey = gr_create [size: [page_w, ROWCOLTITLE_H], units: 'pt'];
    gr_text [colkey, [0, [page_w/2, ROWCOLTITLE_H/2], titles (3), 'sys-b', 
        icolor'black', ROWCOLFONT_H, [position: 'middlecenter']]];

    local wkey = WindowCreate cat [HEADER, PANEL];
    WindowSetData [wkey, optdflts];
    WindowSetAttr [wkey, [colorscale: [graphics: scalekey], 
        mapradio: [graphics: bgraphics, columns: numcols + 1,
        bubbleHelp: bhelp], maptitle: [graphics: mapkey],
        rowlbl: [graphics: rowkey], collbl: [graphics: colkey]]];
    WindowShow [wkey, 1];

    gr_destroy mapkey;
    gr_destroy rowkey;
    gr_destroy colkey;
    gr_destroy scalekey;
    app gr_destroy bgraphics;

    [selrow, selcol] = IndexToRowCol [initsel, numrows, numcols];
    local selerrmess = call [selfun, [data, selrow, selcol, mincut,
        maxcut, colors]];
    if not isnull selerrmess and neL [selerrmess, ''] then
        WindowDestroy wkey;
        Warning selerrmess;
        return;
    endif

    loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'panel' then
            if vals.panel === 'Close' then
                local closeerrmess = call [closefun, []];
                if not isnull closeerrmess and neL [closeerrmess, ''] then
                    Warning closeerrmess;
                endif
                break;

            elseif vals.panel === 'Save' then
                local simgkey = DrawMap [data, numrows, numcols, mincut, 
                    maxcut, colors, vals.nticks];
                gr_export simgkey;
                gr_destroy simgkey;

            elseif vals.panel === 'Print' then
                local pimgkey = DrawMap [data, numrows, numcols, mincut, 
                    maxcut, colors, vals.nticks];
                gr_print pimgkey;
                gr_destroy pimgkey;

            elseif vals.panel === 'Animate' then
                WindowShow [wkey, 0];
                Animate ['row', data, numrows, numcols, selfun, mincut, 
                    maxcut, colors];
                WindowShow [wkey, 1];

            elseif vals.panel === 'Apply' then
                [bgraphics, scalekey, mincut, maxcut, colors]
                    = RedrawMapScale [data, vals, numsignifcols, mincut,
                    maxcut, colors, 0];

                if not isnull bgraphics then
                     WindowSetAttr [wkey, [mapradio: [graphics: bgraphics]]];
                endif

                if not isnull scalekey then
                     WindowSetAttr [wkey, [colorscale: [graphics: scalekey]]];
                endif

                selerrmess = call [selfun, [data, selrow, selcol, mincut,
                    maxcut, colors]];
                if not isnull selerrmess and neL [selerrmess, ''] then
                    Warning selerrmess;
                    break;
                endif
            endif

        elseif trig === 'cutoff' then
            UpdateCutoff [wkey, vals.cutoff];

        elseif trig === 'mapradio' then
            [selrow, selcol] = IndexToRowCol [vals.mapradio, numrows, numcols];
            selerrmess = call [selfun, [data, selrow, selcol, mincut,
                maxcut, colors]];
            if not isnull selerrmess and neL [selerrmess, ''] then
                Warning selerrmess;
                break;
            endif
        endif
    endloop

    WindowDestroy wkey;

endfunction


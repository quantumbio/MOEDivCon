#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
	
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

//    qbheatmap.svl    Interactive Heap Map

#set title   'QuantumBio Heat Map'
#set class   'QuantumBio'
#set version '2010.01'

function gr_export;
function gr_print;

//  Colors
const NEG_RANGE_MAX = 896;
const POS_RANGE_MAX = 704;
const MONO_RANGE_MAX = 384;
const G_FACTOR = 256;
const R_FACTOR = 256 * 256;

//  Scale
const SCALE_BOX = 2;
const SCALE_PAD = 10;
const SCALE_CELL_WD = 10;
const SCALE_TICK_LEN = 5;
const SCALE_VAL_LEN = 40;

//  Cells
const CELL_WD = 20;
const CELL_HT = 10;

const MOE_PAD_W = 3.7;
const MOE_PAD_H = 3.0;

const MAX_ROWS = 40;
const MAX_COLS = 30;

//  Data
const DATA_TITLES = 1;
const DATA_COLNAMES = 2;
const DATA_COLABBR = 3;
const DATA_ROWDATA = 4;

//  Titles
const PAGETITLE_H = 16;
const PAGEFONT_H = 12;
const ROWCOLTITLE_H = 14;
const ROWCOLFONT_H = 10;

//  Window GUI
const HEADER = 
    [
    name: 'panel', 
    title: 'QB Heat Map',
    windowName: 'QB Heat Map',
    text: ['Animate', 'Print', 'Save', 'Close'],
    onTrigger: ['return', 'return', 'return', 'return']
    ];

const PANEL =
    [
    Vbox :
        [
        Hbox :
            [
            extendH: 1,
            Label :
                [
                extendV: 1, centerV: 1, resizeV: 0, extendH: 0
                ],
            Label :
                [
                name: 'maptitle', shadow: 'none', centerH: 1, margin: 0
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Label :
                [
                extendV: 1, centerV: 1, resizeV: 0, extendH: 0
                ]
            ],
        Hbox :
            [
            extendH: 1,
            Label :
                [
                name: 'rowlbl', extendV: 1, centerV: 1, resizeV: 0,
                grScale: 'none'
                ],
            Radio :
                [
                name: 'mapradio', shadow: 'none', type: 'int',
                margin: 0, font: 'smallBold', onTrigger: 'return'
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Label :
                [
                name: 'colorscale', extendV: 0, centerV: 1, resizeV: 0,
                grScale: 'none'
                ]
            ],
        Hbox :
            [
            extendH: 1,
            Label :
                [
                extendV: 1, centerV: 1, resizeV: 0, extendH: 0
                ],
            Label :
                [
                name: 'collbl', shadow: 'none', centerH: 1, margin: 0
                ],
            Separator : 
                [
                vertical:0, shadow:'noline', extendH: 0, margin:1
                ],
            Label :
                [
                extendV: 1, centerV: 1, resizeV: 0, extendH: 0
                ]
            ]
        ]
    ];

//  Local Functions

/****************************************************************************
 *
 *                          Animate
 *
 *  Automatically selects rows, columns or cells.
 *
 ****************************************************************************/
local function Animate [dir, data, numrows, numcols, selfun, mincut, 
        maxcut, colors];

    local selrow, selcol, errmess;
    if dir === 'row' then
        for selrow = 1, numrows, 1 loop
            errmess = call [selfun, [data, selrow, 0, mincut,
                maxcut, colors]];
            if not isnull errmess and neL [errmess, ''] then
                Warning errmess;
                return;
            endif

            sleep 0.5;
        endloop

    elseif dir === 'col' then
        for selcol = 1, numcols, 1 loop
            errmess = call [selfun, [data, 0, selcol, mincut,
                maxcut, colors]];
            if not isnull errmess and neL [errmess, ''] then
                Warning errmess;
                return;
            endif

            sleep 0.5;
        endloop

    elseif dir === 'cell' then
        for selrow = 1, numrows, 1 loop
            for selcol = 1, numcols, 1 loop
                errmess = call [selfun, [data, selrow, selcol, mincut,
                    maxcut, colors]];
                if not isnull errmess and neL [errmess, ''] then
                    Warning errmess;
                    return;
                endif

                sleep 0.5;
            endloop
        endloop
    endif

endfunction

function StandardDeviation;

/****************************************************************************
 *
 *                          CalculateCuts
 *
 *  Determine the minimum and maximum cuts.
 *
 ****************************************************************************/
local function CalculateCuts [data, cutoff, cols, num]

    local rowdata = data (DATA_ROWDATA);
    local row, numbers = [];
    for row in rowdata loop
        numbers = cat [numbers, keep [third row, cols]];
    endloop

    local minnum = min numbers;
    local maxnum = max numbers;
    local [avg, sigma] = StandardDeviation [numbers];

write ['A: {}, S: {}\n', avg, sigma];//DEBUG

    local mincut, maxcut;
    if minnum === 0 and maxnum > 0 and num > 0 then
        mincut = 0;
        maxcut = 2 * (avg + (cutoff * sigma));
    elseif maxnum === 0 and minnum < 0 and num > 0 then
        mincut  = 2 * (avg - (cutoff * sigma));
        maxcut = 0;
    elseif minnum < 0 and maxnum > 0 and num > 0 then
        mincut = avg - (cutoff * sigma);
        maxcut = avg + (cutoff * sigma);

        //  Adjust so that 0 is in the middle of white
        local dist = maxcut - mincut;
        local step = dist / num;
        mincut = (ceil (mincut / step) - 0.5) * step;
        maxcut = mincut + dist;

    else
        return [[], [], twrite ['Cannot generate minimum and maximum cuts\n'
            'with cutoff {}, signifcant columns {}, and number {}\n',
            cutoff, cols, num]];
    endif

    return [mincut, maxcut, ''];

endfunction

/****************************************************************************
 *
 *                          DrawCell
 *
 *  Returns a graphics object with the appropriate background color
 *  representing its value.
 *
 *  NOTE:  calling function should call gr_destroy on key after using it.
 *
 ****************************************************************************/
local function DrawCell [colors, width, height, mincut, maxcut, value]

    local cidx;
    if value <= mincut then
        cidx = 1;
    elseif value >= maxcut then
        cidx = length colors;
    else
        local step = (maxcut - mincut) / (length colors);
        cidx = ceil ((value - mincut) / step);
    endif

    local key = gr_create [size: [width, height], units: 'pt'];
    gr_box [key, [0, [0, 0], [width , height],
        colors (cidx), 1, colors (cidx)]];

    return key;

endfunction

/****************************************************************************
 *
 *                          DrawCellLabel
 *
 *  Returns a graphics object with the formated text drawn.
 *
 *  NOTE:  calling function should call gr_destroy on key after using it.
 *
 ****************************************************************************/
local function DrawCellLabel [ftext, width, height]

    local key = gr_create [size: [width, height], units: 'pt'];
    gr_text [key, [0, [width/2 , height/2], ftext, 'sys-b', 
        icolor'black', 8, [position: 'middlecenter']]];

    return key;

endfunction

/****************************************************************************
 *
 *                          DrawColorScale
 *
 *  Draws a scale of colors starting with color that represents mincut (blue
 *  or white) at the bottom and ending with the color that represents maxcut
 *  (white or red) at the top.
 *
 *  NOTE:  calling function should call gr_destroy on key after using it.
 *
 ****************************************************************************/
local function DrawColorScale [colors, cell_w, cell_h, mincut, maxcut, ticks]

    local width = cell_w + 40;  // cell + ticks
    local height = cell_h * length colors;
    local key = gr_create [title: 'colorscale',
        size: [width, height  + 2 * SCALE_PAD], units: 'pt'];
    local ith;
    for ith = 1, length colors, 1 loop
        gr_box [key, [0, [0, (ith - 1) * cell_h + SCALE_PAD],
            [cell_w , ith * cell_h  + SCALE_PAD],
            colors (ith), 1, colors (ith)]];
    endloop

    local step = height / (ticks - 1);
    local delta = (maxcut - mincut) / (ticks - 1);
    for ith = 0, ticks - 1, 1 loop
        gr_line [key, [0, [cell_w, ith * step  + SCALE_PAD],
            [cell_w + SCALE_TICK_LEN, ith * step + SCALE_PAD],
            icolor'black', 1]];
        gr_text [key, [0, [cell_w + SCALE_TICK_LEN * 1.5,
            ith * step + SCALE_PAD],
            twrite ['{n:.2f}', mincut + (ith * delta)], 'sys', icolor'black',
            10, [position: 'middleleft']]];
    endloop

    return [key, width, height];

endfunction

/****************************************************************************
 *
 *                          DrawMap
 *
 *  Returns a graphics object containing the Heat Map for printing or
 *  saving to a file in one of the standard formats.
 *
 *  NOTE:  calling function should call gr_destroy on key after using it.
 *
 ****************************************************************************/
local function DrawMap [data, numrows, numcols, mincut, maxcut, colors, ticks]

    local [titles, colnames, colabbrevs, rowdata] = data;

    local colnmlen = (max app tok_length colnames) * 8 + 4;
    local rownmlen = (max app tok_length app first rowdata) * 8 + 4;

    local box_w = numcols * CELL_WD;
    local box_h = numrows * CELL_HT;
    local box_x = ROWCOLTITLE_H + rownmlen;
    local box_y = ROWCOLTITLE_H + colnmlen;

    local cs_h = floor ((box_h - 2 * SCALE_PAD) / length colors);
    local tcs_h = cs_h * length colors;
    local cs_w =  SCALE_CELL_WD;
    local tcs_w = SCALE_PAD + cs_w + SCALE_VAL_LEN;

    local page_w = ROWCOLTITLE_H + rownmlen + box_w + tcs_w;
    local page_h = PAGETITLE_H + box_h + colnmlen + ROWCOLTITLE_H;

    local key = gr_create [size: [page_w, page_h], units: 'pt'];

    //  Color map cells
    local row_i, col_i;
    for row_i = 1, numrows, 1 loop
        local [rowname, rowabbrev, rowvals] = rowdata (row_i);
        local c_y = box_y + (numrows - row_i) * CELL_HT;

        gr_text [key, [0, [ROWCOLTITLE_H + CELL_WD/2 , c_y + CELL_HT/2],
            rowname, 'sys', icolor'black', 8, [position: 'middlecenter']]];

        for col_i = 1, numcols, 1 loop
            local cidx, value = rowvals (col_i);
            if value <= mincut then
                cidx = 1;
            elseif value >= maxcut then
                cidx = length colors;
            else
                local step = (maxcut - mincut) / (length colors);
                cidx = ceil ((value - mincut) / step);
            endif

            local c_x = box_x + (col_i - 1) * CELL_WD;
            gr_box [key, [0, [c_x, c_y], [c_x + CELL_WD , c_y + CELL_HT],
                colors (cidx), 1, colors (cidx)]];
        endloop
    endloop

    //  Column labels
    //  HACK ALERT:  make pixmap images 4 times normal size to deal with
    //               anti-aliasing problems.
    local img, bg = rep [rep [0xFFFFFFFF, 4 * colnmlen], 4 * CELL_WD];
    for col_i = 1, numcols, 1 loop
        local colkey = gr_create [size: [4 * colnmlen, 4 * CELL_WD],
            units: 'pt'];
        gr_text [colkey, [0, [4 * 2, 2 * CELL_WD], colnames (col_i), 'sys', 
            icolor'black', 4 * 8, [position: 'middleleft']]];
        img = gr_render_pixmap [bg, colkey];
        gr_destroy colkey;
        gr_pixmap [key, [0, [box_x + (col_i - 1) * CELL_WD, box_y],
            [CELL_WD, colnmlen], app reverse tr img]];
    endloop


    //  Draw box
   gr_line [key, [0,
        [[box_x, box_x, box_x + box_w, box_x + box_w],
         [box_y, box_y + box_h, box_y + box_h, box_y]],
        [[box_x, box_x + box_w, box_x + box_w, box_x],
         [box_y + box_h, box_y + box_h, box_y, box_y]],
        icolor'black', 1]];

    //  Center the scale in its alloted space.
    local cs_x = box_x + box_w + SCALE_PAD;
    local cs_y = (box_h - 2 * SCALE_PAD - tcs_h) / 2 + box_y + SCALE_PAD;

    local ith;
    for ith = 1, length colors, 1 loop
        gr_box [key, [0, [cs_x, cs_y + (ith - 1) * cs_h],
            [cs_x + cs_w, ith * cs_h + cs_y],
            colors (ith), 1, colors (ith)]];
    endloop

    //  Draw box around scale
   gr_line [key, [0,
        [[cs_x, cs_x, cs_x + cs_w, cs_x + cs_w],
         [cs_y, cs_y + tcs_h, cs_y + tcs_h, cs_y]],
        [[cs_x, cs_x + cs_w, cs_x + cs_w, cs_x],
         [cs_y + tcs_h, cs_y + tcs_h, cs_y, cs_y]],
        icolor'black', 1]];

    local csstep = tcs_h / (ticks - 1);
    local delta = (maxcut - mincut) / (ticks - 1);

write ['csw {}, csh {}, tcsw {}, tcsh {}, csx {}, cxy {}\nstep {}, delta {}\n', 
cs_w, cs_h, tcs_w, tcs_h, cs_x, cs_y, csstep, delta];//DEBUG


    for ith = 0, ticks - 1, 1 loop
        gr_line [key, [0, [cs_x + cs_w, cs_y + ith * csstep],
            [cs_x + cs_w + SCALE_TICK_LEN, cs_y + ith * csstep],
            icolor'black', 1]];
        gr_text [key, [0, [cs_x + cs_w + SCALE_TICK_LEN * 1.5,
            cs_y + ith * csstep], twrite ['{n:.2f}', mincut + (ith * delta)],
            'sys', icolor'black', 8, [position: 'middleleft']]];
    endloop

    //  Draw titles

    gr_text [key, [0, [box_x + box_w/2, box_y + box_h + PAGETITLE_H/2],
        titles (1), 'sys-b', icolor'black', PAGEFONT_H,
        [position: 'middlecenter']]];
/*
    local rowkey = gr_create [size: [box_h, ROWCOLTITLE_H], units: 'pt'];
    gr_text [rowkey, [0, [box_h/2, ROWCOLTITLE_H/2], titles (2), 'sys-b', 
        icolor'black', ROWCOLFONT_H, [position: 'middlecenter']]];
    bg = rep [rep [0xFFFFFFFF, box_h], ROWCOLTITLE_H];
    img = gr_render_pixmap [bg, rowkey];
    gr_destroy rowkey;
    gr_pixmap [key, [0, [0, box_y + box_h],
        [ROWCOLTITLE_H, box_h], app reverse tr img]];
*/
    //  HACK ALERT:  make pixmap images 4 times normal size to deal with
    //               anti-aliasing problems.
    local rowkey = gr_create [size: [4 * box_h, 4 * ROWCOLTITLE_H], units: 'pt'];
    gr_text [rowkey, [0, [2 * box_h, 2 * ROWCOLTITLE_H], titles (2), 'sys-b', 
        icolor'black', 4 * ROWCOLFONT_H, [position: 'middlecenter']]];
    bg = rep [rep [0xFFFFFFFF, 4 * box_h], 4 * ROWCOLTITLE_H];
    img = gr_render_pixmap [bg, rowkey];
    gr_destroy rowkey;
    gr_pixmap [key, [0, [0, box_y + box_h],
        [ROWCOLTITLE_H, box_h], app reverse tr img]];

    gr_text [key, [0, [box_x + box_w/2, ROWCOLTITLE_H/2], titles (3), 'sys-b', 
        icolor'black', ROWCOLFONT_H, [position: 'middlecenter']]];

    return key;

endfunction

function GetNegColors;
function GetPosColors;

/****************************************************************************
 *
 *                          GetColors
 *
 *  Returns a scale of num colors starting with the color that
 *  represent mincut (blue or white) and ending with the color that
 *  represents maxcut (white or red).
 *
 ****************************************************************************/
local function GetColors [mincut, maxcut, num]

    local colors = [];

    if mincut === 0 and maxcut > 0 and num > 0 then
        colors = GetPosColors [maxcut, num - 1];
    elseif maxcut === 0 and mincut < 0 and num > 0 then
        colors = GetNegColors [mincut, num - 1];
    elseif mincut < 0 and maxcut > 0 and num > 0 then
        local mid = max [1, floor ((num - 1) * (mincut / (mincut - maxcut)))];
        colors = GetNegColors [mincut, mid];
        colors = cat [colors, dropfirst  GetPosColors [maxcut, num - mid - 1]];
    else
        return [[], twrite ['Cannot generate colors with minimum {},\n'
            'maximum {}, and number {}\n', mincut, maxcut, num]];
    endif

    return [colors, ''];

endfunction

/****************************************************************************
 *
 *                          GetNegColors
 *
 *  Return num number of scaled colors, plus white, ordered from blue to white.
 *
 ****************************************************************************/
local function GetNegColors [mincut, num]

    local colors = [], newcolor;
    local r, g, b;
    local delta = floor (NEG_RANGE_MAX / num);

    //  Blue
    r = 0; g = 0; b = 127;
    while b < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        b = b + delta;
    endloop

    //  Turquoise
    g = b - 256; r = 0; b = 255;
    while g < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        g = g + delta;
    endloop

    //  Aquamarine
    b = 256 - (g - 256); r = 0; g = 255;
    while b >= 0 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        b = b - delta;
    endloop

    //  Green
    r = -b; g = 255; b = 0;
    while r < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        r = r + delta;
    endloop

    if length colors > num then
        colors = drop [colors, num - length colors];
    endif

    //  White
    r = 255; g = 255; b = 255;
    newcolor = r * R_FACTOR + g * G_FACTOR + b;
    colors = append [colors, newcolor];

    return colors;

endfunction

/****************************************************************************
 *
 *                          GetPosColors
 *
 *  Return num number of scaled colors, plus white, ordered from white to red.
 *
 ****************************************************************************/
local function GetPosColors [maxcut, num]

    local colors = [], newcolor;
    local r, g, b;
    local delta = floor (POS_RANGE_MAX / num);

    //  Since we prefer darker colors, build red to white and then reverse.
    //  Maroon
    r = 95; g = 0; b = 95;
    while r < 128 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        r = r + delta;
        b = b + delta;
    endloop

    //  Red
     r = 127 + r - 128; g = 0; b = 0;
    while r < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        r = r + delta;
    endloop
    
    //  Orange
    g = r - 256; r = 255; b = 0;
    while g < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        g = g + delta;
    endloop

    //  Yellow
     b = g - 256; r = 255; g = 255;
    while b < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        b = b + delta;
    endloop

    if length colors > num then
        colors = drop [colors, num - length colors];
    endif

    //  White
    r = 255; g = 255; b = 255;
    newcolor = r * R_FACTOR + g * G_FACTOR + b;
    colors = append [colors, newcolor];

    return reverse colors;
endfunction

function GetMonoNegColors;
function GetMonoPosColors;

/****************************************************************************
 *
 *                          GetMonoColors
 *
 *  Returns a scale of num colors starting with the color that
 *  represent mincut (blue or white) and ending with the color that
 *  represents maxcut (white or red).
 *
 ****************************************************************************/
local function GetMonoColors [mincut, maxcut, num]

    local colors = [];

    if mincut === 0 and maxcut > 0 and num > 0 then
        colors = GetMonoPosColors [maxcut, num - 1];
    elseif maxcut === 0 and mincut < 0 and num > 0 then
        colors = GetMonoNegColors [mincut, num - 1];
    elseif mincut < 0 and maxcut > 0 and num > 0 then
        local mid = max [1, floor ((num - 1) * (mincut / (mincut - maxcut)))];
        colors = GetMonoNegColors [mincut, mid];
        colors = cat [colors, dropfirst  GetMonoPosColors [maxcut,
            num - mid - 1]];
    else
        return [[], twrite ['Cannot generate colors with minimum {},\n'
            'maximum {}, and number {}\n', mincut, maxcut, num]];
    endif

    return [colors, ''];

endfunction

/****************************************************************************
 *
 *                          GetMonoNegColors
 *
 *  Return num number of scaled colors, plus white, ordered from blue to white.
 *
 ****************************************************************************/
local function GetMonoNegColors [mincut, num]

    local colors = [], newcolor;
    local r, g, b;
    local delta = floor (MONO_RANGE_MAX / num);

    //  Dark Blue
    r = 0; g = 0; b = 127;
    while b < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        b = b + delta;
    endloop


    //  Light Blue
    g = b - 256; r = b - 256; b = 255;
    while g < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        g = g + delta;
        r = r + delta;
    endloop


    if length colors > num then
        colors = drop [colors, num - length colors];
    endif

    //  White
    r = 255; g = 255; b = 255;
    newcolor = r * R_FACTOR + g * G_FACTOR + b;
    colors = append [colors, newcolor];

    return colors;

endfunction

/****************************************************************************
 *
 *                          GetMonoPosColors
 *
 *  Return num number of scaled colors, plus white, ordered from white to red.
 *
 ****************************************************************************/
local function GetMonoPosColors [maxcut, num]

    local colors = [], newcolor;
    local r, g, b;
    local delta = floor (MONO_RANGE_MAX / num);

    //  Since we prefer darker colors, build red to white and then reverse.

    //  Dark Red
     r = 127; g = 0; b = 0;
    while r < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        r = r + delta;
    endloop
    
    //  Light Red
     g = r - 255; b = r - 255; r = 255; 
    while g < 256 loop
        newcolor = r * R_FACTOR + g * G_FACTOR + b;
        colors = append [colors, newcolor];
        g = g + delta;
        b = b + delta;
    endloop
    
    if length colors > num then
        colors = drop [colors, num - length colors];
    endif

    //  White
    r = 255; g = 255; b = 255;
    newcolor = r * R_FACTOR + g * G_FACTOR + b;
    colors = append [colors, newcolor];

    return reverse colors;
endfunction

/****************************************************************************
 *
 *                          IndexToRowCol
 *
 *  Return the selected row and column numbers.  Selected rows have selcol = 0
 *  and selected columns have selrow = 0.  
 *
 ****************************************************************************/
local function IndexToRowCol [index, numrows, numcols]

    local selrow = ceil (index / (numcols + 1));
    if selrow === numrows + 1 then
        selrow = 0;
    endif

    local selcol = mod [index, numcols + 1] - 1;
    selcol = select [numcols, selcol, selcol === -1];

    return [selrow, selcol];

endfunction

/****************************************************************************
 *
 *                          StandardDeviation
 *
 *  Return the average and standard deviation of the flat vector of numbers.
 *
 ****************************************************************************/
local function StandardDeviation [nums]

    local n = length nums;
    if n === 0 then
        return 0;
    endif
    local avg = (add nums) / n;
    local sigma = sqrt ((add (sqr (nums - avg))) / n);

    return [avg, sigma];

endfunction

/****************************************************************************
 *
 *                          TruncateCols
 *
 *  Return the data with only the first MAX_COLS columns of data.
 *
 ****************************************************************************/
local function TruncateCols [data]

    local [titles, resnames, resabbrevs, rowdata] = data;
    if length resnames <= MAX_COLS then
        return data;
    endif

    local truncresnames = keep [resnames, MAX_COLS];
    local truncresabbrevs = keep [resabbrevs, MAX_COLS];
    local row, trunclignames = [], truncligabbrevs = [], truncrowvals = [];
    for row in rowdata loop
        local [ligname, ligabbrev, rowvals] = row;
        trunclignames = append [trunclignames, ligname];
        truncligabbrevs = append [truncligabbrevs, ligabbrev];
        truncrowvals = append [truncrowvals, keep [rowvals, MAX_COLS]];
    endloop

    local truncdata = [titles, truncresnames, truncresabbrevs,
        tr [trunclignames, truncligabbrevs, truncrowvals]];

    return truncdata;

endfunction

/****************************************************************************
 *
 *                          TruncateRows
 *
 *  Return the data with only the first MAX_ROWS rows of data.
 *
 ****************************************************************************/
local function TruncateRows [data]

    local [titles, resnames, resabbrevs, rowdata] = data;
    return [titles, resnames, resabbrevs, keep [rowdata, MAX_ROWS]];

endfunction

//  Global Functions

/****************************************************************************
 *
 *                          qb_HeatMapSetupPanel
 *
 *  Parameters:
 *
 *    data : vector : the data to display in heat map.  It has the format:
 *          [ 
 *            [mapTitle, rowTitle, colTitle], [colNames], [colAbbrevs], 
 *            [
 *              [rowName1, rowAbbrev1, [values1]],
 *              [rowName2, rowAbbrev2, [values2]],
 *              ... , 
 *              [rowNameN, rowAbbrevN, [valuesN]]
 *            ]
 *          ]
 *          where length colNames === length colAbbrevs === length values1
 *          ===  ... === length valuesN; the titles, names and abbreviations
 *          are tokens; and the values are numbers. Only the first three
 *          characters of the abbreviations are used for the labels.
 *
 *    cutoff : real : the number of standard deviations used to determine the
 *          minimum and maximum values of the color scale.  Values smaller
 *          than the minimum are assigned the same color as the minimum and
 *          values greater than the maximum are assigned the same color as
 *          the maximum.
 *
 *    numsignifcols : int : the number of significant columns used to
 *          calculate the standard deviation.
 *
 *    numcolors : int : the number of different colors used to generate the
 *          color scale for the heat map.
 *
 *    monochrome : boolean : if true, use a single color (red for positive,
 *          blue for negative) to generate the color scale.  Otherwise,
 *          use a rainbow spectrum of colors.
 *
 *    ticks : int : the number of ticks to display on the color scale showing
 *          the values represented by the colors.
 *
 *    selfun : token : the name of the global function to call when the user
 *          selects a row, column or cell of the heat map.  The function is
 *          passed the following parameters: data, selrow, selcol, mincut,
 *          maxcut and colors.  Selected cells have selrow from 1 to numrows
 *          selcol from 1 to numcols.  Selected rows have selcol = 0 and
 *          selected columns have selrow = 0.  If the function returns an
 *          error message (token), it is displayed using Warning [].
 *
 *    initsel : int : the initial selection.  It is the index into the
 *          radio buttons generated using the above data.
 *
 *    help : boolean : if true, show in the bubble help for each button
 *          the full row label, full column label and cell value.
 *
 ****************************************************************************/
global function qb_HeatMapSetupPanel [data, cutoff, numsignifcols,
        numcolors, monochrome, ticks, selfun, initsel, help]

    if MOE_BATCH then return; endif
    if WindowShow ['QB Heat Map', 1] then return; endif

    //  Currently, only 30 columns and 40 rows are allowed.
    data = TruncateCols [data];
    data = TruncateRows [data];

    local mincut, maxcut, errmess;
    [mincut, maxcut, errmess] = CalculateCuts [data, cutoff, 
        numsignifcols, numcolors];
    if mincut === [] or maxcut === [] then
        Warning errmess;
        return;
    endif

    local colors;
    if monochrome then
        [colors, errmess] = GetMonoColors [mincut, maxcut, numcolors];
    else
        [colors, errmess] = GetColors [mincut, maxcut, numcolors];
    endif

    if colors === [] then
        Warning errmess;
        return;
    endif

    local [titles, colnames, colabbrevs, rowdata] = data;
    local numcols = length colnames;
    local numrows = length rowdata;
    local page_w = (numcols + 1) * (CELL_WD + MOE_PAD_W) + MOE_PAD_W;
    local page_h = (numrows + 1) * (CELL_HT + MOE_PAD_H) + MOE_PAD_H;

    local scalecell_h = floor (page_h / numcolors);
    local scalecell_w =  SCALE_CELL_WD;
    local [scalekey, s_w, s_h] = DrawColorScale [colors, scalecell_w,
        scalecell_h, mincut, maxcut, ticks];

    //  Color map cells and store row labels
    local row_i, col_i, bgraphics = [], bhelp = [];
    for row_i = 1, numrows, 1 loop
        local [rowname, rowabbrev, rowvals] = rowdata (row_i);
        bgraphics = append [bgraphics, DrawCellLabel [tok_keep [rowabbrev, 3],
            CELL_WD, CELL_HT]];
        if help then
            bhelp = append [bhelp, twrite ['row:  {}', rowname]];
        endif

        for col_i = 1, numcols, 1 loop
            bgraphics = append [bgraphics, DrawCell [colors, 
                CELL_WD, CELL_HT, mincut, maxcut, rowvals (col_i)]];
                if help then
                    bhelp = append [bhelp, twrite ['cell [{}, {}] = {}',
                        rowname, colnames (col_i), rowvals (col_i)]];
                endif
        endloop
    endloop

    //  Empty corner label
    bgraphics = append [bgraphics, 0];
    if help then
        bhelp = append [bhelp, 'empty cell'];
    endif

    //  Column labels
    for col_i = 1, numcols, 1 loop
        bgraphics = append [bgraphics, 
            DrawCellLabel [tok_keep [colabbrevs (col_i), 3], CELL_WD, CELL_HT]];
        if help then
            bhelp = append [bhelp, twrite ['col:  {}', colnames (col_i)]];
        endif
    endloop

    //  Create title labels
    local mapkey = gr_create [size: [page_w, PAGETITLE_H], units: 'pt'];
    gr_text [mapkey, [0, [page_w/2, PAGETITLE_H/2], titles (1), 'sys-b', 
        icolor'black', PAGEFONT_H, [position: 'middlecenter']]];

    //  HACK ALERT:  make pixmap images 4 times normal size to deal with
    //               anti-aliasing problems.
    local rowkey = gr_create [size: [4 * page_h, 4 * ROWCOLTITLE_H],
        units: 'pt'];
    gr_text [rowkey, [0, [2 * page_h, 2 * ROWCOLTITLE_H], titles (2), 'sys-b', 
        icolor'black', 4 * ROWCOLFONT_H, [position: 'middlecenter']]];
    local bg = rep [rep [0xFFFFFFFF, 4 * page_h], 4 * ROWCOLTITLE_H];
    local img = gr_render_pixmap [bg, rowkey];
    gr_destroy rowkey;
    rowkey = gr_create [size: [ROWCOLTITLE_H, page_h], units: 'pt'];
    gr_pixmap [rowkey, [0, [0, page_h],
        [ROWCOLTITLE_H, page_h], app reverse tr img]];

    local colkey = gr_create [size: [page_w, ROWCOLTITLE_H], units: 'pt'];
    gr_text [colkey, [0, [page_w/2, ROWCOLTITLE_H/2], titles (3), 'sys-b', 
        icolor'black', ROWCOLFONT_H, [position: 'middlecenter']]];

    local wkey = WindowCreate cat [HEADER, PANEL];
    WindowSetData [wkey, [mapradio: initsel]];
    WindowSetAttr [wkey, [colorscale: [graphics: scalekey], 
        mapradio: [graphics: bgraphics, columns: numcols + 1,
        bubbleHelp: bhelp], maptitle: [graphics: mapkey],
        rowlbl: [graphics: rowkey], collbl: [graphics: colkey]]];
    WindowShow [wkey, 1];

    gr_destroy mapkey;
    gr_destroy rowkey;
    gr_destroy colkey;
    gr_destroy scalekey;
    app gr_destroy bgraphics;

    local [selrow, selcol] = IndexToRowCol [initsel, numrows, numcols];
    local selerrmess = call [selfun, [data, selrow, selcol, mincut,
        maxcut, colors]];
    if not isnull errmess and neL [errmess, ''] then
        WindowDestroy wkey;
        Warning selerrmess;
        return;
    endif

    loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'panel' then
            if vals.panel === 'Close' then 
                break;

            elseif vals.panel === 'Save' then
                local simgkey = DrawMap [data, numrows, numcols, mincut, 
                    maxcut, colors, ticks];
                gr_export simgkey;
                gr_destroy simgkey;

            elseif vals.panel === 'Print' then
                local pimgkey = DrawMap [data, numrows, numcols, mincut, 
                    maxcut, colors, ticks];
                gr_print pimgkey;
                gr_destroy pimgkey;

            elseif vals.panel === 'Animate' then
                WindowShow [wkey, 0];
                Animate ['row', data, numrows, numcols, selfun, mincut, 
                    maxcut, colors];
                WindowShow [wkey, 1];
            endif

        elseif trig === 'mapradio' then
            [selrow, selcol] = IndexToRowCol [vals.mapradio, numrows, numcols];
            selerrmess = call [selfun, [data, selrow, selcol, mincut,
                maxcut, colors]];
            if not isnull errmess and neL [errmess, ''] then
                Warning selerrmess;
                break;
            endif

        endif
    endloop

    WindowDestroy wkey;

endfunction


#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
	
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

//    qbcore.svl    Core user-interface and utilities used by QB panels

#set title   'QuantumBio Core'
#set class   'QuantumBio'
#set version '2010.02'

function _Atoms;

function qb_GetDefaultsNMRScore;
function qb_GetDefaultsQMScore;

//  Charge status
const CHG_COLOR = 
    [
    'white',
    'green',
    'red'
    ];

//  Data tags are in the order in which they are returned by Divcon.
const QMS_DATA_TAGS =
    [
    "LIGAND",
    "TOTAL SCORE",
    "GAS PHASE HEAT OF FORMATION",
    "ELECTROSTATIC SOLVATION",
    "ATTRACTIVE LENNARD JONES",
    "SOLVATION ENTROPY",
    "VIBRATIONAL ENTROPY",
    "ELECTRONIC INTERACTION ENERGY",
    "MRM STERIC ENERGY",
    "MRM ELECTROSTATIC ENERGY",
    "MRM SOLVATION ENERGY",
    "MRM TOTAL ENERGY"
    ];
 
//  Database Fields
const POSE_FIELD = 'Ligand/Pose';
const LIGCHG_FIELD = 'Lig Chg';

const REC_FIELD = 'Receptor';
const RECCHG_FIELD = 'Rec Chg';

const STATUS_FIELD = 'Status';

const QMS_NUM_FIELDS =
    [
    'QMScore',
    'dHf_g',
    'Solv_elec',
    'LJ_att',
    'S_solv',
    'S_vib',
    'E_eInt',
    'MRMScore',
    'E_stericMRM',
    'E_elecMRM',
    'E_solvMRM'
    ];

const NMR_NUM_FIELDS =
    [
    'NMRScore'
    ];

// Environment tags
const COMPLEX = 'complex';
const RECEPTOR = 'receptor';
const RECOK = 'IsRecOkay';
const LIGAND = 'ligand';
const LIGOK = 'IsLigOkay';
const COREOPTS = 'coreoptions';
const APPOPTS = 'applicationoptions';
const STATUS = 'status';

const DBTYPE = 'qb_dbtype';
const QMSCORE = 'qb_qmscoredb';
const NMRSCORE = 'qb_nmrscoredb';

const STATUS_DEFAULTS =
    [
    ['prevwd',       ''            ],
    ['calcchg',      0             ],
    ['verifychg',    0             ],
    ['recchg',       1             ],
    ['ligchg',       1             ],
    ['moerecchg',    0             ],
    ['moeligchg',    0             ]
    ];

/*  NOTE:  Non-GUI opt task must be the first tag.  */
const CORE_OPT_DEFAULTS =
    [
    ['task',         0             ],
    ['mode',         'One-to-One'  ],  // Shared dialog defaults options
    ['cwd',          0             ],
    ['workdir',      '/tmp'        ],
    ['scoredb',      'qmscore.mdb' ],
    ['recdb',        ''            ],
    ['posedb',       ''            ],
    ['recchg',       0             ],
    ['ligchg',       0             ],
    ['poseschg',     0             ]
    ];

const RUN_MODES =
    [
    'One-to-One',
    'One-to-Many',
    'Many-to-Many'
    ];

const CORE_PANEL =
    [
    Hbox :
        [
        extendH: 1,
        FSBText :
            [
            name: 'scoredb', len: 40, extendH: 1, title: 'Output DB:',
            mode: 'saveAs', allowBlank: 0,
            bubbleHelp:
                'The name of the output database that will hold\n'
                'the run paramaters and scoring results.'
            ],
        Button : [ name: 'browse_scoredb', text: 'Browse...' ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        extendH: 1,
        Text :
            [
            name: 'workdir', len: 40, extendH: 1, title: 'Working Dir:',
            type: 'char', allowBlank: 0,
            shortcut: ['/tmp', '.', '~', '~/tmp', '/scratch'],
            bubbleHelp:
                'The name of the working directory for storing\n'
                'QB Divcon intermediate calculations and logs.\n'
                'The absolute path to the specified directory\n'
                'will be stored and used at execution time.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 0, margin:1
            ],
        Checkbox :
            [
            name: 'cwd', text: 'CWD', onTrigger: 'return', 
            bubbleHelp:
                'Set the current working directory using\n'
                'the run time environment variable $PWD.'
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        Radio :
            [
            name: 'mode', text: RUN_MODES, columns: 3, minWidth: 12, 
            extendH: 1, onTrigger: 'return', title: 'Mapping Mode:',
            type: 'char',
            bubbleHelp:
                'The mapping mode of receptors to ligand/poses:\n'
                '  One ligand docked into one receptor.\n'
                '  Many ligand poses docked into the same receptor.\n'
                '  Many ligand poses, each docked into its own receptor.'
            ]
        ],

    Hbox :
        [
        name: 'recbox', extendH: 1,
        FSBText :
            [
            name: 'recdb', len: 40, extendH: 1, title: 'Receptor DB:',
            mode: 'open', allowBlank: 0,
            bubbleHelp:
                'The name of the input database that holds\n'
                'the receptors.'
            ],
        Button : [ name: 'browse_recdb', text: 'Browse...' ]
        ],

    Hbox :
        [
        name: 'posebox', extendH: 1,
        FSBText :
            [
            name: 'posedb', len: 40, extendH: 1, title: 'Ligand/Pose DB:',
            mode: 'open', allowBlank: 0,
            bubbleHelp:
                'The name of the input database that holds\n'
                'the ligand poses (and possibly scores).'
            ],
        Button : [ name: 'browse_posedb', text: 'Browse...' ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        extendH: 1, name: 'chgbox', title: 'Charges:',
        Vbox :
            [
            Button :
                [
                name: 'calcchg', text: 'Calculate', extendH:1, 
                bubbleHelp:
                    'Calculate the total charges for the receptor\n'
                    'and ligand in the MOE Window.'
                ],
            Button :
                [
                name: 'ckdbchg', text: 'Check', extendH:1, 
                bubbleHelp:
                    'Check the charges stored in the "Rec Chg"\n'
                    'and "Lig Chg" fields of the QMScore database.'
                ]
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 0, margin:1
            ],
        Vbox :
            [
            Hbox :
                [
                extendH: 1,
                Label :
                    [
                    name: 'recflg', title: 'Receptor:',
                    bubbleHelp:
                        'Problems with the total charge of receptor?\n'
                        '   White:   uncalculated or user-entered charge.\n'
                        '   Green:   charge calculated by MOE.\n'
                        '   Red:      charge problematic for Divcon.'
                    ],
                Text :
                    [
                    name: 'recchg', allowBlank: 0,
                    type: 'int', minWidth: 4,
                    onTrigger: 'validate',
                    bubbleHelp:
                        'Total charge of receptor.'
                    ]
                ],
            Hbox :
                [
                extendH: 1,
                Label :
                    [
                    name: 'ligflg', title: 'Ligand:',
                        bubbleHelp:
                        'Problems with the total charge of ligand?\n'
                        '   White:   uncalculated or user-entered charge.\n'
                        '   Green:   charge calculated by MOE.\n'
                        '   Yellow:  MOE\'s charge was adjusted.\n'
                        '   Red:      charge problematic for Divcon.'

                    ],
                Text :
                    [
                    name: 'ligchg', allowBlank: 0,
                    type: 'int', minWidth: 4, extendH: 1,
                    onTrigger: 'validate',
                    bubbleHelp:
                        'Total charge of ligand.'
                    ],
                Checkbox :
                    [
                    name: 'poseschg', text: 'All Poses',
                    bubbleHelp:
                        'Use the ligand charge for all\n'
                        'poses in the poses database.'
                    ]
                ]
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1]
    ];

//***********************  Local Functions  *********************************

function SplitComplex;
function SplitReceptor;

/****************************************************************************
 *                          AtomsToMols
 *
 *  Given the set of atoms in the MOE Window, identify and separate the
 *  ligand, then split up the receptor atoms into individual molecules.
 *  Returns the extracted molecules.
 *
 ****************************************************************************/
local function AtomsToMols []

    local [recatoms, ligatoms, errmess] = SplitComplex [];

    if recatoms === [] or ligatoms === [] then
        return [[], [], errmess];
    endif

    local recsets = SplitReceptor [recatoms];

    if recsets === [] then
        return [[], [], 'No receptor was recognized.'];
    endif

    local ligmol = mol_Extract ligatoms;
    local recmols = app mol_Extract recsets;

    return [recmols, ligmol, ''];

endfunction

/****************************************************************************
 *                          CalcCharge
 *
 *  Determine the total charge of the molecule collection represented by 
 * the set of atoms.
 *
 ****************************************************************************/
local function CalcCharge [atoms]

    local charge = add aFCharge atoms;

    return charge;
endfunction

function ChargeOK;

/****************************************************************************
 *                          CalcComplexCharge
 *
 *  Determine the total charge of the ligand and receptor in the MOE window.
 *
 ****************************************************************************/
local function CalcComplexCharge []

    local [recatoms, ligatoms, errmess] = SplitComplex [];
    if recatoms === [] or ligatoms === [] then
        return  [[], [], [], [], errmess];
    endif

    local recchg = CalcCharge [recatoms];
    local ligchg = CalcCharge [ligatoms];

    local recok = ChargeOK [recatoms, recchg];
    local ligok = ChargeOK [ligatoms, ligchg];

    return [recchg, recok, ligchg, ligok, ''];

endfunction

/****************************************************************************
 *                          ChargeOK
 *
 *  Determine whether the given total charge of the molecule collection 
 *  represented by the set of atoms will result in a system with an even
 *  number of electrons.
 *
 ****************************************************************************/
local function ChargeOK [atoms, charge]

    local numelecs = add aAtomicNumber atoms;
    return even (charge + numelecs);

endfunction

function CheckComplexCharge;
function SetChargeStatus;

/****************************************************************************
 *                          CheckCharge
 *
 *  Check user-defined charges for even number of electrons.
 *
 ****************************************************************************/
local function CheckCharge [wkey, status, recchg, ligchg]

    local [recok, ligok, errmess] = CheckComplexCharge [recchg, ligchg];
    if recok === [] or ligok === [] then
        Warning errmess;  //DEBUG
        SetChargeStatus [wkey, status];
        return status;
    endif

    if recok then
        if status.calcchg and recchg === status.moerecchg then
          status.recchg = 2;
        else
          status.recchg = 1;
        endif

    else
        status.recchg = 3;
    endif

    if ligok then
        if status.calcchg and ligchg === status.moeligchg then
            status.ligchg = 2;
        else
            status.ligchg = 1;
        endif
    else
        status.ligchg = 3;
    endif

    SetChargeStatus [wkey, status];
    return status;
endfunction

/****************************************************************************
 *                          CheckComplexCharge
 *
 *  Determine whether the given total charges of the ligand and receptor
 *  in the MOE window will result in systems with an even number of electrons.
 *
 ****************************************************************************/
local function CheckComplexCharge [recchg, ligchg]

    local [recatoms, ligatoms, errmess] = SplitComplex [];
    if recatoms === [] or ligatoms === [] then
        return  [[], [], errmess];
    endif

    local recok = ChargeOK [recatoms, recchg];
    local ligok = ChargeOK [ligatoms, ligchg];

    return [recok, ligok, ''];

endfunction

function qb_GetEnv;
function qb_GetStatusFlags;
function qb_GetPoseFields;
function qb_GetRecFields;
function qb_SaveDivconStatus;
function qb_MolsChargeOK;
function GetWhich;

/****************************************************************************
 *                          CheckDBCharges
 *
 *  Check the charges store in the Rec Chg and Lig Chg fields of the Score
 *  Database and store the charge status in the Status field.
 *
 *  HACK alert:  an extra flag was added to the LIGOK and RECOK flag vectors
 *  in order to force moe to treat is as them as vectors, not as scalars.
 *
 ****************************************************************************/
local function CheckDBCharges [oldkey]

    if oldkey === 0 then
        Warning 'The MOEDivcon database hasn\'t been created.';
        return;
    endif

    local dblist = dbv_KeyList [];
    if isnull dblist or isnull indexof [oldkey, dblist] then
        Warning 'The MOEDivcon database isn\'t open.';
        return;
    endif

    local dbkey = db_Open [oldkey, 'read-write'];
    local [r, l, s, coreopts, a, c] = qb_GetEnv [dbkey];
    local [recmolsok, ligmolsok] = qb_GetStatusFlags dbkey;
    local recoklen = length recmolsok - 1;
    local ligoklen = length ligmolsok - 1;
    local nrows = db_nEntries dbkey;

    //  Have rows been added or deleted?
    if coreopts.mode === 'One-to-Many' then
        if neL [recoklen, 1] or neL [ligoklen, nrows] then
            Warning 'QMScore database has been modified\n'
                    'and is not longer consistent.';
            return;
        endif
    else
        if neL [recoklen, ligoklen, nrows] then
            Warning 'QMScore database has been modified\n'
                    'and is not longer consistent.';
            return;
        endif
    endif

    local rowkey = 0, reccnt = 1, rowcnt = 0;
    local recflds = qb_GetRecFields [dbkey];
    local ligflds = qb_GetPoseFields [dbkey];
    while rowkey = db_NextEntry [dbkey, rowkey] loop
        rowcnt = rowcnt + 1;
        if coreopts.mode === 'Many-to-Many' then
            reccnt = rowcnt;
        endif

        if not recmolsok(reccnt) or not ligmolsok (rowcnt) then
            qb_SaveDivconStatus [dbkey, rowkey, 
                "Error:  Bad molecule, skipping!\n"];
            continue;
        endif

        local recok, ligok;
        local [ligmol, ligchg] = db_ReadFields [dbkey, rowkey, ligflds];
        if coreopts.mode === 'Many-to-Many' then
            local [recmols, recchg] = db_ReadFields [dbkey, rowkey,
                recflds];
            [recok, ligok] = qb_MolsChargeOK [recmols, recchg, ligmol,
                ligchg];
        else
            [recok, ligok] = qb_MolsChargeOK [[], 0, ligmol, ligchg];
        endif

        if recok and ligok then
            local [oldstatus] = db_ReadFields [dbkey, rowkey, STATUS_FIELD];
            if not isnull oldstatus then
                qb_SaveDivconStatus [dbkey, rowkey, "Charge is okay.\n"];
            endif
        else
            local which = GetWhich [not recok, not ligok];
            qb_SaveDivconStatus [dbkey, rowkey, 
                swrite ['Warning: problematic charge for {}.\n', which]];
        endif
    endloop

    db_Close dbkey;
endfunction

function DrawChgStatus;

/****************************************************************************
 *                          ClearChargeStatus
 *
 *  Clear charge status.
 *
 ****************************************************************************/
local function ClearChargeStatus [wkey]

    local ligkey = DrawChgStatus [1];
    local reckey = DrawChgStatus [1];

    WindowSetAttr [wkey, [ligflg: [graphics: ligkey],
        recflg: [graphics: reckey]]];
    
    gr_destroy ligkey;
    gr_destroy reckey;

endfunction

function qb_GetEnv;
function GetStatusMessage;

/****************************************************************************
 *                          CopyPoseDB
 *
 *  Copy the Poses database into the QMScore output database.
 *
 *  HACK alert:  add an extra flag to the LIGOK and RECOK flag vector
 *  in order to force moe to treat them as vectors, not as scalars.
 *
 ****************************************************************************/
local function CopyPoseDB [resultskey, poseskey]

    local mess = '';
    local [fields, ftypes] = db_Fields poseskey;
    local molfield = fields | (ftypes == 'molecule');

    if 1 <> length molfield then
        mess = 'The poses database has\n'
            'more than one molecule field.';
        return mess;
    endif

    local [r, l, status, coreopts, a, c] = qb_GetEnv [resultskey];
    local ligmolok = [];

    //  Check receptor charge
    local recmess = GetStatusMessage ['Receptor', neL [status.recchg, 3]];

    //  HACK alert:  temporarily renames mol field to make copying easier
    db_RenameField [resultskey, POSE_FIELD, molfield];
    apt db_EnsureField [resultskey,  fields, ftypes];

    local [osys, nsys] = SystemPush [];

    local rowkey = 0, stsmess = "";
    while rowkey = db_NextEntry [poseskey, rowkey] loop
        local rowdata = db_Read [poseskey, rowkey];
        local chgdata;
        if coreopts.poseschg then
            stsmess = cat [recmess, GetStatusMessage ['Ligand',
                neL [status.ligchg, 3]]];
            chgdata = tag [[LIGCHG_FIELD, STATUS_FIELD],
                [coreopts.ligchg, stsmess]];
        else
            local ligmol = tagpeek [rowdata, molfield];
            local ligch = mol_Create ligmol;
            local ligatms = cat cAtoms ligch;
            local charge = 0;

            if 1 <> length uniq aMoleculeNumber ligatms then
                stsmess = cat [recmess, 
                    'Error:  Ligand has to be a single molecule.'];
                ligmolok = append [ligmolok, 0];
            else
                charge = CalcCharge [ligatms];
                local chgok = ChargeOK [ligatms, charge];
                stsmess = cat [recmess, GetStatusMessage ['Ligand', chgok]];
                ligmolok = append [ligmolok, 1];
            endif

            chgdata = tag [[LIGCHG_FIELD, STATUS_FIELD], [charge, stsmess]];
            oDestroy ligch;
        endif

        rowdata = cat [chgdata, rowdata];
        db_Write [resultskey, 0, rowdata];
    endloop

    SystemPop [osys, nsys];

    db_RenameField [resultskey, molfield, POSE_FIELD];
    ligmolok = append [ligmolok, 0];
    db_SetEnv [resultskey, LIGOK, twrite ['{v}', ligmolok]];

    return mess;
endfunction

/****************************************************************************
 *                          CopyRecPoseDB
 *
 *  Copy the Receptors and Poses databases into the QMScore output database.
 *
 *  HACK alert:  temporarily renames mol fields to make copying easier.
 *
 *  HACK alert:  add an extra flag to the LIGOK and RECOK flag vectors
 *  in order to force moe to treat is as them as vectors, not as scalars.
 *
 ****************************************************************************/
local function CopyRecPoseDB [resultskey, recskey, poseskey]

    local mess = '';
    if db_nEntries recskey <> db_nEntries poseskey then
        mess = 'The receptor and pose databases\n'
            'have different number of entries.';
        return mess;
    endif

    local [recfields, recftypes] = db_Fields recskey;
    local recmolfield = recfields | (recftypes == 'molecule');
    if 1 <> length recmolfield then
        mess = 'The receptor database has\n'
            'more than one molecule field.';
        return mess;
    endif

    local posemolsok = [], recmolsok = [];
    db_RenameField [resultskey, REC_FIELD, recmolfield];
    apt db_EnsureField [resultskey, recfields, recftypes];
    local [osys, nsys] = SystemPush [];
    local recrowkey = 0, recmsgs = [], stsmess = "";
    while recrowkey = db_NextEntry [recskey, recrowkey] loop
        local recrowdata = db_Read [recskey, recrowkey];
        local recmol = tagpeek [recrowdata, recmolfield];
        local recchs = mol_Create recmol;
        local recatms = cat cAtoms recchs;
        local recchg = CalcCharge [recatms];
        local recok = ChargeOK [recatms, recchg];
        stsmess = GetStatusMessage ['Receptor', recok];
        recmsgs = append [recmsgs, stsmess];
        local recchgdata = tag [[RECCHG_FIELD], [recchg]];
        local recsets = SplitReceptor [recatms];
        local recmols = app mol_Extract recsets;
        recmolsok = append [recmolsok, 1];
        recrowdata = tagpoke [recrowdata, recmolfield, recmols];
        recrowdata = cat [recchgdata, recrowdata];
        db_Write [resultskey, 0, recrowdata];
        oDestroy recchs;
    endloop

    db_RenameField [resultskey, recmolfield, REC_FIELD];
    recmolsok = append [recmolsok, 0];
    db_SetEnv [resultskey, RECOK, twrite ['{v}', recmolsok]];

    local [posefields, poseftypes] = db_Fields poseskey;
    local posemolfield = posefields | (poseftypes == 'molecule');
    if 1 <> length posemolfield then
        mess = 'The pose database has\n'
            'more than one molecule field.';
        SystemPop [osys, nsys];
        return mess;
    endif

    db_RenameField [resultskey, POSE_FIELD, posemolfield];
    apt db_EnsureField [resultskey, posefields, poseftypes];

    local poserowkey = 0, resultrowkey = 0, ith = 1;
    while poserowkey = db_NextEntry [poseskey, poserowkey] loop
        resultrowkey = db_NextEntry [resultskey, resultrowkey];
        local poserowdata = db_Read [poseskey, poserowkey];
        local posemol = tagpeek [poserowdata, posemolfield];
        local posech = mol_Create posemol;
        local poseatms = cat cAtoms posech;
        local posechg = 0;
        if 1 <> length uniq aMoleculeNumber poseatms then
            stsmess = cat [recmsgs(ith), 
                'Error:  Ligand has to be a single molecule.'];
            posemolsok = append [posemolsok, 0];
        else
            posechg = CalcCharge [poseatms];
            local poseok = ChargeOK [poseatms, posechg];
            stsmess = cat [recmsgs(ith), GetStatusMessage ['Pose', poseok]];
            posemolsok = append [posemolsok, 1];
        endif

        local posechgdata = tag [[LIGCHG_FIELD, STATUS_FIELD], [posechg,
            stsmess]];
        poserowdata = cat [posechgdata, poserowdata];
        db_Write [resultskey, resultrowkey, poserowdata];
        oDestroy posech;
        ith = ith + 1;
    endloop

    db_RenameField [resultskey, posemolfield, POSE_FIELD];
    posemolsok = append [posemolsok, 0];
    db_SetEnv [resultskey, LIGOK, twrite ['{v}', posemolsok]];

    SystemPop [osys, nsys];
    return mess;
endfunction

/****************************************************************************
 *                          DrawChgStatus
 *
 *  Return the graphics key for the status label.
 *  NOTE:  calling function should call gr_destroy on key after using it.
 *
 ****************************************************************************/
local function DrawChgStatus [cidx]
    local color = CHG_COLOR (cidx);
    local key = gr_create [title: 'status', size: [13, 13], units: 'pt'];
    gr_oval [key, [0, [6,6], [6,6], icolor color, 1, icolor color]];
    return key;
endfunction

/****************************************************************************
 *                          GetStatusMessage
 *
 *  Return a string message describing the charge status.
 *
 ****************************************************************************/
local function GetStatusMessage [which, ok]

    local mess = "";

    if not ok then
        mess = swrite ['Warning: {} has a problematic charge.\n', which];
    endif

    return mess;

endfunction

/****************************************************************************
 *                          GetWhich
 *
 *  Return a token message describing which molecules are faulty.
 *
 ****************************************************************************/
local function GetWhich [recbad, ligbad]
    local which = '';
    if recbad and ligbad then
        which = 'receptor and ligand';
    elseif recbad then
        which = 'receptor';
    else
        which = 'ligand';
    endif

    return which;
endfunction

/****************************************************************************
 *                          SaveEnv
 *
 *  Save the molecules (ligand and receptor) and options in the 
 *  database.
 *
 ****************************************************************************/
local function SaveEnv [dbkey, tgtmols, ligmol, status, coreopts, appopts,
        complex, type]

    db_SetEnv [dbkey, RECEPTOR, twrite ['{v}', tgtmols]];
    db_SetEnv [dbkey, LIGAND, twrite ['{v}', ligmol]];
    db_SetEnv [dbkey, STATUS, twrite ['{v}', status]];
    db_SetEnv [dbkey, COREOPTS, twrite ['{v}', coreopts]];
    db_SetEnv [dbkey, APPOPTS, twrite ['{v}', appopts]];
    db_SetEnv [dbkey, COMPLEX, twrite ['{v}', complex]];

    if type === 'nmrscore' then
        db_SetEnv [dbkey, DBTYPE, NMRSCORE];
    elseif type === 'qmscore' then
        db_SetEnv [dbkey, DBTYPE, QMSCORE];
    endif

endfunction

/****************************************************************************
 *                          SetChargeStatus
 *
 *  Set charge status label.
 *
 ****************************************************************************/
local function SetChargeStatus [wkey, status]

    local ligkey = DrawChgStatus [status.ligchg];
    local reckey = DrawChgStatus [status.recchg];

    WindowSetAttr [wkey, [ligflg: [graphics: ligkey],
        recflg: [graphics: reckey]]];
    
    gr_destroy ligkey;
    gr_destroy reckey;

endfunction

/****************************************************************************
 *                          SetScoreFields
 *
 *  Ensure that the required fields are present.
 *
 ****************************************************************************/
local function SetScoreFields [dbkey, addreceptor, fields, dbtype]

    if addreceptor then
        db_EnsureField [dbkey, REC_FIELD, 'molecule'];
        db_EnsureField [dbkey, RECCHG_FIELD, 'int'];
    endif

    db_EnsureField [dbkey, POSE_FIELD, 'molecule'];
    db_EnsureField [dbkey, LIGCHG_FIELD, 'int'];
    db_EnsureField [dbkey, STATUS_FIELD, 'char'];

    if dbtype === 'qmscore' then
        apt db_EnsureField [dbkey, QMS_NUM_FIELDS, 'double'];
    elseif dbtype === 'nmrscore' then
        apt db_EnsureField [dbkey, NMR_NUM_FIELDS , 'double'];
        if neL [fields, []] then
            apt db_EnsureField [dbkey, fields, 'double'];
        endif
    endif
endfunction

/****************************************************************************
 *                          SplitComplex
 *
 *  Split the set of atoms in the MOE Window into ligand and receptor atoms.
 *
 ****************************************************************************/
local function SplitComplex []

    local complexatoms = Atoms [];
    if length complexatoms === 0 then
        return [[], [], 'No molecular complex loaded in MOE Window.'];
    endif

    const COLLECTNAMES = ['QB_LIGAND', 'LIGX_LIGAND'];
    local recatoms, ligatoms;
    local cname, makecoll = 0;

    local colnames = oCollections [];
    for cname in COLLECTNAMES loop
        if anytrue eqE [cname, colnames] then
            ligatoms  = cat oAtoms oGetCollection cname;
            ligatoms = join [ligatoms, complexatoms];
            break;
        endif
    endloop

    if length ligatoms === 0 then
        ligatoms  = _Atoms '$$ligand';
        makecoll = 1;
    endif

    if length ligatoms === 0 or length ligatoms >= length complexatoms then
        return [[], [], 'No ligand was recognized.\n  Use LigX to define it.'];
    endif

    if 1 <> length uniq aMoleculeNumber ligatoms then
        return [[], [], 'Ligand has to be a single molecule.'];
    endif

    if makecoll then
        oSetCollection ['QB_LIGAND', ligatoms];
     endif

    recatoms = diff [complexatoms, ligatoms];

    return [recatoms, ligatoms, ''];

endfunction

/****************************************************************************
 *                          SplitReceptor
 *
 *  Given a set of receptor atoms, returns subsets which represent
 *  individual molecules (connected pieces) in the receptor.
 *
 ****************************************************************************/
local function SplitReceptor [receptoratoms]

    if receptoratoms === [] then return []; endif

    local atomsets = [];
    local [recidx, reccnt] = sac aMoleculeNumber receptoratoms;
    if length reccnt > 1 then
        receptoratoms = receptoratoms [recidx];
        atomsets = split [receptoratoms, reccnt];
    else
        atomsets = [receptoratoms];
    endif

    return atomsets;

endfunction

/****************************************************************************
 *                          UpdateCharge
 *
 *  Update the window based on new charge.
 *
 ****************************************************************************/
local function UpdateCharge [wkey, status]

    local [recchg, recok, ligchg, ligok, errmess] = CalcComplexCharge [];
    if recchg === [] or recok === [] or ligchg === [] or ligok === [] then
        Warning  errmess;
        SetChargeStatus [wkey, status];
        return status;
    endif

    status.calcchg = 1;
    status.moerecchg = recchg;
    status.moeligchg = ligchg;

    status.recchg = select [2, 3, recok];
    status.ligchg = select [2, 3, ligok];

    WindowSetData [wkey, [ligchg: ligchg, recchg: recchg]];
    SetChargeStatus [wkey, status];

    return status;
endfunction

/****************************************************************************
 *                          UpdateCWD
 *
 *  Update the window based on new CWD value.
 *
 ****************************************************************************/
local function UpdateCWD [wkey, cwd, wd, prev]
    if cwd === 1 then
        WindowSetAttr [wkey, [workdir: [sensitive: 0, allowBlank: 1]]];
        WindowSetData [wkey, [workdir: '']];
        return wd;
    else
        WindowSetAttr [wkey, [workdir: [sensitive: 1, allowBlank: 0]]];
        WindowSetData [wkey, [workdir: prev]];
        return prev;
    endif
endfunction

/****************************************************************************
 *                          UpdateMode
 *
 *  Update the window based on new mode value.
 *
 ****************************************************************************/
local function UpdateMode [wkey, mode, status]
    if mode === 'One-to-One' then
        WindowSetAttr [wkey, [
            recbox: [sensitive: 0], recdb: [allowBlank: 1], 
            posebox: [sensitive: 0], posedb: [allowBlank: 1], 
            panel:[sensitive: [1,1,1,1]],
            chgbox: [sensitive: 1], recchg: [allowBlank: 0],
            ligchg: [allowBlank: 0], poseschg: [sensitive: 0]]];
        SetChargeStatus [wkey, status];
    elseif mode === 'One-to-Many' then
        WindowSetAttr [wkey, [
            recbox: [sensitive: 0], recdb: [allowBlank: 1],
            posebox: [sensitive: 1], posedb: [allowBlank: 0],
            panel:[sensitive: [0,1,1,1]],
            chgbox: [sensitive: 1], recchg: [allowBlank: 0],
            ligchg: [allowBlank: 0],
            poseschg: [sensitive: 1]]];
        SetChargeStatus [wkey, status];
    elseif mode === 'Many-to-Many' then
        WindowSetAttr [wkey, [
            recbox: [sensitive: 1], recdb: [allowBlank: 0],
            posebox: [sensitive: 1], posedb: [allowBlank: 0],
            panel:[sensitive: [0,1,1,1]],
            chgbox: [sensitive: 0], recchg: [allowBlank: 1],
            ligchg: [allowBlank: 1],
            poseschg: [sensitive: 0]]];
        ClearChargeStatus [wkey];
    endif
endfunction

//************************  Global Functions  *******************************

/****************************************************************************
 *
 *                          qb_CoreHandler
 *
 *  Handle the triggers of the core panel.
 *
 ****************************************************************************/
global function qb_CoreHandler [wkey, trig, status, vals, btasks, dbkey]

    local btid;
    if trig === 'mode' then
        UpdateMode [wkey, vals.mode, status];

    elseif trig === 'cwd' then
        status.prevwd = UpdateCWD [wkey, vals.cwd, vals.workdir,
            status.prevwd];

    elseif trig === 'calcchg' then
        if second task_fork [master: 'parent',
                statics:'share'] === 'child' then
            task_prio 0;

            status = UpdateCharge [wkey, status];
            exit [];
        endif

    elseif trig === 'ckdbchg' then
        if second task_fork [master: 'parent',
                statics:'share'] === 'child' then
            task_prio 0;

            CheckDBCharges [dbkey];
            exit [];
        endif

    elseif trig === 'recchg' then
        if second task_fork [master: 'parent', 
                statics:'share'] === 'child' then
            task_prio 0;

            status = CheckCharge [wkey, status, vals.recchg,
                vals.ligchg];
            exit [];
        endif

    elseif trig === 'ligchg' then
        if second task_fork [master: 'parent',
                statics:'share'] === 'child' then
            task_prio 0;

            status = CheckCharge [wkey, status, vals.recchg,
                vals.ligchg];
            exit [];
        endif

    elseif trig === 'browse_scoredb' then
        btid = run ['fbrowse.svl', [trig, wkey, 'Select QMScore DB File', 
            'none', '*.mdb', 'scoredb']];
        if btid then btasks = append [btasks, btid]; endif

    elseif trig === 'browse_recdb' then
        btid = run ['fbrowse.svl', [trig, wkey, 'Select Receptor DB File', 
            'open', '*.mdb', 'recdb']];
        if btid then btasks = append [btasks, btid]; endif

    elseif trig === 'browse_posedb' then
        btid = run ['fbrowse.svl', [trig, wkey, 'Select Pose DB File', 
            'open', '*.mdb', 'posedb']];
        if btid then btasks = append [btasks, btid]; endif
    endif

    return [status, btasks];
endfunction

/****************************************************************************
 *                          qb_CutReceptor
 *
 *  Given a pose database and radius, find all receptor atoms of the current
 *  complex in the MOE window that are within the radius distance from each
 *  pose, expand those atoms out to their respective residues, and return
 *  the "molecules" formed by those atoms.
 *
 ****************************************************************************/
global function qb_CutReceptor [posedbkey, radius]

    if radius <= 0.0 then
        return [[], [], 'Radius must be greater than zero.'];
    endif

    local [recatoms, ligatoms, errmess] = SplitComplex [];

    if recatoms === [] or ligatoms === [] then
        return [[], [], errmess];
    endif

    //  Find neighboring atoms within radius
    local cutset = [];
    local subset;
    for subset in split [x_id recatoms, 50] loop
        local key = prox_open [radius, aPos recatoms[subset], radius/2];
        local cutidx = uniq second prox_find [key, aPos ligatoms, radius/2];
        prox_close key;
        cutset = cat [cutset, subset[cutidx]];
    endloop

    if length cutset === 0 then
        return [[], [], twrite ['No receptor atoms within radius {n:.1f}\n'
            'of the ligand pose atoms.', radius]];
    endif

    local cutatoms = recatoms [cutset];

    print aMoleculeNumber cutatoms;  //DEBUG

    local residues = uniq oParent (cutatoms);
    local resatoms = cat oChildren residues;

    print aMoleculeNumber resatoms;  //DEBUG

    local delatoms = diff [recatoms, resatoms];
    local delresidues = uniq oParent delatoms;
    oDestroy delatoms;
    delresidues = delresidues | rAtomCount delresidues == 0;
    local delchains = uniq oParent delresidues;
    oDestroy delresidues;
    delchains = delchains | cResidueCount delchains == 0;
    oDestroy delchains;

	Add_H (resatoms | aLonePairs resatoms <= 0);
	Add_HLP (resatoms | aLonePairs resatoms > 0);

    print aMoleculeNumber resatoms;  //DEBUG

    local recsets = SplitReceptor [resatoms];

    local ligmol = mol_Extract ligatoms;
    local recmols = app mol_Extract recsets;

    return [recmols, ligmol, ''];

endfunction

/****************************************************************************
 *
 *                          qb_GetCorePanel
 *
 *  Returns the vector defining the core panel.
 *
 ****************************************************************************/
global function qb_GetCorePanel []
    return CORE_PANEL;
endfunction

/****************************************************************************
 *                          qb_GetDefaultsCore
 *
 *  Return the default values for the GUI core.
 *
 ****************************************************************************/
global function qb_GetDefaultsCore []
    return dropfirst tag tr CORE_OPT_DEFAULTS;
endfunction

/****************************************************************************
 *                          qb_GetDefaultsStatus
 *
 *  Return the default values for the GUI status.
 *
 ****************************************************************************/
global function qb_GetDefaultsStatus []
    return tag tr STATUS_DEFAULTS;
endfunction

/****************************************************************************
 *                          qb_GetEnv
 *
 *  Get the molecules (ligand and receptor) and options from the  
 *  database.
 *
 ****************************************************************************/
global function qb_GetEnv [dbkey]

    local tgttok = db_GetEnv [dbkey, RECEPTOR];
    local [[tgtmols]] = sread [string tgttok, '{v}'];
    local ligtok = db_GetEnv [dbkey, LIGAND];
    local [[ligmol]] = sread [string ligtok, '{v}'];
    local cpxtok = db_GetEnv [dbkey, COMPLEX];
    local [[complex]] = sread [string cpxtok, '{v}'];

    local ststok = db_GetEnv [dbkey, STATUS];
    local [[status]] = sread [string ststok, '{v}'];
    status = tagcat [status, tag tr STATUS_DEFAULTS];

    local coreopttok = db_GetEnv [dbkey, COREOPTS];
    local [[coreopts]] = sread [string coreopttok, '{v}'];
    coreopts = tagcat [coreopts, tag tr CORE_OPT_DEFAULTS];

    local appopttok = db_GetEnv [dbkey, APPOPTS];
    local [[appopts]] = sread [string appopttok, '{v}'];
    local type = db_GetEnv [dbkey, DBTYPE];

    if type === QMSCORE then
        appopts = tagcat [appopts, qb_GetDefaultsQMScore []];
    elseif type === NMRSCORE then
        appopts = tagcat [appopts, qb_GetDefaultsNMRScore []];
    endif

    return [tgtmols, ligmol, status, coreopts, appopts, complex];

endfunction

/****************************************************************************
 *                          qb_GetLigandAtomNames
 *
 *  Get the atom names of the given element ligand in the MOE Window.
 *
 ****************************************************************************/
global function qb_GetLigandAtomNames [type]
    local [recset, ligand, errmess] = AtomsToMols [];
    if recset === [] or ligand === [] then
        Warning errmess;
        exit [];
    endif

    local [atomindices] = indicesof [type, ligand(4)(MOL_ATOM_EL)];
    local atomnames = get [ligand(4)(MOL_ATOM_NAME), atomindices];

    return atomnames;
endfunction

/****************************************************************************
 *                          qb_GetPoseFields
 *
 ****************************************************************************/
global function qb_GetPoseFields []

    return [POSE_FIELD, LIGCHG_FIELD];

endfunction

/****************************************************************************
 *                          qb_GetRecFields
 *
 ****************************************************************************/
global function qb_GetRecFields []

    return [REC_FIELD, RECCHG_FIELD];

endfunction

/****************************************************************************
 *                          qb_GetStatusFlags
 *
 *  Get the receptor and ligand molecule status flags.
 *
 ****************************************************************************/
global function qb_GetStatusFlags [dbkey]
    local recmolsoktok = db_GetEnv [dbkey, RECOK];
    local [[recmolsok]] = sread [string recmolsoktok, '{v}'];
    local ligmolsoktok = db_GetEnv [dbkey, LIGOK];
    local [[ligmolsok]] = sread [string ligmolsoktok, '{v}'];

write ['R: {v}\nL: {v}\n', recmolsok, ligmolsok];//DEBUG
    return [recmolsok, ligmolsok];
endfunction

/****************************************************************************
 *
 *                          qb_InitCorePanel
 *
 *  Initialize the core panel window.
 *
 ****************************************************************************/
global function qb_InitCorePanel [wkey, status, defaults]
    status.prevwd = defaults.workdir;
    WindowSetData [wkey, dropfirst defaults];
    WindowSetAttr [wkey, [workdir: [sensitive: 1, allowBlank: 0],
        recbox: [sensitive: 0], recdb: [allowBlank: 1],
        posebox: [sensitive: 0], posedb: [allowBlank: 1],
        poseschg: [sensitive: 0]]];
    status = UpdateCharge [wkey, status];

    return status;
endfunction

/****************************************************************************
 *                          qb_LoadScoreDB
 *
 ****************************************************************************/
global function qb_LoadScoreDB [dbpath, type]

    local dbkey = db_Open [dbpath, 'read-write'];
    local dbtype = db_GetEnv [dbkey, DBTYPE];

    if type === 'nmrscore' and neL [dbtype, NMRSCORE] then
        db_Close dbkey;
        return [0, [], [], [], [], [], [],
            twrite ['{}\nis not a NMRScore Database.', dbpath]];
    endif

    if type === 'qmscore' and neL [dbtype, QMSCORE] then
        db_Close dbkey;
        return [0, [], [], [], [], [], [],
            twrite ['{}\nis not a QMScore Database.', dbpath]];
    endif

    local [rec, lig, status, coreopts, appopts, complex] = qb_GetEnv [dbkey];

    return [dbkey, rec, lig, status, coreopts, appopts, complex, ''];

endfunction

/****************************************************************************
 *                          qb_MergeDB
 *
 *  Perform a naive merge of the two databases (that is, assume the first
 *  row of data in srcname1 corresponds to the first row of data srcname2,
 *  etc.).  Only the fields are merged, the environment is ignored.
 *
 ****************************************************************************/
global function qb_MergeDB [srcname1, srcname2, dstname]

    local dstkey = db_Open [dstname, 'create'];
    local srckey1 = db_Open [srcname1, 'read'];
    local srckey2 = db_Open [srcname2, 'read'];
    local [fields1, ftypes1] = db_Fields srckey1;
    local [fields2, ftypes2] = db_Fields srckey2;

    apt db_EnsureField [dstkey,  fields1, ftypes1];
    apt db_EnsureField [dstkey,  fields2, ftypes2];

    local rowkey1 = 0, rowkey2 = 0;
    while (rowkey1 = db_NextEntry [srckey1, rowkey1])
        and (rowkey2 = db_NextEntry [srckey2, rowkey2]) loop
        local rowdata1 = db_Read [srckey1, rowkey1];
        local rowdata2 = db_Read [srckey2, rowkey2];
        db_Write [dstkey, 0, cat [rowdata1, rowdata2]];
    endloop

    db_Close dstkey;
    db_Close srckey1;
    db_Close srckey2;
endfunction

/****************************************************************************
 *                          qb_MolsChargeOK
 *
 *  Determine whether the given total charge of the molecules will result
 *  in a system with an even number of electrons.
 *
 ****************************************************************************/
global function qb_MolsChargeOK [recmols, recchg, ligmol, ligchg]

    local [osys, nsys] = SystemPush [];

    local ligchn = mol_Create ligmol;
    local ligatms = cat cAtoms ligchn;
    local ligok = ChargeOK [ligatms, ligchg];
    oDestroy ligchn;

    local recchns = app mol_Create recmols;
    local recatms = cat cAtoms recchns;
    local recok = ChargeOK [recatms, recchg];
    oDestroy recchns;

    SystemPop [osys, nsys];

    return [recok, ligok];

endfunction

/****************************************************************************
 *                          qb_SaveDivconStatus
 *
 *  Save the error/status message for the given row.
 *
 ****************************************************************************/
global function qb_SaveDivconStatus [dbkey, rowkey, message]

    local sep = "------------------------------------------------------------\n";
    local [status] = db_ReadFields [dbkey, rowkey, [STATUS_FIELD]];
    message = cat [message, sep, status];
    local fielddata = tag [STATUS_FIELD, [message]];
    db_Write [dbkey, rowkey, fielddata];

endfunction

/****************************************************************************
 *                          qb_SaveNMRScore
 *
 *  Save just the score data in the NMRScore database.
 *
 ****************************************************************************/
global function qb_SaveNMRScore [mdbkey, rowkey, scoredata, atomdata]
    scoredata = cat [tag [NMR_NUM_FIELDS, scoredata], atomdata];
    db_Write [mdbkey, rowkey, scoredata];

endfunction

/****************************************************************************
 *                          qb_SaveQMScore
 *
 *  Save just the score data in the QMScore database.
 *
 ****************************************************************************/
global function qb_SaveQMScore [mdbkey, rowkey, scoredata]

    if alltrue (QMS_DATA_TAGS === app first scoredata) then
        db_Write [mdbkey, rowkey, tag [QMS_NUM_FIELDS, 
            dropfirst app second scoredata]];
    endif

endfunction

/****************************************************************************
 *                          qb_SetUpScoreDB
 *
 *  Create the output database for storing Score results and ensure that
 *  the required fields are present.  Store the molecules and run options 
 *  in the DB environment.
 *
 *  Note:  it is assumed that this function is called from a child process
 *  and will exit on an error.
 *
 *  HACK alert:  add an extra flag to the LIGOK and RECOK flag vectors
 *  in order to force moe to treat is as them as vectors, not as scalars.
 *
 ****************************************************************************/
global function qb_SetUpScoreDB [status, coreopts, appopts, complex, fields,
        dbtype]

    local dbkey = db_Open [coreopts.scoredb, 'create'];
    SetScoreFields [dbkey, coreopts.mode === 'Many-to-Many', fields, dbtype];

    if coreopts.mode === 'One-to-One' or coreopts.mode === 'One-to-Many' then
        local [recset, ligand, errmess] = AtomsToMols [];
        if recset === [] or ligand === [] then
            Warning errmess;
            exit [];
        endif

        db_SetEnv [dbkey, RECOK, twrite ['{v}', [1, 0]]];
        SaveEnv [dbkey, recset, ligand, status, coreopts, appopts, complex, 
            dbtype];
    else
        SaveEnv [dbkey, [], [], status, coreopts, appopts, complex, dbtype];
    endif

    if coreopts.mode === 'One-to-One' then
        local posedata = tag [qb_GetPoseFields [], [ligand, coreopts.ligchg]];
        local stsmess = GetStatusMessage ['Receptor', 
            neL [status.recchg, 3]];
        stsmess = cat [stsmess, GetStatusMessage ['Ligand', 
            neL [status.ligchg, 3]]];
        posedata = cat [posedata, tag [[STATUS_FIELD], [stsmess]]];
        db_Write [dbkey, 0, posedata];
        db_SetEnv [dbkey, LIGOK, twrite ['{v}', [1, 0]]];

    else
        local posekey = db_Open [coreopts.posedb, 'read'];
        if dbkey === posekey then
            Warning twrite ['{} and {}\n are the same database.', 
                coreopts.scoredb, coreopts.posedb];
            exit [];
        endif

        if coreopts.mode === 'One-to-Many' then
            local pmess = CopyPoseDB [dbkey, posekey];
            if neL [pmess, ''] then
                db_Close posekey;
                db_Close dbkey;
                Warning pmess;
                exit [];
            endif
        else
            local reckey = db_Open [coreopts.recdb, 'read'];
            if dbkey === reckey then
                Warning twrite ['{} and {}\n are the same database.', 
                    coreopts.scoredb, coreopts.recdb];
                exit [];
            endif

            local rmess = CopyRecPoseDB [dbkey, reckey, posekey];
            if neL [rmess, ''] then
                db_Close reckey;
                db_Close posekey;
                db_Close dbkey;
                Warning rmess;
                exit [];
            endif

            db_Close reckey;
        endif

        db_Close posekey;
    endif

    return dbkey;
endfunction

/****************************************************************************
 *
 *                          qb_TagCoreVals
 *
 *  Tag the values from the core panel window.
 *
 ****************************************************************************/
global function qb_TagCoreVals [vals]

    vals.scoredb = fabsname vals.scoredb;
    vals.recdb = select ['', fabsname vals.recdb, vals.recdb === ''];
    vals.posedb = select ['', fabsname vals.posedb, vals.posedb === ''];

    local coreopts = tag [first tr CORE_OPT_DEFAULTS, [
        second first CORE_OPT_DEFAULTS,
        vals.mode, vals.cwd, vals.workdir,
        vals.scoredb,  vals.recdb, vals.posedb,
        vals.recchg, vals.ligchg, vals.poseschg]];

    return coreopts;
endfunction

/****************************************************************************
 *
 *                          qb_UpdateCorePanel
 *
 *  Initialize the core panel window.
 *
 ****************************************************************************/
global function qb_UpdateCorePanel [wkey, status, coreopts]

    WindowSetData [wkey, dropfirst coreopts];
    status = CheckCharge [wkey, status, coreopts.recchg, coreopts.ligchg];
    UpdateMode [wkey, coreopts.mode, status];
    status.prevwd = UpdateCWD [wkey, coreopts.cwd, coreopts.workdir, 
        coreopts.workdir];

    return status;
endfunction

/****************************************************************************
 *                          qb_VerifyCharges
 *
 *  Verify with the user that the current charges should be used even if
 *  they are problematic for Divcon.
 *
 *  Assumption:  called from MOE gui, not moebatch.
 *
 *
 ****************************************************************************/
global function qb_VerifyCharges [wkey, status, vals]

    if vals.mode === 'Many-to-Many' then
        status.verifychg = 1;
        return status;
    endif

    status = CheckCharge [wkey, status, vals.recchg, vals.ligchg];
    if status.ligchg === 3 or status.recchg === 3 then
        local which = GetWhich [status.recchg === 3, status.ligchg === 3];
        local ynmess = twrite [
            'Divcon is going to have problems\n'
            'with the {}.  Continue anyway?', which];
        if YesNo ynmess then
            status.verifychg = 1;
            return status;
        else
            status.verifychg = 0;
            return status;
        endif
    else
        status.verifychg = 1;
        return status;
    endif
endfunction

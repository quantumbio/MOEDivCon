#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2009 QuantumBio Inc. and/or its affiliates.
	
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

#set title   'QuantumBio NMRScore Interface'
#set class   'QuantumBio'
#set version '2009.01'
#set main 'qb_NMRScore'

/*  NOTE:  If you change the Key lists here, you need to update the
 *         Option lists and default indices in nmrpanel.svl.
 */

const GEOM_KEYS =
    [
    'NOOPT',
    'HONLYOPT',
    'ALLOPT'
    ];

global function qb_NMRScore [receptor_mols, ligand_mol, opts]

local errmess = [];
local workdir;
local subdirname;
if opts.pwd === 1 then
    workdir = getenv 'PWD';
else
    workdir = fabsname opts.workdir;
endif

    write ['Work Dir:  {}\n', workdir];  //DEBUG

if opts.task === [] then
    subdirname = workdir;
else
    subdirname = twrite ['{}/qb_out{n:}', workdir, opts.task];
    local okay = _fmkdir subdirname;
    if okay === -1 then
        errmess = swrite ['Unable to create subdirectory:  {}',
            subdirname];
        return [[], errmess];
    endif
endif

//  exe_open child process inherits parent's environment.
local process_key = exe_open ['moedivconnmr', subdirname, [], 1];
local process_keys = [process_key];
local status = exe_status process_keys;

local prios = exe_getpriority process_keys;
exe_setpriority [process_keys, prios];

local stdin = exe_stdin process_keys;
local stdout = exe_stdout process_keys;

//  Pass the two backbones to QuantumBio's Divcon NMRScore
//
//  SplitReceptor ensures that there is only one chain per molecule
//  in the receptor collection.

local retValue, success = 0;
local mol, molIndex, molCount, residueIndex, residueCount, atomIndex, atomCount;
molCount = length receptor_mols;
fwrite [stdin, '{n:}\n', molCount];
for molIndex = 1, molCount, 1 loop
    mol = receptor_mols(molIndex);
    atomIndex = 1;
    residueCount = mol(2)(MOL_CHAIN_NRES)(1);
    fwrite [stdin, '{n:}\n', residueCount];
    for residueIndex = 1, residueCount, 1 loop
        atomCount = mol(3)(MOL_RES_NATOMS)(residueIndex);
        fwrite [stdin, '{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex),
            mol(3)(MOL_RES_UID)(residueIndex), atomCount];
       for atomCount loop
            fwrite [stdin, '{c:} {c:} {n:.4f}\n',
                mol(4)(MOL_ATOM_NAME)(atomIndex),
                mol(4)(MOL_ATOM_EL)(atomIndex),
                mol(4)(MOL_ATOM_ION)(atomIndex)];
            fwrite [stdin, '{n:.4f} {n:.4f} {n:.4f}\n',
                mol(4)(MOL_ATOM_X)(atomIndex),
                mol(4)(MOL_ATOM_Y)(atomIndex),
                mol(4)(MOL_ATOM_Z)(atomIndex)];
            atomIndex = atomIndex + 1;
        endloop
    endloop
endloop

[retValue] = fread [stdout, '{n:}\n'];

//  There is only one molecule and one chain in the ligand/poses collection.
fwrite [stdin, '{n:}\n', 1];
mol = ligand_mol;
atomIndex = 1;
residueCount = mol(2)(MOL_CHAIN_NRES)(1);
fwrite [stdin, '{n:}\n', residueCount];
for residueIndex = 1, residueCount, 1 loop
    atomCount = mol(3)(MOL_RES_NATOMS)(residueIndex);
    fwrite [stdin, '{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex),
        mol(3)(MOL_RES_UID)(residueIndex), atomCount];
    for  atomCount loop
        fwrite [stdin, '{c:} {c:} {n:.4f}\n',
            mol(4)(MOL_ATOM_NAME)(atomIndex),
            mol(4)(MOL_ATOM_EL)(atomIndex),
            mol(4)(MOL_ATOM_ION)(atomIndex)];
        fwrite [stdin, '{n:.4f} {n:.4f} {n:.4f}\n',
            mol(4)(MOL_ATOM_X)(atomIndex),
            mol(4)(MOL_ATOM_Y)(atomIndex),
            mol(4)(MOL_ATOM_Z)(atomIndex)];
        atomIndex = atomIndex + 1;
    endloop
endloop

[retValue] = fread [stdout, '{n:}\n'];

local ligatmels = ligand_mol(4)(MOL_ATOM_EL);
local numligH = add eqE [ligatmels, 'H'];

local results, return_statement;
local sleep_time = 0.05, sleep_inc = 0.05;
while exe_status process_key loop
    if not MOE_BATCH then
        sleep sleep_time;
        sleep_time = min [1, sleep_time + sleep_inc];
    endif

    [[return_statement]] = fread [stdout, '{c:*}'];

    write ['Divcon: {}\n', return_statement];//DEBUG

    if return_statement === "updatescore" then
        local atomid, atomvalue;
        local numNMRH;
        [[numNMRH]] = fread [stdout, '{n:}'];
print [numligH,'numNMRH', numNMRH];	//DEBUG
        for numNMRH loop
            [[atomid]] = fread [stdout, '{n:}'];
            [[atomvalue]] = fread [stdout, '{n:}'];
print [atomid, atomvalue];	//DEBUG
            results = cat [results, [[atomid, atomvalue]]];
        endloop
        success = 1;
        fwrite [stdin, '{c:}\n', 'Ok'];

    elseif return_statement === "QBException" then
        [[return_statement]] = fread [stdout, '{c:*}'];
        while neL [return_statement, "Divcon done."] loop
            errmess = cat [errmess, return_statement];
            [[return_statement]] = fread [stdout, '{c:*}'];
        endloop;
        fwrite [stdin, '{c:}\n', 'Ok'];
    endif
endloop

exe_kill  [process_key, 0];
exe_kill  process_key;
exe_close process_keys;

//  Clean up working directory.
local templist = flist [subdirname, 'MOE_*.dmx*'];
templist = cat [templist, flist [subdirname, 'MOE_*.out']];

local fname = twrite ['{}/fort.8', subdirname];
if ftype fname === 'file' then
    templist = cat [templist, fname];
endif

//fdelete templist;//DEBUG

if success === 1 then
    return [results, []];
else
    return [[], errmess];
endif
endfunction


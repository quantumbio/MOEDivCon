#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2013 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif

function _Atoms;
function fwrite_PDB;
function pro_StandardRes;
function pro_PeptideFlags;
function StructurePreparationGUI; 

// QB tool box
function qbPrepareSystem;
function qbCorrectAtomNames;
function qbCheckLicense;
function qbGetResidueOnRadius;

// statics
static transFileName;
static residueNamesTaken;

local function GenerateBatchScript [opt,batchfilename]

    local shscr = fopenw batchfilename;
              //             1         2         3         4         5         6         7         8
              //    12345678901234567890123456789012345678901234567890123456789012345678901234567890
    fwrite [shscr, '#!/bin/bash\n\n'];
    fwrite [shscr, 'tmpQBHOME={}\n',getenv 'QBHOME'];
    fwrite [shscr, 'DIVCON=qmechanic\n'];

    fwrite [shscr, 'csvFileName={}\n', twrite ['{}-NMR.csv', opt.baseName]];
    fwrite [shscr, 'pdbFileName={}\n',twrite ['{}-NMR.pdb', opt.baseName]];
    fwrite [shscr, 'h5FileName={}\n',twrite ['{}-NMR.h5', opt.baseName]];
    fwrite [shscr, 'posesSDFname={}\n',ftail opt.posesSDF];
    
    local allKeys,allValues;
    
    fwrite [shscr, 'setNP={}\n',opt.setNP];
    fwrite [shscr, 'setMem={}\n',opt.setMem];
    if not isnull opt.siteatoms then
        local tmpSiteResidue = uniq aResidue opt.siteatoms;
        fwrite [shscr, 'selection="{}"\n',twrite ['/{}/{}/{}//', app token cLetter rChain tmpSiteResidue, rName tmpSiteResidue, rUID tmpSiteResidue]];
    endif
    fwrite [shscr, '    \n'];
    
                        //             1         2         3         4         5         6         7         8
                        //    12345678901234567890123456789012345678901234567890123456789012345678901234567890
    fwrite [shscr, 'errorOut()    \n'];
    fwrite [shscr, '{}\n',"{"];
    fwrite [shscr, '    echo    \n'];
    fwrite [shscr, '    echo "Usage: ./{} [--np=4]"    \n',batchfilename];
    fwrite [shscr, '    echo     \n'];
    fwrite [shscr, '    echo "Optional Command line arguments:"    \n'];
    fwrite [shscr, '    echo " --help           * Show this help and exit.           "\n'];
    fwrite [shscr, '    echo " --np=#           * Number of processors in simulation.           Current: $setNP"\n'];
    fwrite [shscr, '    echo " --m=#            * Amount of memory to use in GB.                Current: $setMem"\n'];
    fwrite [shscr, '    echo     \n'];
    fwrite [shscr, '    echo " see: http://www.quantumbioinc.com/support/"    \n'];
    fwrite [shscr, '    echo     \n'];
    fwrite [shscr, '    exit 1    \n'];
    fwrite [shscr, '}    \n'];
    fwrite [shscr, '        \n'];

    fwrite [shscr, 'while test $# -gt 0; do\n'];
    fwrite [shscr, '    case "$1" in\n'];
    fwrite [shscr, '        -*=*) optarg=`echo "$1" | sed \'s/[-_a-zA-Z0-9]*=//\'` ;;\n'];
    fwrite [shscr, '        *) optarg= ;;\n'];
    fwrite [shscr, '    esac\n'];
    fwrite [shscr, '    case $1 in\n'];
    fwrite [shscr, '        --help)    \n'];
    fwrite [shscr, '            errorOut    \n'];
    fwrite [shscr, '            ;;    \n'];
    fwrite [shscr, '        --np=*) \n'];
    fwrite [shscr, '            setNP=$optarg   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        --m=*) \n'];
    fwrite [shscr, '            setMem=$optarg   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        *)  \n'];
    fwrite [shscr, '            echo "ERROR: $optarg option unknown."  \n'];
    fwrite [shscr, '            errorOut  \n'];
    fwrite [shscr, '    esac    \n'];
    fwrite [shscr, '    shift   \n'];
    fwrite [shscr, 'done    \n'];
    fwrite [shscr, '        \n'];
    
    fwrite [shscr, 'function RunDivCon ()  \n'];
    fwrite [shscr, '{}   \n',"{"];
    fwrite [shscr, '    if [ -z "${}" ] ; then  \n', "{QBHOME}"];
    fwrite [shscr, '        if [ -e $tmpQBHOME/etc/qbenv.sh ] ; then      \n'];
    fwrite [shscr, '            DIVCON=$tmpQBHOME/bin/qmechanic      \n'];
    fwrite [shscr, '        elif hash qmechanic 2>/dev/null; then   \n'];
    fwrite [shscr, '            DIVCON=`which qmechanic`      \n'];
    fwrite [shscr, '        else  \n'];
    fwrite [shscr, '            echo "ERROR: DivCon not found at $tmpQBHOME"\n'];
    fwrite [shscr, '            echo "      source /path/to/DivConDiscoverySuite/etc/qbenv.sh and try again."\n'];
    fwrite [shscr, '            errorOut  \n'];
    fwrite [shscr, '        fi          \n'];
    fwrite [shscr, '    else  \n'];
    fwrite [shscr, '        DIVCON=$QBHOME/bin/qmechanic\n'];
    fwrite [shscr, '    fi          \n'];
    fwrite [shscr, '        \n'];
    fwrite [shscr, '    echo "NOTE: using DivCon installed at $DIVCON"\n'];
    fwrite [shscr, '        \n'];
    fwrite [shscr, '    qbdivconopt="$pdbFileName $posesSDFname $csvFileName $h5FileName -h mndo_nmr --np $setNP --print 2 --dc"\n'];
    
    fwrite [shscr, '    if [ ! -z "${}" ] ; then    qbdivconopt="$qbdivconopt --ligand-selection \'$selection\'"  ;   fi    \n',"{selection}"];
    fwrite [shscr, '    echo "$DIVCON $qbdivconopt"  \n'];
    fwrite [shscr, '    eval $DIVCON $qbdivconopt  \n'];
    fwrite [shscr, '}   \n'];
    fwrite [shscr, '        \n'];

    fwrite [shscr, 'function ProcessPackageFile    \n'];
    fwrite [shscr, '{}    \n',"{"];
    fwrite [shscr, '    outFileName=$1    \n'];
    fwrite [shscr, '    outFile=$2    \n'];
    fwrite [shscr, '        \n'];
    fwrite [shscr, '    if [ ! -e $outFileName ] ; then    \n'];
    fwrite [shscr, '        baseTranslatorTmp=`which openssl`    \n'];
    fwrite [shscr, '        if [ ! -z "${}" ] ; then    \n', "{baseTranslatorTmp}"];
    fwrite [shscr, '            baseTranslator="$baseTranslatorTmp base64 -d"    \n'];
    fwrite [shscr, '        else    \n'];
    fwrite [shscr, '            baseTranslatorTmp=`which base64`    \n'];
    fwrite [shscr, '            if [ ! -z "${}" ] ; then    \n', "{baseTranslatorTmp}"];
    fwrite [shscr, '                baseTranslator="$baseTranslatorTmp -d"    \n'];
    fwrite [shscr, '            else    \n'];
    fwrite [shscr, '                echo "ERROR: Script requires standard system installation of openssl or base64."    \n'];
    fwrite [shscr, '                echo "   Install openssl or place $outFileName in current directory and re-run."    \n'];
    fwrite [shscr, '                errorOut  \n'];
    fwrite [shscr, '            fi    \n'];
    fwrite [shscr, '        fi    \n'];
    fwrite [shscr, '        echo "$outFile" | $baseTranslator > $outFileName    \n'];
    fwrite [shscr, '    fi    \n'];
    fwrite [shscr, '}    \n'];
    fwrite [shscr, '        \n'];
    
    fwrite [shscr, '\ncsvFile=\'\n'];
    apt fwrite [shscr, '{}\n', r64_encodeln freadb [twrite ['{}-NMR.csv', opt.baseName],'char',INT_MAX]];
    fwrite [shscr, '\'\n'];
    fwrite [shscr, 'ProcessPackageFile $csvFileName "$csvFile"\n'];
    
    fwrite [shscr, '\npdbFile=\'\n'];
    apt fwrite [shscr, '{}\n', r64_encodeln freadb [twrite ['{}-NMR.pdb', opt.baseName],'char',INT_MAX]];
    fwrite [shscr, '\'\n'];
    fwrite [shscr, 'ProcessPackageFile $pdbFileName "$pdbFile"\n'];

    fwrite [shscr, '\nSDFile=\'\n'];
    apt fwrite [shscr, '{}\n', r64_encodeln freadb [opt.posesSDF,'char',INT_MAX]];
    fwrite [shscr, '\'\n'];
    fwrite [shscr, 'ProcessPackageFile $posesSDFname "$SDFile"\n'];

    fwrite [shscr, '\nRunDivCon\n'];
    
    fclose shscr;

endfunction

// Creates a "Create Batch File" panel.
// Returns the name of the proposed file if "Create" is pressed.
// Otherwise returns null.
// NOTE: based on dock_ui.svl available in MOE dist.
local function BatchPanel finame
    local wkey = WindowCreate [
        name: 'batchwin', windowName: 'batch',
        title: 'NMR: Create Batch File',
        text: ['Create', 'Cancel'],
        onTrigger: ['validate', 'return'],
        Hbox: [
            extendH: 1,
            FSBText: [
                name: 'batfile', len: 30,
                title: 'Batch File:',
                allowBlank: 0,
                mode: 'saveAs'
            ]
        ],

        Separator: [flushLeft: 1],

        Label: [ flushLeft: 1,
            text: 'See header of the batch file for usage information.'
        ]
    ];

    WindowSetData [wkey, [batfile: tok_cat [finame, '_batch.sh']]];
    WindowShow wkey;
    local [val, trig] = WindowWait wkey;
    WindowDestroy wkey;

    if val.batchwin == 'Create' then
        return val.batfile;
    else
        return [];
    endif
endfunction

// code between ======== copy/paste/edit from dock_ui.svl MOE 2012
// ============
const SETS = tr [
//                              S  L  R
    [ 'Dummy Atoms',            0, 0, 0, '$$dummy'      ],
    [ 'Ligand Atoms',           1, 1, 0, '$$ligand'     ],
    [ 'SDF File',               0, 1, 0, '$$ligfile'    ],
    [ 'Pocket Atoms',           0, 0, 0, '$$pocket'     ],
    [ 'Receptor Atoms',         0, 0, 1, '$$receptor'   ],
    [ 'Receptor+Solvent',       0, 0, 1, '$$recsolvent' ],
    [ 'All Atoms',              0, 0, 1, '$$all'        ],
    [ 'Selected Atoms',         1, 1, 1, '$$aselected'  ],
    [ 'Unselected Atoms',       0, 0, 1, '$$unselected' ],
    [ 'Selected Residue',       1, 1, 1, '$$rselected'  ],
    [ 'Selected Chains',        0, 0, 1, '$$cselected'  ],
    [ 'None (Wall Only)',	    0, 0, 0, '$$none'	]
];

local function StandardSetTitles what
    if     what == 'siteset' then what = 2;             // map category
    elseif what == 'ligset'  then what = 3;
    elseif what == 'recset'  then what = 4;
    else                          what = 4;
    endif

    local dynprio = SETS(what);
    local dynset = (SETS(5)|dynprio)[x_sort pack dynprio];
    local dyntitle = SETS(1)[indexof [dynset, SETS(5)]];

    local chains = Chains [];
    chains = chains | not m_findmatch ['[[]PRIVATE]*', cName chains];
    local ctag = diff [uniq sort cTag chains, ''];      // chain tags
    ctag = ctag | not m_findmatch ['DUMMY*PH4*', ctag];
    ctag = ctag | not m_findmatch ['$*', ctag];

    local sets = sortuniq oCollections [];             // named sets
    sets = sets | not m_findmatch [['[$.]*','*~'], sets];

    return [
	cat [dyntitle, sets],
	cat [dynset, sets]
    ];
endfunction
local function StandardSet [name, visible]
    local atoms;

	// Get Active atoms. An atom will be considered as active if there
	// is at least 1 atom which is active in the molecule.

    local a_atoms = Atoms [];
    a_atoms = split [a_atoms, mtoc m_uniq aMoleculeNumber a_atoms];
    a_atoms = a_atoms | app orE not aInert a_atoms;
    a_atoms = cat a_atoms;

    if name == '$$ligfile' then
	return [];
    elseif name == '$$none' then
	return [];
    elseif name == '$$recsolvent' then
	atoms = join [
	    uniq cat [ _Atoms '$$receptor', _Atoms '$$solvent'],
	    a_atoms
	];
    elseif name == '$$all' then
	atoms = Atoms[];
    elseif name == '$$unselected' then
	atoms = Atoms [] | not aSelected Atoms[];
    elseif m_findmatch ['$$*', name] then
	atoms = join [_Atoms name, a_atoms];
    elseif m_findmatch ['ctag$$*', name] then
	atoms = Chains[];
	atoms = atoms | cTag atoms == tok_drop [name, 6];
	atoms = cat cAtoms atoms;
    else
	atoms = cat oAtoms oGetCollection name;
    endif
    if istrue visible then
	atoms = atoms | not aHidden atoms;
    endif
    return join [atoms, _Atoms []]; 
endfunction

// ============

function qbGetAtomsInNMRCSV;
function qbFixChargedAtomsPanel; 
function qbCalcMemoryRequirementsInGB;
function qbSendAtomsToNMRCSV;

global function qbNMRPrepPanel[]

//        exit ['This tool is coming soon!\nPlease contact support@quantumbioinc.com for more information.'];

	if WindowShow ['NMRPrepPanel', 1] then
	    return;
	endif
	
// this function requires that the user already have a PDB file open and ready to run.
    if isnull Atoms[] then
        Warning 'Error:\nUse File->Open to open a molecule of interest\nprior to attempting NMR Preparation.';
        return;
    endif

    local pdbfile = cTag first Chains[];
    if isnull pdbfile then
        pdbfile = 'unknown.pdb';
    endif

    static s_sets, s_names, l_sets, l_names;
    local siteatoms, ligatoms;

    [s_sets, s_names] = StandardSetTitles 'siteset';
    [l_sets, l_names] = StandardSetTitles 'ligset';

    local config = gr_icon ['$MOE/lib/icon/config.ico', 12, 'foreground'];
    
    local strprep_info;
    
    local boundData, unboundData, setData;
    
    local function PercentProton []
        local totalAtomCnt = length cat Atoms[];
        local hAtomCnt = length cat [Atoms [] | aElement Atoms[] == 'H'];
        return hAtomCnt/totalAtomCnt;
    endfunction
    
    local hPercent = PercentProton[];
    const hCutOff = 0.49;
    strprep_info = twrite['Not performed and {f.1}% of atoms are protons',100*hPercent];

    local coreList = [];
    
	local wkey = WindowCreate
	[
	    name: 'panel',
	    title: 'NMR Preparation',
	    windowName: 'NMRPrepPanel',
	    text: ['Help','Batch...','Cancel'],
//	    onTrigger: ['return','validate','exit'],
	    onTrigger: ['return','validate','return'],
	    bubbleHelp: [
	    'Help, Guidelines, and Support',
		'Generate Batch script for DivCon-NMR...',
		'Cancel without creating DivCon-NMR run script.'
	    ],
        Group :
        [
            Vbox:
            [
                columns: 1,
                flushLeft: 1,
                extendH: 1,
                Text:
                [
                    name: 'baseName',
                    sensitive: 1,
                    title: 'Base Filename:',
                    type: 'char',
                    extendH: 1,
                    allowBlank: 0,
                    bubbleHelp:
                        'Choose base filename for use in NMRScore. Note: any spaces will be replaced with underscores.'
                ]
            ],
        Separator : [flushLeft:1],
            Mbox:
            [
                columns: 2,
                Button:
                [
                    title: 'Structure Preparation', name: 'button_MOEPreparation', graphics: config,
                    bubbleHelp: 
                        'Configure and run the MOE-based structure preparation.\n'
                        '   Warning, if less then 49% the atoms are protons. FIX: Run Protonate3D.\n'
                        '   Noted, if there was no change to the structure before and after structure preparation.\n'
                        '   Noted, if not performed.'
                ],
                Label :
                [ 
                    name: 'strprep_info', text: strprep_info, 
                    bubbleHelp: 
                        'Configure and run the MOE-based structure preparation.\n'
                        '   Warning, if less then 40% the atoms are protons. FIX: Run Protonate3D.\n'
                        '   Noted, if there was no change to the structure before and after structure preparation.\n'
                        '   Noted, if not performed.'
                ],
                Button:
                [
                    title: 'Stabilize Charge', name: 'button_FixCharge', graphics: config,
                    bubbleHelp: '(Optional) Stabilize charged atoms/residues through various means in order to encourage convergence.\n'
                                '   NOTE: This can be done after the NMR atoms of interest are chosen below.'
                ],
                Label :
                [ 
                    name: 'chgstabilize_info', text: '', 
                    bubbleHelp: '(Optional) Stabilize charged atoms/residues through various means in order to encourage convergence.\n'
                                '   NOTE: This can be done after the NMR atoms of interest are chosen below.'
                ]
            ]
        ],

        Separator : [flushLeft:1],
        Hbox:
        [
            Radio : [
                name	: 'calctype',
                title   : 'Calculation:',
                margin	: 1,
                columns	: 3,
                type	: 'int',
                flushLeft	: 1,
                extendH	: 1,
                onTrigger	: 'return',
                font	: 'mediumBold',
                text	: ['Shift','ShiftP','NMRScore'],
                bubbleHelp	: 
                    ['Calculate NMR Chemical Shift (CS) on all chosen atoms.',
                        'Calculate NMR Chemical Shift Perturbation (CSP) on all chosen atoms.',
                        'Calculate NMRScore on all chosen atoms.']
            ]
	    ],

        Vbox:
        [
            name:   'NMRScoreOptions',
            sensitive:0,
            Hbox:
            [
                Option:
                [
                    name: 'siteOptions',
                    title: 'NMR Selection:',
                    type: 'int',
                    text: s_sets,
                    onTrigger: 'return',
                    bubbleHelp: 'The NMR Selection that will be scored/removed prior to the pose placement.'
                ],
                Button:
                    [
                        name: 'button_ShowSelectionAtoms', text: '?', font: 'mediumBold',
                        bubbleHelp: 'Displays the approximate number of atoms that will be treated quantum mechanically.'
                    ],
                Label :
                [ 
                    name: 'siteOptions_info', text: '', 
                    bubbleHelp: 'NMR Selection can only include one (1) residue.'
                ]
            ],

            Hbox:
            [
                Option:
                [
                    name: 'ligandOptions',
                    title: 'Ligand Poses:',
                    type: 'int',
                    text: l_sets,
                    onTrigger: 'return',
                    bubbleHelp: 'The set of atoms (or file) that defines the ligand pose to score.'
                ],
                Button:
                    [
                        name: 'button_ShowLigandAtoms', text: '?', font: 'mediumBold',
                        bubbleHelp: 'Displays the atoms that will be treated .'
                    ],
                Label :
                [ 
                    name: 'ligandOptions_info', text: '', 
                    bubbleHelp: 'Unless SDF is chosen, the ligand atoms must be the same as the NMR Selection\n'
                                '   and can only be a single residue.'
                ]
            ],
            Hbox:
            [
                extendH: 1,
                FSBText: 
                [
                    name: 'posesSDF', len: 25, extendH: 1, sensitive: 0,
                    allowBlank: 1,
                    bubbleHelp:
                    'Choose SDF which has the poses to be scored.'
                ],
                Button: [   name: 'browse_posesSDF', text: 'Browse...', sensitive: 0    ]
            ]
        ],
            Separator : [flushLeft:1],
            Group : 
            [
                Vbox:   
                [
                title: 'NMR Atoms:',
                name: 'coreResidues',
                    Hbox:
                    [
                        columns:4,
                        Button:
                            [
                                name: 'retrieveSelection', 
                                text: 'Retrieve Selection',
                                bubbleHelp: 'Retrieve selected residues and add them to region refinement.'
                            ],
                        Button:
                            [
                                name: 'retrieveCSV', 
                                text: 'Retrieve CSV',
                                bubbleHelp: 'Retrieve experimental chemical shift data from QuantumBio-standard CSV NMR file.'
                            ],
                        Button:
                            [
                                name: 'button_ShowNMRAtoms', text: '?', font: 'mediumBold',
                                bubbleHelp: 'Displays the approximate number of atoms that will be treated quantum mechanically.'
                            ],
                        Button:
                            [
                                name: 'deleteSelection', 
                                text: 'X', font: 'mediumBold',flushLeft: 0,
                                bubbleHelp: 'Delete selected atom from the list.'
                            ]
                    ],
                    Data: [name:'CSVFileName'],
                    Listbox :
                        [
                        name: 'coreResiduesBox',
                        text: '',
                        width:30,
                        extendH:1,
                        header: 'Chain\tRes\tUID\tAtom',
                        onTrigger: 'return',
                        type: 'modint',
                        multiSelect: 0,
                        sortEnable: 1,
                        bubbleHelp:
                            'NMR Chemical shift (CS) calculations will be performed on each of these atoms.\n'
                            '   If SHIFT is chosen, only the CSs will be calculated.\n'
                            '   If ShiftP is chosen, the CS Perturbation (CSP) for each bound/unbound atom will be calculated.\n'
                            '   If NMRScore is chosen, the CSP RMSD (or NMRScore) will be calculated for each atom.\n'
                            '   The list may be expanded by selecting additional atoms in the MOE window and \n'
                            '   pressing the Retrieve Selection button above.'
                        ]                ],
                Hbox:
                [
                    name: 'expData',
                    columns:3,
                    Text:
                        [
                            name: 'expUnbound',
                            title:  'Unbound Shift: ',
                            type:   'real',
                            onTrigger: 'return',
                            allowBlank: 1,
                            bubbleHelp: 'Experimental unbound data (ppm).'
                        ],
                    Text:
                        [
                            name: 'expBound',
                            title:  'Bound Shift: ',
                            type:   'real',
                            onTrigger: 'return',
                            allowBlank: 1,
                            bubbleHelp: 'Experimental bound data (ppm).'
                        ],
                     Button:
                        [
                            name: 'button_SetExp', text: 'Set', font: 'mediumBold',
                            bubbleHelp: 'Sets the experimental bound/unbound shift data.'
                        ]
               ]
            ],
        Separator : [flushLeft:1],
        Mbox:
        [
            columns:2,
            flushLeft:0, 
            Text:
                [
                    name: 'setNP',
                    title: 'Processor Count: ',
                    type:   'int',
                    onTrigger: 'return',
                    allowBlank: 0,
                    shortcut: ['1','2','4','8','16'],
                    bubbleHelp: 'The QM calculation is fully threaded for multiple processors.'
                ],
                Label:
                    [
                        name: 'setMemLabel',
                        title: 'Memory (GB): ',
                        text: '--'
                    ],Data : [name:'setMem']
        ],
        Mbox:
        [
            columns: 2,
            Button:
            [
                title: 'Warnings', name: 'button_ShowWarnings', text: '?', font: 'mediumBold',
                bubbleHelp: 'If there are any warnings, they will appear here.'
            ],
            Label : [ name: 'warning_info' ]
        ]
	];
	
	local function updateCoreResidueList [coreList]
	    return apt twrite ['{}\t{}\t{}\t{}',app token cLetter aChain coreList, rName aResidue coreList, rUID aResidue coreList, aName coreList];
	endfunction
    
    local function ShowWarnings [wkey,trigger,values,status,siteatoms,ligatoms,is_file]
            local message = [];
            
            // check the NMR Selection and Ligand poses to make sure that they are correct
            local siteCorrect = 0;
            local ligandCorrect = 0;
            if (length uniq aResidue siteatoms) > 1 then
                WindowSetAttr[wkey, [ siteOptions_info: [text:'ERROR: >1 residue', foreground:'red']   ]];
            else
                siteCorrect = 1;
                WindowSetAttr[wkey, [ siteOptions_info: [text:'', foreground:'red']   ]];
            endif
            if (length uniq aResidue ligatoms) > 1 then
                WindowSetAttr[wkey, [ ligandOptions_info: [text:'ERROR: >1 residue', foreground:'red']   ]];
            else
                ligandCorrect = 1;
                WindowSetAttr[wkey, [ ligandOptions_info: [text:'', foreground:'red']   ]];
            endif
            if not is_file and not (ligatoms === siteatoms) then
                siteCorrect = 0;
                ligandCorrect = 0;
	            WindowSetAttr[wkey, [ ligandOptions_info: [text:'ERROR: no match site', foreground:'red']   ]];
	            WindowSetAttr[wkey, [ siteOptions_info: [text:'ERROR: no match ligand', foreground:'red']   ]];
	        endif
	        if (not is_file and not length ligatoms) then 
                ligandCorrect = 0;
	            WindowSetAttr[wkey, [ ligandOptions_info: [text:'ERROR: ligand empty', foreground:'red']   ]];
            endif	        
	        if (not length siteatoms) then
                siteCorrect = 0;
	            WindowSetAttr[wkey, [ siteOptions_info: [text:'ERROR: site empty', foreground:'red']   ]];
            endif
	        if values.calctype == 1 then
	            siteCorrect = 1;
                ligandCorrect = 1;
            endif
            WindowSetAttr [wkey, [panel: [sensitive: [1,(siteCorrect and ligandCorrect),1]]]];
            // we dont support alternate atom positions yet
            local alt_atoms = cat app oGetCollection findmatch ['PDB_ALTLOC_[A-Z,a-z,0-9]', oCollections[]];
            local commonAtoms = join [alt_atoms,Atoms[]];
            if not isnull commonAtoms then
                local inResidues = uniq cat aResidue commonAtoms;
                message = twrite ['Residues {} have alternative conformations.\nDisorder in the QM Region is not supported at this time and will be removed at runtime\n(e.g. highest occupied or "A" conformation will be included in QM calculation).\n\n',
                    apt twrite ['{}:{}:{}',cName rChain inResidues, rName inResidues, rUID inResidues]];
            endif
            
            if not status.ran_structprep then
                message = twrite ['{}Structure preparation was not executed during this session.\n\n',message];
            elseif not status.structprep_changed then
                message = twrite ['{}Structure preparation was executed, but no changes were observed in structure.\n\n',message];
            endif
            
            // update information in the window
            WindowSetAttr[wkey, [ 
                chgstabilize_info : [text:twrite ['There are {} charged atoms in the structure.',length (Atoms [] | aFCharge Atoms [] <> 0)] ] 
            ]];
            if not isnull message then
                message = twrite ['WARNING(S):\n\n{}',message];
                WindowSetAttr[wkey, [ warning_info: [text:'Click to see detailed warnings', foreground:'red']   ]];
                if trigger === 'inbatch' then
                    message = twrite ['{}Continue?\n',message];
                    return NoYes message;
                elseif trigger === 'button_ShowWarnings' then
                    Warning message;
                endif
            else
                WindowSetAttr[wkey, [ warning_info: [text:'None']   ]];
            endif
            return 1;
    endfunction

    WindowSetAttr[wkey,[
            coreResiduesBox:[text : updateCoreResidueList[coreList],value: [igen length coreList]],
            setNP: [value:2],
            baseName:   [value:fbase ftail pdbfile]
    ] ];
    local values, trigger;
    local ynMemIsSet = 0;
    values = WindowValues wkey;
	local status;
	status.ran_protonate = 0; status.ran_structprep = 0; status.structprep_changed = 0;

	local function setCalcValues [wkey,values]
	    if isnull values then
	        values = WindowValues wkey;
	    endif
        if values.calctype == 2 then
            WindowSetAttr[wkey,
            [
                NMRScoreOptions:    [sensitive:1],
                expData:            [sensitive:0]
            ]];
        elseif values.calctype == 1 then
            WindowSetAttr[wkey,
            [
                NMRScoreOptions:    [sensitive:0],
                expData:            [sensitive:0]
            ]];
        elseif values.calctype == 3 then
            WindowSetAttr[wkey,
            [
                NMRScoreOptions:    [sensitive:1],
                expData:            [sensitive:1]
            ]];
        endif
	endfunction
	
    setCalcValues [wkey];

    WindowSetAttr[wkey, [ setMem: [value:status.memory] ]];
        
    values = WindowValues wkey;
    siteatoms = StandardSet s_names(values.siteOptions);
    ligatoms = StandardSet l_names(values.ligandOptions);

    local prevAtoms = Atoms[];
    if second task_fork [] == 'child' then
        task_settitle [ task_key -1, 'update_QBmemory'];
        status.memory = 2 * qbCalcMemoryRequirementsInGB[Atoms[],values.setNP];
        WindowSetAttr[wkey, [ setMemLabel: [text: [twrite['{}',status.memory] ]], setMem: [value: [twrite['{}',status.memory]]] ]];
        exit[];
    endif
    ShowWarnings [wkey,trigger,values,status,siteatoms,ligatoms, l_names(values.ligandOptions) == '$$ligfile'];
	WindowShow wkey;
	local tmpFile;
	local selectedAtomID;
	local is_file;
    loop
        [values, trigger] = WindowWait wkey;
  // write ['DEBUG: {} | {}\n', values, trigger];
        if trigger === 'expUnbound' or trigger === 'expBound' or trigger === 'button_SetExp' then
            selectedAtomID = bitshr [second values.coreResiduesBox,WMOD_NBITS];
            if selectedAtomID > 0 then
                unboundData.(totok coreList(selectedAtomID)) = values.expUnbound;
                boundData.(totok coreList(selectedAtomID)) = values.expBound;
                setData.(totok coreList(selectedAtomID)) = 1;
            endif
        elseif trigger === 'button_ShowNMRAtoms' then
            aSetSelected [coreList, 1];
        elseif trigger === 'button_ShowLigandAtoms' then
            aSetSelected [ligatoms, 1];
        elseif trigger === 'button_ShowSelectionAtoms' then
            aSetSelected [siteatoms, 1];
        elseif trigger === 'siteOptions' then
            siteatoms = StandardSet s_names(values.siteOptions);
            if l_names(values.ligandOptions) <> '$$ligfile' then
                values.ligandOptions = indexof [s_names(values.siteOptions),l_names];
                WindowSetAttr [wkey, [ligandOptions: [value:values.ligandOptions]]];
                ligatoms = StandardSet l_names(values.ligandOptions);
            endif
        elseif trigger === 'ligandOptions' then
            ligatoms = StandardSet l_names(values.ligandOptions);
	        is_file = l_names(values.ligandOptions) == '$$ligfile';
	        WindowSetAttr [wkey, [ 
	            posesSDF:           [sensitive: is_file],
	            browse_posesSDF:    [sensitive: is_file]
	        ]];
        elseif trigger === 'calctype' then
            setCalcValues [wkey, values];
            is_file = l_names(values.ligandOptions) == '$$ligfile';
            WindowSetAttr [wkey, [ 
                posesSDF:           [sensitive: is_file],
                browse_posesSDF:    [sensitive: is_file]
            ]];
        elseif trigger === 'button_MOEPreparation' then
            local before_run = length cat Atoms[];
            StructurePreparationGUI[cmd:'interactive'];
            status.ran_structprep = 1;
            sleep 2.0;      // needs a couple of seconds to init StructurePrep function
            WindowShow [wkey, 0];
            while WindowKey 'Structure Preparation' loop
                sleep 0.15;
                if WindowKey 'Protonate3D' then
                    status.ran_protonate = 1;
                endif
            endloop
            hPercent = PercentProton[];
            local after_run = length cat Atoms[];
            if hCutOff > hPercent then
                WindowSetAttr[wkey,[strprep_info: [text:twrite['Warning: only {}% of atoms are protons', 100*hPercent]]]];
            elseif before_run == after_run then
                WindowSetAttr[wkey,[strprep_info: [text:'Note: no change in structure.']]];
                status.structprep_changed = 0;
            else
                WindowSetAttr[wkey,[strprep_info: [text:'MOE preparation Ran']]];
                status.structprep_changed = 1;
            endif
            WindowShow[wkey,1];
        elseif trigger === 'coreResiduesBox' then
            selectedAtomID = bitshr [second values.coreResiduesBox,WMOD_NBITS];
            if selectedAtomID > 0 then
                Isolate [coreList(selectedAtomID),Atoms[]];
                WindowSetAttr[wkey,
                [
                    expUnbound: [value:unboundData.(totok coreList(selectedAtomID))],
                    expBound: [value:boundData.(totok coreList(selectedAtomID))]                
                ]];
            endif
        elseif trigger === 'deleteSelection' then
            selectedAtomID = first values.coreResiduesBox;
            if not isnull selectedAtomID then
                local newSelectedID = selectedAtomID - 1;
                if selectedAtomID == 1 then
                    newSelectedID = 1;
                endif
                local tmpMask;
                tmpMask = m_id coreList;
                tmpMask(selectedAtomID) = 0;
                coreList = coreList | tmpMask;
                local tmpexpUnbound;
                local tmpexpBound;
                if length coreList > 0 then
                    tmpexpUnbound = unboundData.(totok coreList(newSelectedID));
                    tmpexpBound = boundData.(totok coreList(newSelectedID));
                else
                    tmpexpUnbound = [];
                    tmpexpBound = [];
                endif

                WindowSetAttr[wkey, 
                [
                    coreResiduesBox: 
                    [ 
                        text:   updateCoreResidueList[coreList],
                        value:  [newSelectedID]
                    ],
                    expUnbound: [value:tmpexpUnbound],
                    expBound: [value:tmpexpBound] 
                ]];

            endif
        elseif trigger === 'retrieveSelection' then
            local newSelectedList = diff[Atoms [] | aSelected Atoms [],coreList];
            local newSelected;
            for newSelected in newSelectedList loop
                local prevLenCoreList = length coreList;
                coreList = cat [coreList, newSelected];
                boundData.(totok newSelected) = 0;
                unboundData.(totok newSelected) = 0;
                setData.(totok newSelected) = 0;
                WindowSetAttr[wkey,
                [
                    coreResiduesBox: 
                        [
                        text:   updateCoreResidueList[coreList],
                        value:  [1]
                        ],
                    expUnbound: [value:unboundData.(totok coreList(1))],
                    expBound: [value:boundData.(totok coreList(1))]
                ]];
            endloop
        elseif trigger === 'retrieveCSV' then
            tmpFile = FilePrompt [title:'Select QuantumBio Standard NMR CSV file', mode:'open', filter:'*.csv', multi:0];
            local [tmpCoreList,tmpBoundData,tmpUnboundData] = qbGetAtomsInNMRCSV [tmpFile];
            boundData = uniq cat [boundData,tmpBoundData];
            unboundData = uniq cat [unboundData,tmpUnboundData];
            coreList = uniq cat [coreList,tmpCoreList];
            WindowSetAttr[wkey,
            [
                coreResiduesBox: 
                    [
                    text:   updateCoreResidueList[coreList],
                    value:  [1]
                    ],
                expUnbound: [value:unboundData.(totok coreList(1))],
                expBound: [value:boundData.(totok coreList(1))],
                CSVFileName: [value:tmpFile]
            ]];
        elseif trigger === 'button_FixCharge' then
            tmpCoreList = [];
            tmpCoreList.coreList = coreList;
            qbFixChargedAtomsPanel[tmpCoreList];
            WindowShow[wkey,1];
        elseif trigger === 'browse_posesSDF' then
            local poseFile = FilePrompt [title:'Select Pose SDF', mode:'open', filter:'*.sdf', multi:0];
            if not isnull poseFile then
                WindowSetAttr[wkey,[posesSDF: [value:poseFile]]];
            endif
        elseif trigger === 'panel' then
            if values.(trigger) == 'Batch...' then
                local baseNameString = swrite ['{}', values.baseName];
                baseNameString[cat indicesof[" ",baseNameString]] = "_";
                values.baseName = token baseNameString;
                WindowSetAttr[wkey, [ baseName:   [value:values.baseName]  ]];
                                
                local batchname = [];
                if ShowWarnings [wkey,'inbatch',values,status,siteatoms,ligatoms, l_names(values.ligandOptions) == '$$ligfile'] then
                    batchname = BatchPanel values.baseName;
                endif

                if not isnull batchname then
                    if values.calctype == 1 then    // Shifts alone
                        siteatoms = [];
                        ligatoms = [];
                    endif
                    if values.calctype <> 3 then    // NOT NMRScore
                        for selectedAtomID in coreList loop
                            boundData.(totok selectedAtomID) = [];
                            unboundData.(totok selectedAtomID) = [];
                        endloop
                    endif
                    if length uniq aResidue siteatoms == 1 then
                        values.siteatoms = siteatoms;
                        values.ligatoms = ligatoms;
                    endif
                    WritePDB[twrite['{}-NMR.pdb',values.baseName]];
                    qbSendAtomsToNMRCSV[twrite['{}-NMR.csv',values.baseName],coreList,boundData,unboundData];
                    GenerateBatchScript[values,batchname];
                    break;
                endif
            elseif values.(trigger) == 'Help' then
                LaunchDocument '$QBHOME/doc/help-refine.html';
            elseif values.(trigger) == 'Cancel' then
                break;
            endif
        endif
        ShowWarnings [wkey,trigger,values,status,siteatoms,ligatoms,l_names(values.ligandOptions) == '$$ligfile'];
        if not (Atoms[] === prevAtoms) then
            prevAtoms = Atoms[];
            task_kill (task_keylist [] | task_title task_keylist [] == 'update_QBmemory');    // kill other memory update tasks
            if second task_fork[master:'parent'] == 'child' then
                task_settitle [ task_key -1, 'update_QBmemory'];
                
                if second task_fork [master:'parent'] === 'child' then          // this will give the user some feedback
                    task_settitle [ task_key -1, 'mem_progress'];
                    local loopCount = '|';
                    loop
                        sleep 0.5;
                        if loopCount == '|' then
                            loopCount = '/';
                        elseif loopCount == '/' then
                            loopCount = '-';
                        elseif loopCount == '-' then
                            loopCount = '\\';
                        elseif loopCount == '\\' then
                            loopCount = '|';
                        endif
                        WindowSetAttr[wkey, [ setMemLabel: [text: [twrite['{}',loopCount] ]], setMem: [value: [twrite['-10']]] ]];
                    endloop
                    exit[];
                endif
                status.memory = 2 * qbCalcMemoryRequirementsInGB [Atoms[],values.setNP];
                task_kill (task_keylist [] | task_title task_keylist [] == 'mem_progress');
                WindowSetAttr[wkey, [ setMemLabel: [text: [twrite['{}',status.memory] ]], setMem: [value: [twrite['{}',status.memory]]] ]];
                exit[];
            endif
        endif
    endloop
    // clean up some items and then close out
    task_kill (task_keylist [] | task_title task_keylist [] == 'update_QBmemory');    // kill other memory update tasks
    WindowDestroy wkey;
endfunction

local function Label_Atom [atoms,labels,gobj_token,gobj_key]

    if isnull atoms then
        atoms = Atoms[];
    endif
    if isnull labels then
        return;
    endif
    if isnull gobj_key then
        gobj_key = GCreate '';
    endif
    if isnull gobj_token then
        gobj_token = 'unknown labels';
    endif
    
    GSetTitle [gobj_key,gobj_token];

    local atom;
    for atom in atoms loop
        GText cat [gobj_key,aColor atom, aPos atom + 0.1, totok labels(cat indexof [atom, atoms])];
    endloop
    
    return gobj_key;
    
endfunction

function qbListModels;
function qbRetrieveChemicalShifts;
function qbRetrieveNMRScore;
function ReadHDF5;
function qbRetrieveLigandSelection;

global function qbNMRAnalizePanel[]

	if WindowShow ['NMRAnalizePanel', 1] then
	    return;
	endif

	local wkey = WindowCreate
	[
	    name: 'panel',
	    title: 'NMR Analysis',
	    windowName: 'NMRAnalizePanel',
	    text: ['Help','Close'],
	    onTrigger: ['return','return'],
	    bubbleHelp: [
	    'Help, Guidelines, and Support',
		'Close the analysis.'
	    ],
        Group :
        [
            Hbox:
            [
                extendH: 1,
                FSBText: 
                [
                    name: 'completedHDF', len: 25, extendH: 1, sensitive: 1,
                    title: 'DivCon File:',
                    allowBlank: 0,
                    bubbleHelp:
                    'Choose HDF5 file from completed simulation.'
                ],
                Button: [   name: 'browse_HDF', text: 'Browse...', sensitive: 1    ]
            ],
            Separator : [flushLeft:1],
            Mbox:
            [
                name: 'processShifts',
                columns: 1,
            Hbox:
            [
                Listbox :
                    [
                    name: 'scoresBox',
                    text: '',
                    width:50,
                    extendH:1,
                    header: 'Ligand\tNMRScore\tH-NMRScore\tC-NMRScore',
                    onTrigger: 'return',
                    type: 'modint',
                    multiSelect: 0,
                    sortEnable: 1,
                    bubbleHelp:
                        'If several ligands (in addition to Wildtype) were chosen with the use of an SDFile, they will be listed here.\n'
                        '   The NMRScore will be displayed as well if experimental values were provided.'
                    ] 
            ],
            Separator : [flushLeft:1],
            Hbox:
            [
                Radio : [
                    name	: 'calctype',
                    title   : 'Calculation:',
                    margin	: 1,
                    columns	: 3,
                    type	: 'int',
                    flushLeft	: 1,
                    extendH	: 1,
                    onTrigger	: 'return',
                    font	: 'mediumBold',
                    text	: ['Bound Shift','Unbound Shift','CSP'],
                    bubbleHelp	: 
                        ['Display NMR Bound Chemical Shift (CS) on all chosen atoms.',
                            'Display NMR Unbound Chemical Shift (CS) on all chosen atoms.',
                            'Display NMR Chemical Shift Perturbation (CSP) on all chosen atoms.']
                ]
	        ],
	        Mbox:
	        [
	            columns:    5,
	            Checkbox: [
	                name    :   'showColors',
	                title   :   '',
	                onTrigger:  'return',
	                bubbleHelp: ['Color atoms based on available shift values. White means no calculated values available.']
	            ],
	            Label : [flushLeft:1, title: 'Color Atoms'],
	            Checkbox: [
	                name    :   'showLabels',
	                title   :   '',
	                onTrigger:  'return',
	                bubbleHelp: ['Label atoms based on available shift values.']
	            ],
	            Label : [flushLeft:1, title: 'Label Shifts'],
                Option:
                [
                    name: 'eleOptions',
                    onTrigger : 'return',
                    type: 'char',
                    bubbleHelp: 'Structure factor column within MTZ file.'
                ]
	        ]
	        ]
	    ]
    ];
    
    WindowSetAttr[wkey,[ processShifts: [ sensitive:0 ] ] ];
    
    WindowShow wkey;
    
    function ColorAtomsByValue[values,chemicalShifts]
        if values.showColors == 0 then
            return;
        endif
        aSetRGB[Atoms[], rep [bytepack3 [255,255,255],length Atoms[]]];     // change all atoms to white

        local interestAtoms = get [Atoms[],chemicalShifts.Index];
        aSetHidden [rAtoms uniq aResidue interestAtoms, 0];
        local elements;
        if values.eleOptions == 'All' then
            elements = uniq aElement interestAtoms;
        else
            elements = values.eleOptions;
        endif
        local element;
        for element in elements loop
            local interestAtomsMask = aElement interestAtoms == element;
            
            local maxShift, minShift , normalizedShifts;
            if values.calctype == 1 then
                maxShift = max (chemicalShifts.'Bound Shift' | interestAtomsMask);
                minShift = min (chemicalShifts.'Bound Shift' | interestAtomsMask);
                normalizedShifts = ((chemicalShifts.'Bound Shift' | interestAtomsMask) / maxShift);
            elseif values.calctype == 2 then
                maxShift = max (chemicalShifts.'Unbound Shift' | interestAtomsMask);
                minShift = min (chemicalShifts.'Unbound Shift' | interestAtomsMask);
                normalizedShifts = ((chemicalShifts.'Unbound Shift' | interestAtomsMask) / maxShift);
            elseif values.calctype == 3 then            // CSP
                maxShift = max ((chemicalShifts.'Bound Shift' - chemicalShifts.'Unbound Shift') | interestAtomsMask);
                minShift = min ((chemicalShifts.'Bound Shift' - chemicalShifts.'Unbound Shift') | interestAtomsMask);
                normalizedShifts = (((chemicalShifts.'Bound Shift' - chemicalShifts.'Unbound Shift') | interestAtomsMask) / maxShift);
            endif
            if maxShift < 0 then
                normalizedShifts = normalizedShifts * -1;
            endif

            aSetRGB[(interestAtoms | interestAtomsMask) | (normalizedShifts >= 0), 
                    bytepack3 [
                        255,
                        round ( (1 - (normalizedShifts | (normalizedShifts >= 0)))*255),
                        round ( (1 - (normalizedShifts | (normalizedShifts >= 0)))*255)
                    ]];

            aSetRGB[(interestAtoms | interestAtomsMask) | (normalizedShifts < 0), 
                    bytepack3 [
                        round ( (1 + (normalizedShifts | (normalizedShifts < 0)))*255),
                        round ( (1 + (normalizedShifts | (normalizedShifts < 0)))*255),
                        255
                    ]];
        endloop
        aSetColorBy [Atoms[],'rgb'];
    endfunction
    
    function LabelAtomsByValue[values,chemicalShifts]

        static gobj_key;

        if not isnull gobj_key then
            GDestroy gobj_key;
        endif
        if values.showLabels == 0 then
            return;
        endif

        gobj_key = GCreate '';

        local interestAtoms = get [Atoms[],chemicalShifts.Index];
        local elements;
        if values.eleOptions == 'All' then
            elements = uniq aElement interestAtoms;
        else
            elements = values.eleOptions;
        endif
        local element;
        for element in elements loop
            local interestAtomsMask = aElement interestAtoms == element;
            aSetHidden [rAtoms uniq aResidue (interestAtoms | interestAtomsMask), 0];
            local normalizedShifts;
            local label_token;
            if values.calctype == 1 then
                normalizedShifts = (chemicalShifts.'Bound Shift' | interestAtomsMask);
                label_token = 'Bound Shift Labels';
            elseif values.calctype == 2 then
                normalizedShifts = (chemicalShifts.'Unbound Shift' | interestAtomsMask);
                label_token = 'Unbound Shift Labels';
            elseif values.calctype == 3 then            // CSP
                normalizedShifts = ((chemicalShifts.'Bound Shift' - chemicalShifts.'Unbound Shift') | interestAtomsMask);
                label_token = 'CSP Labels';
            endif
            gobj_key = Label_Atom [interestAtoms | interestAtomsMask,(ceil (normalizedShifts * 10))/10,label_token,gobj_key];
        endloop
    endfunction
    
    function GetChemicalShifts [wkey, hdfFile, target, poseMols]
        local values = WindowValues wkey;
        local errorcode;
        local ligand;
        static poseChains,prevPoseMols,chemicalShifts;
        if neL [prevPoseMols,poseMols] then
            poseChains = [];
            chemicalShifts = [];
            prevPoseMols = poseMols;
        endif

        local selectedLigandID = bitshr [second values.scoresBox,WMOD_NBITS];
        if selectedLigandID > 0 then
            ligand = (first untag poseMols)(selectedLigandID);
            oDestroy poseChains;
            poseChains = mol_Create poseMols.(totok ligand);
            [chemicalShifts,errorcode] = qbRetrieveChemicalShifts [hdfFile, target, ligand];
            local runSelectionResidue;
            if ligand <> 'Wildtype' then
                [runSelectionResidue,errorcode] = qbRetrieveLigandSelection [hdfFile,target];
                local inAtomList = diff [Atoms [], uniq cat rAtoms ((Residues[])(runSelectionResidue.ligandSelection+1))];
                chemicalShifts.Index = indexof [get [inAtomList,chemicalShifts.Index],Atoms[]];
            endif
            local elements = cat ['All',sort uniq aElement get[Atoms [], chemicalShifts.Index]];
            WindowSetAttr[wkey,[ eleOptions: [ text:elements ] ] ];
        endif
        return chemicalShifts;
    endfunction
    
    local hdfModels,chemicalShifts, nmrscores, tmpLigand, ligandlist, poseMols;
    local atomColors, allScores;
    local errorcode;
    loop
        local [values, trigger] = WindowWait wkey;
//        write ['DEBUG: {} | {}\n', values, trigger];
        if trigger === 'browse_HDF' then
            local hdfFile = FilePrompt [title:'Select HDF5 File', mode:'open', filter:'*.h5', multi:0];
            if not isnull hdfFile then
                values.showLabels=0;
                LabelAtomsByValue[values];
                oDestroy Chains[];
                allScores = [];
                poseMols = [];
                [hdfModels,errorcode] = qbListModels hdfFile;
                if not isnull hdfModels.target then
                    ReadHDF5[hdfFile,[model:hdfModels.target]];
                    ligandlist = uniq cat ['Wildtype',hdfModels.ligand]; // TODO: check for selection first
                    for tmpLigand in ligandlist loop
                        [nmrscores,errorcode] = qbRetrieveNMRScore [hdfFile, hdfModels.target,tmpLigand];
                        if errorcode <> '' then
                            nmrscores = rep ['',4];
                            nmrscores(1) = tmpLigand;
                        endif
                        allScores = append[allScores,nmrscores];
                    endloop
                    allScores = tr allScores;
                    WindowSetAttr[wkey,[scoresBox: [
                        text:apt twrite['{}\t{}\t{}\t{}',allScores(1),allScores(2),allScores(3),allScores(4)],
                        value:[igen length ligandlist]
                        ]]];
                    
                    // read in and store all of the mols
                    local pdata = SystemPush [];
                    for tmpLigand in ligandlist loop
                            poseMols.(totok tmpLigand) = ReadHDF5[hdfFile,[model:hdfModels.target,ligand:tmpLigand,center:0,return_data:1]];
                    endloop
                    SystemPop pdata;

                    chemicalShifts = GetChemicalShifts [wkey, hdfFile, hdfModels.target,poseMols];
                    View[];
                    atomColors = aColorBy Atoms[];
                    WindowSetAttr[wkey,[ processShifts: [ sensitive:1 ] ] ];
                    WindowSetAttr[wkey,[completedHDF: [value:hdfFile]]];
                else
                    Warning [twrite ['Read error: {}',hdfFile]];
                endif
            endif
        elseif trigger === 'showColors' then
            if values.showColors == 1 then
                atomColors = aColorBy Atoms[];
                chemicalShifts = GetChemicalShifts [wkey, hdfFile, hdfModels.target, poseMols];
                ColorAtomsByValue[values,chemicalShifts];
            else
                aSetColorBy [Atoms[],atomColors];
            endif
            LabelAtomsByValue[values,chemicalShifts];
        elseif trigger === 'scoresBox' then
            chemicalShifts = GetChemicalShifts [wkey, hdfFile, hdfModels.target, poseMols];
            ColorAtomsByValue[values,chemicalShifts];
            LabelAtomsByValue[values,chemicalShifts];
        elseif trigger === 'showLabels' then
            chemicalShifts = GetChemicalShifts [wkey, hdfFile, hdfModels.target, poseMols];
            ColorAtomsByValue[values,chemicalShifts];
            LabelAtomsByValue[values,chemicalShifts];
        elseif trigger === 'calctype' then
            chemicalShifts = GetChemicalShifts [wkey, hdfFile, hdfModels.target, poseMols];
            ColorAtomsByValue[values,chemicalShifts];
            LabelAtomsByValue[values,chemicalShifts];
        elseif trigger === 'eleOptions' then
            chemicalShifts = GetChemicalShifts [wkey, hdfFile, hdfModels.target, poseMols];
            ColorAtomsByValue[values,chemicalShifts];
            LabelAtomsByValue[values,chemicalShifts];
        elseif trigger === 'panel' then
            if values.(trigger) == 'Close' then
                break;
            elseif values.(trigger) == 'Help' then
                LaunchDocument '$QBHOME/doc/help-refine.html';
            endif
        endif
    endloop
    values.showLabels=0;
    LabelAtomsByValue[values];
    WindowDestroy wkey;
endfunction
#eof

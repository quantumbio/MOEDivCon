#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2012 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

/****************************************************************************
 *                                qbmmmin.svl
 *
 *  Perform energy minimization using the OPLS-AA + Solvation forcefield
 *  on the complexes stored in the MOEDivCon QMScore database using the
 *  given weight on heavy atoms only.
 *
 *  If the mode of the QMScore database is 'One-to-Many', it is changed to
 *  a 'Many-to-Many' database so that a new copy of the receptor is minimized
 *  with each pose and the resulting structures are stored in the database.
 *
 *  Note:  The new structures overwrite those currently stored in the database,
 *  so it is advised that you create a backup before calling the script.
 *
 *  From the MOE documentation for MM:
 *
 *    A quadratic force to the starting geometry is added to the atoms in an
 *    attempt to keep the resulting minimum close to the original coordinates. 
 *    A force constant of 300 is comparable to the strength of a bond. A tether
 *    value greater than or equal to 100 000 is interpreted to mean a fixed
 *    atom; that is, atoms that are tethered with a weight greater than or
 *    equal to 100 000 are frozen during the calculation. 
 *
 *  Warning:  Atoms that have been fixed or tethered via other MOE methods
 *  will affect the minimization calculation.
 *
 *
 *  Main function:
 *
 *    qb_MMMinDB [dbpath, weight]
 *
 *  Arguments:
 *    
 *    dbpath : token : path to the MOEDivCon database.
 *
 *    weight : number : tether weight.
 *
 *  Example moebatch call:
 *
 *    moebatch -exec "run ['qbmmmin.svl', ['qmscore.mdb', 100]]" -exit
 *
 ****************************************************************************/
#set title   'QuantumBio MM Minimization'
#set class   'QuantumBio'
#set version '2010.01'
#set main 'qb_MMMinDB'

function qb_GetColFields;
function qb_GetCoreEnv;
function qb_GetPoseFields;
function qb_GetRecFields;
function qb_IsModeOneToMany;
function qb_IsModeOneToOne;
function qb_IsModeManyToMany;
function qb_IsModeSinglePoint;
function qb_IsQMScoreDatabase;
function qb_SaveCoreEnv;
function qb_SetModeManytoMany;

function MM;
function PartialCharge;

local function tetherMMMin [weight]

	pot_SetCharges [];

    local atoms = Atoms [];
    local m = aMMType atoms == '??';
    if anytrue m then
	    write ['\nWARNING:  There are unparameterized atoms in the system.\n\n'];
    endif

    local tetherWeight = rep [weight, length atoms];
    (tetherWeight | aAtomicNumber atoms <= 1) = 0;

    MM [
        tetherWeight:    tetherWeight,
        gtest:           0.05,
        keep_chirality:  '',
        pot_finalize:    0,
        pot_charge:      0
    ];

endfunction

global function qb_MMMinDB [dbpath, weight]

    if neL [fext dbpath, 'mdb'] then
        exit twrite ['{}\nis not a MOE database.', dbpath];
    endif

    if neL [ftype dbpath, 'file'] then
        exit twrite ['Unable to find the database:\n    {}', dbpath];
    endif

    local dbkey = db_Open [dbpath, 'read-write'];

    //  Exit if not QMScore database
    if not qb_IsQMScoreDatabase dbkey then
        db_Close dbkey;
        exit twrite ['{}\nis not a MOEDivCon QMScore database.', dbpath];
    endif

    local dbrowkeys = db_Entries dbkey;
    local rowkey = first dbrowkeys;

    local [recmol, ligmol, status, coreopts, complex] = qb_GetCoreEnv [dbkey];
    local recchg = coreopts.recchg, ligchg = coreopts.ligchg;
    local recchns, ligchns, newrecmol, newligmol;

    local osys, nsys, oldpotinfo, oldpotsetup;
    if not MOE_BATCH then 
        [osys, nsys] = SystemPush [];
        oldpotinfo = pot_Info [];
        oldpotsetup = pot_Setup [];
    endif

    local potfile = tok_cat [MOE, '/lib/oplsaa.ff'];
    pot_Load potfile;

    pot_Setup
        [
        strEnable:1, angEnable:1, stbEnable:1, oopEnable:1, torEnable:1,
        vdwEnable:1, eleEnable:1, solEnable:1, resEnable:1, strWeight:1, 
        angWeight:1, stbWeight:1, oopWeight:1, torWeight:1, vdwWeight:1, 
        eleWeight:1, solWeight:1, cutoffEnable:1, cutoffOn:8, cutoffOff:10, 
        angForm:0, eleDist:0, vdwScale14:0.5, vdwBuffer1:0, vdwBuffer2:0, 
        eleScale14:0.5, eleDielectric:1, eleBuffer:0, solDielectric:80, 
        solDielectricOffset:0, state0:1, state1:0, state2:1, threadCount:0
        ];

    if qb_IsModeSinglePoint [coreopts] then
        recchns = mol_Create recmol;

        tetherMMMin weight;

        newrecmol = mol_Extract recchns;
        newrecmol(1)(MOL_NAME) = recmol(1)(MOL_NAME);

        recmol = newrecmol;

        local coldata = tag [qb_GetColFields [], [recmol, recchg]];
        rowkey = db_Write [dbkey, rowkey, coldata];

        oDestroy Chains [];

    elseif qb_IsModeOneToOne [coreopts] then
        recchns = mol_Create recmol;
        ligchns = mol_Create ligmol;

        tetherMMMin weight;

        newrecmol = mol_Extract recchns;
        newrecmol(1)(MOL_NAME) = recmol(1)(MOL_NAME);
        newligmol = mol_Extract ligchns;
        newligmol(1)(MOL_NAME) = ligmol(1)(MOL_NAME);

        recmol = newrecmol;
        ligmol = newligmol;

        local posedata = tag [qb_GetPoseFields [], [ligmol, ligchg]];
        rowkey = db_Write [dbkey, rowkey, posedata];

        oDestroy Chains [];

    else
        local rownum = 1, recbasename = '';
        local recflds = qb_GetRecFields [dbkey];
        if qb_IsModeOneToMany [coreopts] then
            apt db_EnsureField [dbkey, recflds, ['molecule', 'int']];
            db_FieldPrefix [dbkey, recflds];
            local idx = indexof ["=", string recmol(1)(MOL_NAME)];
            if idx > 0 then
                recbasename = tok_drop [recmol(1)(MOL_NAME), idx];
            endif
        endif

        local poseflds = qb_GetPoseFields [dbkey];

        for rowkey in dbrowkeys loop
            write ['\nRow {}:\n', rownum];

            local rowdata = db_Read [dbkey, rowkey];
            if qb_IsModeManyToMany [coreopts] then
                [recmol, recchg] = tagget [rowdata, recflds];
            endif

            [ligmol, ligchg] = tagget [rowdata, poseflds];
            recchns = mol_Create recmol;
            ligchns = mol_Create ligmol;

            tetherMMMin weight;

            newrecmol = mol_Extract recchns;

            if qb_IsModeOneToMany [coreopts] then
                local recname = tok_cat ['rec', totok rownum];
                if tok_length recbasename > 0 then
                    recname = tok_cat [recname, '=', recbasename];
                endif

                newrecmol(1)(MOL_NAME) = recname;
            else
                newrecmol(1)(MOL_NAME) = recmol(1)(MOL_NAME);
            endif


            newligmol = mol_Extract ligchns;
            newligmol(1)(MOL_NAME) = ligmol(1)(MOL_NAME);

            rowdata = tagput [rowdata, recflds, [newrecmol, recchg]];
            rowdata = tagput [rowdata, poseflds, [newligmol, ligchg]];
            db_Write [dbkey, rowkey, rowdata];

            oDestroy Chains [];
            rownum = rownum + 1;
        endloop

        //  Change mode from one-to-many to many-to-many.
        if qb_IsModeOneToMany [coreopts] then
            coreopts = qb_SetModeManytoMany [coreopts];
        endif

        recmol = [];
        ligmol = [];
    endif

    qb_SaveCoreEnv [dbkey, recmol, ligmol, status, coreopts, complex];
    db_Close dbkey;

    if not MOE_BATCH then 
        SystemPop [osys, nsys]; 

        pot_Load oldpotinfo.filename;
        pot_Setup oldpotsetup;
    endif

endfunction




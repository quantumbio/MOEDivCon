#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2013 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif

// example: qbmoebatch -exec "run ['qbPhenixPrep.svl',['3V7Y.pdb',[enableAutoPrep:0,enableProtonate:1,enableLigFix:0],['test.cif','test2.cif']],'qbPhenixPrepFile']" -exit

// example: qbmoebatch -exec "run ['qbPhenixPrep.svl',['1A2C-phenix.pdb','1A2C-phenix.translation'],'qbPostPhenixFile']" -exit

function _Atoms;
function fwrite_PDB;
function pro_StandardRes;
function pro_PeptideFlags;

function CIF_fread_cif_all;
function cif_ExtractInfo;

// QB tool box
function qbPrepareSystem;
function qbCorrectAtomNames;
function qbCheckLicense;

// statics
static transFileName;
static residueNamesTaken;

const CORE_DEFAULTS = [
    enableAutoPrep:0,       // Run the MOE structure preparation tool.
    enableProtonate:1,      // Turns on Protonate3D
    protPH:7.4,              // Set pH for Protonation
    enableLigFix:0,          // Fixes the ligand protonation
    enableCIFprotons:1      // protonates structure based on CIF file prior to further processing
];

const PREPDEFAULTS = cat [CORE_DEFAULTS,[
    forceUseElement:1,         // force reading of the element in the PDB file. Not a good idea if file format broken.
    qmApplication:[],       // Skip the DivCon tests - we will be running no matter what since this is refinement.
    enableCIFprotons:1      // protonates structure based on CIF file prior to further processing
]];

// Source code between  // ===================== lines based on code provided by CCG 1/2013
// ===================== 
const MONLIB_CIF_DICT = [
    '_chem_comp.number_atoms_all':'int',
    '_chem_comp.number_atoms_nh':'int',
    '_chem_comp_atom.charge':'float',
    '_chem_comp_atom.partial_charge':'float',
    '_chem_comp_atom.x':'float',
    '_chem_comp_atom.y':'float',
    '_chem_comp_atom.z':'float',
    '_chem_comp_bond.value_dist':'float',
    '_chem_comp_bond.value_dist_esd':'float',
    '_chem_comp_angle.value_angle':'float',
    '_chem_comp_angle.value_angle_esd':'float',
    '_chem_comp_tor.value_angle':'float',
    '_chem_comp_tor.value_angle_esd':'float',
    '_chem_comp_tor.period':'float',
    '_chem_comp_plane_atom.dist_esd':'float'
];

local function cif2mol[ cif_file, root ]
    root = tolower root;

    local c = CIF_fread_cif_all [cif_file, MONLIB_CIF_DICT];
    local tt = tok_cat[ 'comp_', root ];
    local nn = length c.(tt).'_chem_comp_atom.atom_id';
    local x0 = rep[ 0, nn ];
    c.(tt).'_chem_comp_atom.x' = x0;
    c.(tt).'_chem_comp_atom.y' = x0;
    c.(tt).'_chem_comp_atom.z' = x0;

    local d = cif_ExtractInfo [c.(tt), [hetnam: string toupper root,
	    type:'monlibcif', havechg: 0, verbose:1]];
    return first d.models;
endfunction

// JT: takes atom keys from a template (dictionary), modify the ionization
//     state of the molecule and assign all the matching names from the
//     dictionary.
local function matchHydrogens[ cif_file, inResidue, root ]
    local amol = cat rAtoms inResidue;
    local amol_num = uniq aMoleculeNumber amol;
    if length amol_num <> 1 or 
        length cat amol <> length cat [Atoms[] | indexof[ aMoleculeNumber Atoms[], amol_num ]] then
        write ['WARNING: {} residue {}:{} can not be processed with CIF-protonation\n\t(e.g. not single, complete, small molecule, residue)\n',rName inResidue, cName rChain inResidue, rUID inResidue];
        return [];
    endif
    
	// Match heavy atoms of each molecule
	// in a separate system
	// Idea: strip off hydrogens, set ionization
	// to zero and used the PrioSMI function
	// to find matching heavy (between dictionary and molecule)
	// IMPORTANT: it is expected that the two molecules have
	// the same connection table and differ only by the
	// ionization of their heavy atoms

    local sys_info = SystemPush amol;
    local m_h = (aElement Atoms[]) == 'H';
    oDestroy (Atoms[] | m_h);
    aSetIon[ Atoms[], 0 ];
    local x_smi_mol_heavy = aPrioSMI Atoms[];
    local s_heavy_mol = oSerialNumber Atoms[];
    local amolHeavyCnt = length cat Atoms[];
    SystemPop sys_info;

    sys_info = SystemPush[];
    local adict = first cAtoms first mol_Create cif2mol[ cif_file, root ];
    local name_prio = aName adict[ x_sort aPrioSMI adict ];
    m_h = (aElement Atoms[]) == 'H';
    local ion_heavy = aIon (Atoms[]| not m_h);
    oDestroy (Atoms[] | m_h );
    aSetIon[ Atoms[], 0 ];
    local ions_ordered_dict_heavy = ion_heavy[ x_sort aPrioSMI Atoms[] ];
    local cifHeavyCnt = length cat Atoms[];
    SystemPop sys_info;

    if amolHeavyCnt == cifHeavyCnt then
    // first test to make sure that this works as planned.
        sys_info = SystemPush amol;
        local testAmol = cat Atoms[];
        local amoli = testAmol[ pack indexof[ s_heavy_mol, oSerialNumber testAmol ]];
        local amolisorted = amoli[ x_sort x_smi_mol_heavy ];
 write ['BEFORE: {}\n', aIon testAmol];
        aSetIon[ amolisorted, ions_ordered_dict_heavy ];
write ['AFTER: {}\n', aIon testAmol];
        Add_H testAmol;
        local testAtmCnt = length cat Atoms[];
        SystemPop sys_info;
        if testAtmCnt == length name_prio then
            amoli = amol[ pack indexof[ s_heavy_mol, oSerialNumber amol ]];
            amolisorted = amoli[ x_sort x_smi_mol_heavy ];
            aSetIon[ amolisorted, ions_ordered_dict_heavy ];
            Add_H amol;
            amol = cat rAtoms inResidue;
            local x_smi_mol  = aPrioSMI amol;
            aSetName[  amol[ x_sort x_smi_mol ], name_prio ];
        else
            amol = [];
        endif
    else
        amol = [];
    endif
    if isnull amol then
        write ['WARNING: {} residue {}:{} can not be processed with CIF-protonation\n\t(e.g. due to disagreement in atom count between CIF and PDB)\n',rName inResidue, cName rChain inResidue, rUID inResidue];
    endif
    return amol;
endfunction

local function applycif[ cif_file, root, atoms ]

    local newnames = [];
    
    if ftype cif_file === '' then
        write ['WARNING: CIF filename {} not found!\n', cif_file];
        return newnames;
    endif
        
    local mol = cif2mol[ cif_file, root ];
    local dict_ckeys = mol_Create mol;
    local dict_akeys = cat cAtoms dict_ckeys;

    oDestroy dict_ckeys;
    
	// Map the names using unique smiles sorting

    local sys_info = SystemPush atoms;
    atoms = Atoms[];

    dict_ckeys = mol_Create mol;
    dict_akeys = cat cAtoms dict_ckeys;
    
    if length dict_akeys === length atoms then

        local x_smi_dict = aPrioSMI dict_akeys;
    
        local sorted_dictname = aName ( dict_akeys[ x_sort x_smi_dict ] );
    
        local x_smi_mol = aPrioSMI atoms;
        local x_mol = x_sort x_smi_mol;
        local sorted_akeys = atoms[ x_sort x_smi_mol ];
        if sort aPrioZQH atoms === sort aPrioZQH dict_akeys then
            newnames = sorted_dictname[ x_smi_mol ];
        endif
    endif

    SystemPop sys_info;
    return newnames;

endfunction

// lmw - occasionally the MOE PDB read/writer will manipulate atom names.
//      This function will return whether or not this is the case.
local function DoubleCheckCIFNames[inResidue,names]
    local mol = mol_Extract inResidue;
    local pdata = SystemPush [];
    fwrite_PDB ['1234567890-tmp.pdb',mol_Create mol];
    local testChains = ReadPDB['1234567890-tmp.pdb'];
    fdelete '1234567890-tmp.pdb';
    local newnames = cat aName rAtoms cResidues testChains;
    SystemPop pdata;
    return sort newnames === sort names;
endfunction

local function ProcessCIF[ cif_file, inResidue ]
    local atoms = cat rAtoms inResidue;
    local root = token first wordsplit[ string ftail[ cif_file], ".cif"];
    local names = applycif[ cif_file, root, atoms ];
    
    if not isnull names and DoubleCheckCIFNames[inResidue,names] then
        write [' INFO: Use  {} for residue {} {}:{}\n', cif_file, rName inResidue, cName rChain inResidue, rUID inResidue];
        aSetName[ atoms, names ];
        residueNamesTaken = uniq sort cat [rName inResidue, residueNamesTaken];
        return inResidue;
    else
        write ['WARNING: incomplete representation for {} residue {}:{}\n', rName inResidue, cName rChain inResidue, rUID inResidue];
    endif
endfunction

local function recursiveDirectoryList[directory]
    if isnull directory then
        return [];
    endif
    local list = flist directory;
    local tmpdir, filelist;
    for tmpdir in list loop
        if ftype tmpdir == 'dir' then
            filelist = append [filelist, recursiveDirectoryList[tmpdir]];
        else
            filelist = append [filelist, tmpdir];
        endif
    endloop  
    return cat filelist;
endfunction

local function GetRNamesFromCIF[ciffiles,tmpResidue]
    local tmpCIFfile = [];
    if isnull ciffiles then
        return tmpCIFfile;
    endif
    
    for tmpCIFfile in ciffiles loop
        local c = CIF_fread_cif_all [tmpCIFfile, MONLIB_CIF_DICT];
    
        local x;
        local availableResEntries = [];
        for x = 2, length c, 1 loop
            availableResEntries = cat [availableResEntries, token toupper second fieldsplit[string first cat c[x], "_"]];
        endloop
        if length join [availableResEntries, rName tmpResidue] > 0 then ; return tmpCIFfile; endif
    endloop
    return [];
endfunction

local function ProtonateBasedOnCif [residueList,ciffiles]
    local filelist = [];
    local fixedAtoms;
    if not isnull getenv 'PHENIX' then
        filelist = recursiveDirectoryList[tok_cat [getenv 'PHENIX', '/chem_data/']];
    endif
    if isnull cat [ciffiles,filelist] then
        write ['NOTE: No CIF files processed for protonation.\n'];
        return fixedAtoms;
    endif
    local tmpResidue;
    for tmpResidue in residueList loop
        local cifFile = GetRNamesFromCIF[ciffiles,tmpResidue];
        if isnull cifFile then
            cifFile = first cat [ fabsname filelist | fbase ftail filelist == rName tmpResidue ];
        endif
        if not isnull cifFile then
            write [' INFO: Attempting to use {} for protonation of {} residue {}:{}\n', cifFile, rName tmpResidue, cName rChain tmpResidue, rUID tmpResidue];
            fixedAtoms = cat [fixedAtoms, matchHydrogens[cifFile, tmpResidue, rName tmpResidue]];
        endif
    endloop
    return fixedAtoms;
endfunction

local function RenameBasedOnCIF [residueList,ciffiles]
    local phenixdb;
    if not isnull getenv 'PHENIX' then
        phenixdb = tok_cat [getenv 'PHENIX', '/chem_data/'];
        write ['NOTE: Using Phenix cif database found at {}\n', phenixdb];
    else
        write ['\n'];
           //            1         2         3         4         5         6         7         8
           //   12345678901234567890123456789012345678901234567890123456789012345678901234567890
        write ['WARNING: In order to attempt the use of CIF-based naming, you must supply path \n'];
        write ['         to PHENIX cif database using $PHENIX environment variable as per \n'];
        write ['         PHENIX documentation.\n'];
        if isnull ciffiles then
            write ['\n'];
            return[];
        else
            write [' NOTE: Attempting to use CIF files provided.\n\n'];
        endif
    endif

    local tmpResidue;
    local residuesToRemove;
    local filelist = recursiveDirectoryList[phenixdb];
    for tmpResidue in residueList loop
        local cifFile = GetRNamesFromCIF[ciffiles,tmpResidue];
        if isnull cifFile then
            cifFile = first cat [ fabsname filelist | fbase ftail filelist == rName tmpResidue ];
        endif
        if not isnull cifFile then
            write [' INFO: Attempting to use {} for {} residue {}:{}\n', cifFile, rName tmpResidue, cName rChain tmpResidue, rUID tmpResidue];
            residuesToRemove = cat [residuesToRemove, ProcessCIF[cifFile,tmpResidue]];
        else
            write ['WARNING: no CIF file found for {} residue {}:{} \n', rName tmpResidue, cName rChain tmpResidue, rUID tmpResidue];
        endif
    endloop
    return residuesToRemove;
endfunction
// ===================== 

local function WriteResidue [outResidues]
    local fileHandle;
    static newResidueName;
    if isnull newResidueName then newResidueName = '100'; endif;
    local residueName = toupper rName first outResidues;
    if length pack indexof [residueNamesTaken,residueName] then
        fileHandle = fopenx transFileName;
        if newResidueName == '100' then
            fileHandle = fopenw transFileName;
                            //            1         2         3         4         5         6         7         8
                            //   12345678901234567890123456789012345678901234567890123456789012345678901234567890
            fwrite [fileHandle, '# The following is a list of temporary residue name translations. These \n'];
            fwrite [fileHandle, '# translations are provided in order to address Phenix atom/residue name \n'];
            fwrite [fileHandle, '# requirements. Upon completion of refinement, these translations can be \n'];
            fwrite [fileHandle, '# applied to recreate original using:\n'];
            fwrite [fileHandle, '# qbmoebatch -exec "run [\'qbPhenixPrep.svl\',[\'POSTPHENIX.pdb\',\'{}\'],\'qbPostPhenixFile\']"\n',transFileName];
        else
            fileHandle = fopenx transFileName;
            fileHandle = fseek [fileHandle, fsize fileHandle];
        endif
        local oldResidueName = residueName;
        residueName = totok [atoi newResidueName + 1];
        newResidueName = residueName;
        rSetName [outResidues, newResidueName];
        write ['NOTE (residue name conversion): {} = {} < {} >\n', newResidueName, oldResidueName, apt twrite ['{}:{}',cName rChain outResidues,rUID outResidues]];
        fwrite [fileHandle, ' {} = {} < {} >\n', newResidueName, oldResidueName, apt twrite ['{}:{}',cName rChain outResidues,rUID outResidues]];
        fclose fileHandle;
    endif

    local mol = mol_Extract first outResidues;
    local pdata = SystemPush [];
    residueNamesTaken = cat [residueNamesTaken,residueName];
    fwrite_PDB [twrite ['{}.pdb',residueName],mol_Create mol];
    SystemPop pdata;
    write [' INFO: Use {}.pdb for residue {}\n', residueName, rName outResidues];

endfunction

function GetDistanceToLigand[inResidue]

    local ligandPositions = cat _Atoms '$$ligand';
    local residuePosiions = cat rAtoms inResidue;
    if isnull ligandPositions or isnull residuePosiions then
        return 'NONE';
    endif

    local atomA, atomB;
    local shortDistance = 10000;
    for atomA in ligandPositions loop
        for atomB in residuePosiions loop
            local tmpValue = sqrt add pow [sub [aPos atomA, aPos atomB],2];
            if tmpValue < shortDistance then
                shortDistance = tmpValue;
            endif
        endloop
    endloop
    
    return shortDistance;

endfunction

local function FindPeptideBreaks[inChains]

    if isnull inChains then
        inChains = Chains[];
    endif
    local tmpChain;
    for tmpChain in inChains loop
        local residueList = cat cResidues tmpChain;
        residueList = residueList | rAtomCount residueList;
        residueList = diff [residueList, uniq aResidue _Atoms '$$solvent'];
        residueList = diff [residueList, uniq aResidue _Atoms '$$ligand'];
        local x = 1;
        while x < length residueList loop
            if not cat pro_PeptideFlags cat [residueList(x),residueList(x+1)] then
                write ['WARNING: No Peptide Bond: {} {}:{} ({} A) and {} {}:{} ({} A)\n',
                    rName residueList(x), cName rChain residueList(x), rUID residueList(x), GetDistanceToLigand residueList(x),
                    rName residueList(x+1), cName rChain residueList(x+1), rUID residueList(x+1),GetDistanceToLigand residueList(x+1)];
            endif
            x = x + 1;
        endloop
    endloop
    
endfunction

local function RenameProtonsInOrder[inResidues]
    local inResidue;
    for inResidue in inResidues loop
        local allAtoms = cat rAtoms inResidue;
        local tmpHatom, Hcount = 0;
        
        for tmpHatom in cat [allAtoms | aAtomicNumber allAtoms == 1] loop
            Hcount = Hcount + 1;
            aSetName [tmpHatom, twrite ['{}{}','H',Hcount]];
        endloop
    endloop
endfunction

local function ResiduePreparation []
    local testResidues = cat
        [pro_StandardRes[],'HOH','ASH','CYX','DA','DT','DG','DC','A','U','G','C',toupper el_Elements[]];
    local residueList = Residues[] | m_join [rName Residues [], testResidues] == 0;
    write ['Residues to treat: {}\n', uniq rName residueList];
    return residueList;
endfunction

local function InputInputFiles[inpdbfile,forceUseElement]
    oDestroy Chains[];
    local tmpIn;
    tmpIn.alt_loc = 1;
    tmpIn.install_cryst = 1;
    tmpIn.use_element = forceUseElement;
    return length ReadPDB[inpdbfile,tmpIn];
endfunction

local function OutputInputFiles[residueList,ciffiles,filebase]
    // address a MOE-ism that renames HIS residues based on protonation
    rSetName [cat [Residues [] | rName Residues [] == 'HIP'],'HIS'];
    rSetName [cat [Residues [] | rName Residues [] == 'HID'],'HIS'];
    rSetName [cat [Residues [] | rName Residues [] == 'HIE'],'HIS'];

    transFileName = twrite['{}-phenix.translation',filebase];
    residueList = diff [residueList,RenameBasedOnCIF[residueList,ciffiles]];

    local data = app aName rAtoms residueList;
    data = app sort data;
    residueList = uniq residueList[x_sort data];

    local tmpIndexGrp;
    for tmpIndexGrp in indicesof [uniq x_fsort data,x_fsort data] loop
        WriteResidue[residueList[tmpIndexGrp]];
    endloop

    FindPeptideBreaks[];

    WritePDB[twrite['{}-phenix.pdb',filebase],[cryst1:1]];
endfunction

global function qbPhenixPrep [filebase,opt,ciffiles]
    // WARNING: removal/circumvention of license check code is a direct violation of license agreement!
    if not qbCheckLicense[] then
        return;
    endif
    local residueList = ResiduePreparation[];
    
    if opt.enableCIFprotons then
        opt.notProtAtomList = aNumber ProtonateBasedOnCif[residueList,ciffiles];
    endif

    qbPrepareSystem [opt];
    OutputInputFiles[residueList,ciffiles,filebase];
endfunction

global function qbPhenixPrepFile[inpdbfile,opt,ciffiles]
    opt = tagcat[opt, PREPDEFAULTS];
    if not InputInputFiles[inpdbfile,opt.forceUseElement] then
        return;
    endif

    qbPhenixPrep[fbase inpdbfile,opt,ciffiles];
endfunction

global function qbPostPhenix [inpdbfile,trFile]
    if isnull trFile then
        trFile = twrite ['{}.translation',fbase inpdbfile];
    endif

    local fileHandle = fopenr [trFile];
    local line;
    while length (line = freadb [fileHandle, 'line', 1]) loop
        line = cat line;
        if line(1) <> "#" then
            local newName = first wordsplit [line, " "];
            local oldName = third wordsplit [line, " "];
            newName = token newName;
            oldName = token oldName;
            write ['  INFO: rename {} to {}\n', newName, oldName];
            rSetName [Residues [] | rName Residues [] == newName,oldName];
        endif
    endloop
    fclose fileHandle;
endfunction

global function qbPostPhenixFile [inpdbfile,trFile]
    oDestroy Chains[];
    if not length ReadAuto[inpdbfile] then;
        return;
    endif
    qbPostPhenix[inpdbfile,trFile];
    WritePDB[twrite['{}-after.pdb',fbase inpdbfile]];
endfunction

global function qbPhenixPrepPanel[]

	local wkey = WindowCreate [
	    name: 'shell',
	    title: 'Prepare System',
	    text: ['Close'],
	    onTrigger: ['exit'],
	    bubbleHelp: [
		'Close after performing above steps...'
	    ],

        Button :
            [
            name: 'button_selectPDB', text : 'Select PDB',
            bubbleHelp:
                'Read in PDB file you wish to refine.'
            ],

	    Label :
	        [
	        name: 'cifftxt', text: 'User-provided CIF Files:'
	        ],
        Listbox :
            [
            name: 'ciffilesBox',text: '',width:30,
            bubbleHelp:
                'If PHENIX environment variable is set per PHENIX documentation,\n'
                'CIF files will be used. Additional CIF files can be chosen here.'
            ],
        Button : [ name: 'browse_ciffiles', text: 'Browse...' ],
        
        Button :
            [
            name: 'button_cifProtonation', text : 'CIF Protonation',
            bubbleHelp:
                'User-provided CIF files along with PHENIX-provided CIF files can\n'
                'be used for protonation.'
            ],

        Button :
            [
            name: 'button_MOEPreparation', text : 'MOE-based Preparation',
            bubbleHelp:
                'User-provided CIF files along with PHENIX-provided CIF files can\n'
                'be used for protonation.'
            ],
	    	    
        Button :
            [
            name: 'button_GenerateFiles', text : 'Generate Input Files',
            bubbleHelp:
                'User-provided CIF files along with PHENIX-provided CIF files can\n'
                'be used for protonation.'
            ]
	    	    

	];

	WindowShow wkey;
	local ciffiles;
	local pdbfile = cTag first Chains[];
    local residueList = ResiduePreparation[];
    loop
        local [values, trigger] = WindowWait wkey;
        if trigger === 'browse_ciffiles' then
            ciffiles = FilePrompt [title:'Select User CIF Files',mode:'open',filter:'*.cif',multi:1];
            WindowSetAttr[wkey,[ciffilesBox: [text:ciffiles]]];
        elseif trigger === 'button_selectPDB' then
            pdbfile = FilePrompt [title:'Select PDB File',mode:'open',filter:'*.pdb',multi:0];
            if not isnull pdbfile then
                InputInputFiles[pdbfile,1];
                residueList = ResiduePreparation[];
            endif
        elseif trigger === 'button_cifProtonation' then
            aSetSelected [ ProtonateBasedOnCif[residueList,ciffiles] ,1 ];
        elseif trigger === 'button_MOEPreparation' then
            run 'structprep_ui.svl';
        elseif trigger === 'button_GenerateFiles' then
            OutputInputFiles[residueList,ciffiles,fbase ftail pdbfile];
        elseif trigger === 'shell' then
            break;
        endif
    endloop
    WindowDestroy wkey;
endfunction

#eof

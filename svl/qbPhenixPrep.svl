#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2013 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif

// example: qbmoebatch -exec "run ['qbPhenixPrep.svl',['3V7Y.pdb',[enableAutoPrep:0,enableProtonate:1,enableLigFix:0],['test.cif','test2.cif']],'qbPhenixPrepFile']" -exit

// example: qbmoebatch -exec "run ['qbPhenixPrep.svl',['1A2C-phenix.pdb','1A2C-phenix.translation'],'qbPostPhenixFile']" -exit

function _Atoms;
function fwrite_PDB;
function pro_StandardRes;
function pro_PeptideFlags;

function CIF_fread_cif_all;
function cif_ExtractInfo;
function mtz_Read;
function StructurePreparationGUI;

function harmonize_H;

// QB tool box
function qbPrepareSystem;
function qbCorrectAtomNames;
function qbCheckLicense;
function qbGetResidueOnRadius;
function qb_cLetter;
function qbCalcMemoryRequirementsInGB;

// statics
static transFileName;
static residueNamesTaken;
static errorCifFiles;

const CORE_DEFAULTS = [
    enableAutoPrep:0,       // Run the MOE structure preparation tool.
    enableProtonate:1,      // Turns on Protonate3D
    pmode:'Protonate3D',    // set the mode of the protonation (e.g. Protonate3D or Add_H are acceptable).
    protPH:7.4,              // Set pH for Protonation
    enableLigFix:0,          // Fixes the ligand protonation
    enableCIFprotons:1      // protonates structure based on CIF file prior to further processing
];

const PREPDEFAULTS = cat [CORE_DEFAULTS,[
    forceUseElement:1,         // force reading of the element in the PDB file. Not a good idea if file format broken.
    enableAltAtoms:0,       // enable reading of alternative atoms - warning: HIGHLY EXERPERIMENTAL!
    qmApplication:[],       // Skip the DivCon tests - we will be running no matter what since this is refinement.
    enableCIFprotons:1      // protonates structure based on CIF file prior to further processing
]];

local function WriteLog [line,basename,state]
    static logFileName;
    local fileHandle;

    if isnull state then
        state = 'none';
    endif

    if state == 'init' then
        logFileName = [];
        line = 'qbMOE INIT LOG\n\n';
    endif
    
    if isnull basename and isnull logFileName then
        logFileName = twrite ['{}.log','qbMOE'];
        fileHandle = fopenw logFileName;
    elseif isnull logFileName then
        logFileName = twrite ['{}-{}.log',basename,'qbMOE'];
        fileHandle = fopenw logFileName;
    elseif not isnull basename and not isnull logFileName then
        local newFilename = twrite ['{}-{}.log',basename,'qbMOE'];
        if newFilename <> logFileName then
            fdelete newFilename;
            frename [logFileName,newFilename];
            line = append [line, twrite ['Log file renamed from {} to {}', logFileName, newFilename]];
            logFileName = newFilename;
        endif
        fileHandle = fopenx logFileName;
        fileHandle = fseek [fileHandle, fsize fileHandle];
    else
        fileHandle = fopenx logFileName;
        fileHandle = fseek [fileHandle, fsize fileHandle];
    endif
    
    if state == 'getname' then
        fclose fileHandle;
        return logFileName;
    endif
    local tmpLine;
    for tmpLine in line loop
        fwrite [fileHandle,'{} --- {}\n', asctime[], tmpLine];
        write ['{}\n', tmpLine];
    endloop
    
    fclose fileHandle;
    return logFileName;
endfunction

local function filterInert atoms
    return diff [atoms,Atoms [] | aInert Atoms[]];
endfunction

// Source code between  // ===================== lines based on code provided by CCG 1/2013
// ===================== 
const MONLIB_CIF_DICT = [
    '_chem_comp.number_atoms_all':'int',
    '_chem_comp.number_atoms_nh':'int',
    '_chem_comp_atom.charge':'float',
    '_chem_comp_atom.partial_charge':'float',
    '_chem_comp_atom.x':'float',
    '_chem_comp_atom.y':'float',
    '_chem_comp_atom.z':'float',
    '_chem_comp_bond.value_dist':'float',
    '_chem_comp_bond.value_dist_esd':'float',
    '_chem_comp_angle.value_angle':'float',
    '_chem_comp_angle.value_angle_esd':'float',
    '_chem_comp_tor.value_angle':'float',
    '_chem_comp_tor.value_angle_esd':'float',
    '_chem_comp_tor.period':'float',
    '_chem_comp_plane_atom.dist_esd':'float'
];

local function cif2mol[ cif_file, root ]
    root = tolower root;
//    local dic = MONLIB_CIF_DICT;
    local dic = [];
    local c = CIF_fread_cif_all [cif_file, dic ];
    local tt = tok_cat[ 'comp_', root ];
    if isnull c.(tt) then
        tt = root;
    else
        local nn = length c.(tt).'_chem_comp_atom.atom_id';
        local x0 = rep[ 0, nn ];
        c.(tt).'_chem_comp_atom.x' = x0;
        c.(tt).'_chem_comp_atom.y' = x0;
        c.(tt).'_chem_comp_atom.z' = x0;
    endif
    local d = cif_ExtractInfo [c.(tt), [hetnam: string toupper root,
	    type:'auto', havechg: 0, verbose:1]];
    return first d.models;
endfunction

// JT: takes atom keys from a template (dictionary), modify the ionization
//     state of the molecule and assign all the matching names from the
//     dictionary.
local function matchHydrogens[ cif_file, inResidue, root ]
    local amol = filterInert cat rAtoms inResidue;
    local amol_num = uniq aMoleculeNumber amol;
    if length amol_num <> 1 or 
        length cat amol <> length cat [Atoms[] | indexof[ aMoleculeNumber Atoms[], amol_num ]] then
        WriteLog [ twrite ['WARNING: {} residue {}:{} can not be processed with CIF-protonation\n\t(e.g. not single, complete, small molecule, residue)',rName inResidue, cName rChain inResidue, rUID inResidue] ];
        return [];
    endif

	// Match heavy atoms of each molecule
	// in a separate system
	// Idea: strip off hydrogens, set ionization
	// to zero and used the PrioSMI function
	// to find matching heavy (between dictionary and molecule)
	// IMPORTANT: it is expected that the two molecules have
	// the same connection table and differ only by the
	// ionization of their heavy atoms

    local sys_info = SystemPush amol;
    local m_h = (aElement Atoms[]) == 'H';
    oDestroy (Atoms[] | m_h);
    aSetIon[ Atoms[], 0 ];
    local x_smi_mol_heavy = aPrioSMI Atoms[];
    local s_heavy_mol = oSerialNumber Atoms[];
    local amolHeavyCnt = length cat Atoms[];
    SystemPop sys_info;

    sys_info = SystemPush[];
    local adict = first cAtoms first mol_Create cif2mol[ cif_file, root ];
    local name_prio = aName adict[ x_sort aPrioSMI adict ];

    m_h = (aElement Atoms[]) == 'H';
    local ion_heavy = aIon (Atoms[]| not m_h);
    local geo_heavy = aGeometry (Atoms[]| not m_h);
    oDestroy (Atoms[] | m_h );
    aSetIon[ Atoms[], 0 ];
    local ions_ordered_dict_heavy = ion_heavy[ x_sort aPrioSMI Atoms[] ];
    local geos_ordered_dict_heavy = geo_heavy[ x_sort aPrioSMI Atoms[] ];
    local cifHeavyCnt = length cat Atoms[];
    SystemPop sys_info;
    if amolHeavyCnt == cifHeavyCnt then
    // first test to make sure that this works as planned.
        sys_info = SystemPush amol;
        local testAmol = cat Atoms[];
        local amoli = testAmol[ pack indexof[ s_heavy_mol, oSerialNumber testAmol ]];
        local amolisorted = amoli[ x_sort x_smi_mol_heavy ];
        aSetIon[ amolisorted, ions_ordered_dict_heavy ];
        aSetGeometry[ amolisorted, geos_ordered_dict_heavy ];
        Add_H testAmol;
        local testAtmCnt = aName cat Atoms[];

        SystemPop sys_info;
        if length testAtmCnt == length name_prio then
            amoli = amol[ pack indexof[ s_heavy_mol, oSerialNumber amol ]];
            amolisorted = amoli[ x_sort x_smi_mol_heavy ];
            aSetIon[ amolisorted, ions_ordered_dict_heavy ];
            aSetGeometry[ amolisorted, geos_ordered_dict_heavy ];
            Add_H amol;
            amol = filterInert cat rAtoms inResidue;
            local x_smi_mol  = aPrioSMI amol;
            aSetName[  amol[ x_sort x_smi_mol ], name_prio ];
        else
            WriteLog [twrite ['\tProton counts do not agree suggesting incorrect CIF file.']];
            amoli = amol[ pack indexof[ s_heavy_mol, oSerialNumber amol ]];
            amolisorted = amoli[ x_sort x_smi_mol_heavy ];
            aSetIon[ amolisorted, ions_ordered_dict_heavy ];
            aSetGeometry[ amolisorted, geos_ordered_dict_heavy ];
            Add_H amol;
            amol = [];
        endif
    else
        WriteLog [twrite ['\tHeavy atom counts do not agree suggesting truncated residue/ligand.']];
        amol = [];
    endif
    if isnull amol then
        WriteLog [twrite ['WARNING: {} residue {}:{} can not be processed with CIF-protonation\n\t(e.g. due to disagreement in atom count between CIF and PDB)',rName inResidue, cName rChain inResidue, rUID inResidue]];
        WriteLog ['\tDouble check protonation on this residue/ligand to verify correctness.\n'];
        errorCifFiles = cat [errorCifFiles,cif_file];
    endif
    return amol;
endfunction

local function applycif[ cif_file, root, atoms ]

    local newnames = [];
    
    if ftype cif_file === '' then
        WriteLog[twrite ['WARNING: CIF filename {} not found!', cif_file]];
        return newnames;
    endif
        
    local mol = cif2mol[ cif_file, root ];
    local dict_ckeys = mol_Create mol;
    local dict_akeys = cat cAtoms dict_ckeys;

    oDestroy dict_ckeys;
    
	// Map the names using unique smiles sorting

    local sys_info = SystemPush atoms;
    atoms = Atoms[];

    dict_ckeys = mol_Create mol;
    dict_akeys = cat cAtoms dict_ckeys;

    if length dict_akeys === length atoms then

        local x_smi_dict = aPrioSMI dict_akeys;
    
        local sorted_dictname = aName ( dict_akeys[ x_sort x_smi_dict ] );
    
        local x_smi_mol = aPrioSMI atoms;
        local x_mol = x_sort x_smi_mol;
        local sorted_akeys = atoms[ x_sort x_smi_mol ];
        if sort aPrioZQH atoms === sort aPrioZQH dict_akeys then
            newnames = sorted_dictname[ x_smi_mol ];
        endif
    endif

    SystemPop sys_info;
    return newnames;

endfunction

// lmw - occasionally the MOE PDB read/writer will manipulate atom names.
//      This function will return whether or not this is the case.
local function DoubleCheckCIFNames[inResidue,names]
    local mol = mol_Extract filterInert cat rAtoms inResidue;
    local pdata = SystemPush [];
    fwrite_PDB ['1234567890-tmp.pdb',mol_Create mol];
    local testChains = ReadPDB['1234567890-tmp.pdb'];
    fdelete '1234567890-tmp.pdb';
    local newnames = cat aName filterInert cat rAtoms cResidues testChains;
    SystemPop pdata;
    return sort newnames === sort names;
endfunction

local function ProcessCIF[ cif_file, inResidue ]
    local atoms = filterInert cat rAtoms inResidue;
    local root = token first wordsplit[ string ftail[ cif_file], ".cif"];
    local names = applycif[ cif_file, root, atoms ];
    if not isnull names and DoubleCheckCIFNames[inResidue,names] then
        WriteLog[twrite [' INFO: Use  {} for residue {} {}:{}', cif_file, rName inResidue, cName rChain inResidue, rUID inResidue]];
        aSetName[ atoms, names ];
        residueNamesTaken = uniq sort cat [rName inResidue, residueNamesTaken];
        return inResidue;
    else
    endif
endfunction

local function recursiveDirectoryList[directory]
    if isnull directory then
        return [];
    endif
    local list = flist directory;
    local tmpdir, filelist;
    for tmpdir in list loop
        if ftype tmpdir == 'dir' then
            filelist = append [filelist, recursiveDirectoryList[tmpdir]];
        else
            filelist = append [filelist, tmpdir];
        endif
    endloop  
    return cat filelist;
endfunction

local function getCIFlist [directory]
    if isnull directory then
        if not isnull getenv 'PHENIX' then
            directory = tok_cat [getenv 'PHENIX', '/chem_data/'];
        endif
    endif
    local filelist = recursiveDirectoryList[directory];
    return diff [cat filelist,errorCifFiles];
endfunction

local function GetRNamesFromCIF[ciffiles,tmpResidue]
    local tmpCIFfile = [];
    if isnull ciffiles then
        return tmpCIFfile;
    endif
    
    for tmpCIFfile in ciffiles loop
        local c = CIF_fread_cif_all [tmpCIFfile, MONLIB_CIF_DICT];
    
        local x;
        local availableResEntries = [];
        for x = 2, length c, 1 loop
            availableResEntries = cat [availableResEntries, token toupper second fieldsplit[string first cat c[x], "_"]];
        endloop
        if length join [availableResEntries, rName tmpResidue] > 0 then ; return tmpCIFfile; endif
    endloop
    return [];
endfunction

local function GetCIFileFromList [filelist, tmpResidue]
    local cifFile = [];
    if isnull cifFile then
        cifFile = first cat [ fabsname filelist | fbase ftail filelist == rName tmpResidue ];
    endif
    if isnull cifFile then
        cifFile = first cat [ fabsname filelist | fbase ftail filelist == twrite ['data_{}',rName tmpResidue] ];
    endif
    return cifFile;
endfunction

local function ProtonateBasedOnCif [residueList,ciffiles]
    local filelist = [];
    local fixedAtoms;
    filelist = getCIFlist[];

    if isnull cat [ciffiles,filelist] then
        WriteLog[twrite ['NOTE: No CIF files processed for protonation.']];
        return fixedAtoms;
    endif
    local tmpResidue;
    for tmpResidue in residueList loop
        local cifFile = GetRNamesFromCIF[ciffiles,tmpResidue];
        if isnull cifFile then
            cifFile = GetCIFileFromList [filelist,tmpResidue];
        endif
        if not isnull cifFile then
            WriteLog[twrite [' INFO: Attempting to use {} for protonation of {} residue {}:{}', cifFile, rName tmpResidue, cName rChain tmpResidue, rUID tmpResidue]];
            fixedAtoms = cat [fixedAtoms, matchHydrogens[cifFile, tmpResidue, rName tmpResidue]];
        endif
    endloop
    return fixedAtoms;
endfunction

local function RenameProtonsInOrder[inResidue]
    local allAtoms = cat filterInert rAtoms inResidue;
    local allPrios = aPrioSMI allAtoms;
    local tmpAtom;

    for tmpAtom in allAtoms loop
        if aElement tmpAtom == 'H' then
            aSetName [tmpAtom, twrite ['{}{}','H',allPrios(indexof[tmpAtom,allAtoms])]];
        endif
    endloop
endfunction

local function RenameBasedOnCIF [residueList,ciffiles]

    if not isnull getenv 'PHENIX' then
        WriteLog[twrite ['NOTE: Using Phenix cif database found at {}', tok_cat [getenv 'PHENIX', '/chem_data/']]];
    else
                     //            1         2         3         4         5         6         7         8
                     //   12345678901234567890123456789012345678901234567890123456789012345678901234567890
        WriteLog[twrite ['WARNING: In order to attempt the use of CIF-based naming, you must supply path ']];
        WriteLog[twrite ['         to PHENIX cif database using $PHENIX environment variable as per ']];
        WriteLog[twrite ['         PHENIX documentation.']];
        if isnull ciffiles then
            WriteLog[twrite [' ']];
            return[];
        else
            WriteLog[twrite [' NOTE: Attempting to use CIF files provided.']];
        endif
    endif

    local tmpResidue;
    local residuesToRemove;
    local filelist = getCIFlist[];
    for tmpResidue in residueList loop
        local cifFile = GetRNamesFromCIF[ciffiles,tmpResidue];
        if isnull cifFile then
            cifFile = GetCIFileFromList [filelist,tmpResidue];
        endif
        if not isnull cifFile then
            WriteLog[twrite [' INFO: Attempting to use {} for {} residue {}:{}', cifFile, rName tmpResidue, cName rChain tmpResidue, rUID tmpResidue]];
            residuesToRemove = cat [residuesToRemove, ProcessCIF[cifFile,tmpResidue]];
        else
            WriteLog[twrite ['WARNING: no CIF file found for {} residue {}:{} ', rName tmpResidue, cName rChain tmpResidue, rUID tmpResidue]];
        endif
        // there are ocassions due to MOE-bugs or user errors, atoms are not uniquely named.
        local atNames = aName filterInert cat rAtoms tmpResidue | aElement filterInert cat rAtoms tmpResidue == 'H';
        if not (length uniq atNames == length atNames) then
//            WriteLog[twrite ['WARNING: Fixed proton names for {} residue {}:{}', rName tmpResidue, cName rChain tmpResidue, rUID tmpResidue]];
            RenameProtonsInOrder[tmpResidue];
        endif
    endloop
    return residuesToRemove;
endfunction
// ===================== 

local function WriteResidue [outResidues]
    local fileHandle;
    static newResidueName;
    if isnull newResidueName then
        fdelete transFileName;
        newResidueName = '100'; 
    endif;
    local residueName = toupper rName first outResidues;
    if length pack indexof [residueNamesTaken,residueName] then
        fileHandle = fopenx transFileName;
        if newResidueName == '100' then
            fileHandle = fopenw transFileName;
                            //            1         2         3         4         5         6         7         8
                            //   12345678901234567890123456789012345678901234567890123456789012345678901234567890
            fwrite [fileHandle, '# The following is a list of temporary residue name translations. These \n'];
            fwrite [fileHandle, '# translations are provided in order to address Phenix atom/residue name \n'];
            fwrite [fileHandle, '# requirements. Upon completion of refinement, these translations can be \n'];
            fwrite [fileHandle, '# applied to recreate original using:\n'];
            fwrite [fileHandle, '# qbmoebatch -exec "run [\'qbPhenixPrep.svl\',[\'POSTPHENIX.pdb\',\'{}\'],\'qbPostPhenixFile\']"\n',transFileName];
        else
            fileHandle = fopenx transFileName;
            fileHandle = fseek [fileHandle, fsize fileHandle];
        endif
        local oldResidueName = residueName;
        residueName = totok [atoi newResidueName + 1];
        newResidueName = residueName;
        rSetName [outResidues, newResidueName];
        WriteLog[twrite ['NOTE (residue name conversion): {} = {} < {} >', newResidueName, oldResidueName, apt twrite ['{}:{}',cName rChain outResidues,rUID outResidues]]];
        fwrite [fileHandle, ' {} = {} < {} >\n', newResidueName, oldResidueName, apt twrite ['{}:{}',qb_cLetter rChain outResidues,rUID outResidues]];
        fclose fileHandle;
    endif

    local mol = mol_Extract first outResidues;
    local pdata = SystemPush [];
    residueNamesTaken = cat [residueNamesTaken,residueName];
    local resPDBfilename = twrite ['{}.pdb',residueName];
    fwrite_PDB [resPDBfilename,mol_Create mol];
    SystemPop pdata;
    WriteLog[twrite [' INFO: Use {} for residue {}', resPDBfilename, rName outResidues]];
    return resPDBfilename;
endfunction

function GetDistanceToLigand[inResidue]

    local ligandPositions = cat _Atoms '$$ligand';
    local residuePosiions = filterInert cat rAtoms inResidue;
    if isnull ligandPositions or isnull residuePosiions then
        return 'NONE';
    endif

    local atomA, atomB;
    local shortDistance = 10000;
    for atomA in ligandPositions loop
        for atomB in residuePosiions loop
            local tmpValue = sqrt add pow [sub [aPos atomA, aPos atomB],2];
            if tmpValue < shortDistance then
                shortDistance = tmpValue;
            endif
        endloop
    endloop
    
    return shortDistance;

endfunction

local function FindPeptideBreaks[inChains]

    if isnull inChains then
        inChains = Chains[];
    endif
    local tmpChain;
    for tmpChain in inChains loop
        local residueList = cat cResidues tmpChain;
        residueList = residueList | rAtomCount residueList;
        residueList = diff [residueList, uniq aResidue _Atoms '$$solvent'];
        residueList = diff [residueList, uniq aResidue _Atoms '$$ligand'];
        local x = 1;
        while x < length residueList loop
            if not cat pro_PeptideFlags cat [residueList(x),residueList(x+1)] then
                WriteLog[twrite ['WARNING: No Peptide Bond: {} {}:{} ({} A) and {} {}:{} ({} A)',
                    rName residueList(x), cName rChain residueList(x), rUID residueList(x), GetDistanceToLigand residueList(x),
                    rName residueList(x+1), cName rChain residueList(x+1), rUID residueList(x+1),GetDistanceToLigand residueList(x+1)]];
            endif
            x = x + 1;
        endloop
    endloop
    
endfunction

function Seq_NameToLetter;
local function ResiduePreparation []
    local testResidues = uniq (rName Residues [] | Seq_NameToLetter rName Residues [] <> 'X');
    testResidues = uniq cat [pro_StandardRes[], testResidues,
        'HOH','ASH','CYX','DA','DT','DG','DC','A','U','G','C',toupper el_Elements[]];
    local residueList = Residues[] | m_join [rName Residues [], testResidues] == 0;
    WriteLog[twrite ['Residues to treat: {}', uniq rName residueList]];
    return residueList;
endfunction

function CellEnable;
local function ReadInputFiles[inpdbfile,opt]
    oDestroy Chains[];
    local tmpIn;
    tmpIn.alt_loc = opt.enableAltAtoms;
    // turn on PBC
    tmpIn.gen_symm = tmpIn.install_cryst = tmpIn.cell_enable = 1
    tmpIn.use_element = opt.forceUseElement;
    local inchains = ReadPDB[inpdbfile,tmpIn];
    CellEnable 1;
    
    if not isnull inchains then
        if not opt.enableAltAtoms then
            local altCollection;
            for altCollection in findmatch ['PDB_ALTLOC_[A-Z,a-z,0-9]', oCollections[]] loop
                oSetCollection [altCollection, [] ];    // alt designator cleared from output
            endloop
            aSetOccupancy [Atoms[],1.00];
        endif
    endif
    return length inchains;
endfunction

local function WriteInputFiles[residueList,ciffiles,filebase,opt]
    opt = tagcat[opt, PREPDEFAULTS];    // this function is called from various locations (both GUI and non-GUI which have different opts)
    // address a MOE-ism that renames HIS residues based on protonation
    rSetName [cat [Residues [] | rName Residues [] == 'HIP'],'HIS'];
    rSetName [cat [Residues [] | rName Residues [] == 'HID'],'HIS'];
    rSetName [cat [Residues [] | rName Residues [] == 'HIE'],'HIS'];

// the following lines are added inorder to delete this stuff completely prior to run.
        if not opt.enableAltAtoms then
            local altCollection;
            for altCollection in findmatch ['PDB_ALTLOC_[A-Z,a-z,0-9]', oCollections[]] loop
                oSetCollection [altCollection, [] ];    // alt designator cleared from output
            endloop
            aSetOccupancy [Atoms[],1.00];
        endif

    transFileName = twrite['{}-phenix.translation',filebase];
    residueList = diff [residueList,RenameBasedOnCIF[residueList,ciffiles]];

    harmonize_H[]; // called immediately before the files are written to address any naming issues.

    local data = app filterInert rAtoms residueList;
    data = app aName data;
    data = app sort data;
    residueList = uniq residueList[x_sort data];

    local resPDBfilenames;
    local tmpIndexGrp;
    for tmpIndexGrp in indicesof [uniq x_fsort data,x_fsort data] loop
        resPDBfilenames = uniq cat [resPDBfilenames, WriteResidue[residueList[tmpIndexGrp]]];
    endloop

    FindPeptideBreaks[];

    local mainPDBfilename = twrite['{}-phenix.pdb',filebase];
    WritePDB[mainPDBfilename,[cryst1:1]];
    return [mainPDBfilename,resPDBfilenames];
endfunction

global function qbPhenixPrep [filebase,opt,ciffiles]
    // WARNING: removal/circumvention of license check code is a direct violation of license agreement!
    if not qbCheckLicense[] then
        return;
    endif
    opt = tagcat[opt, PREPDEFAULTS];
    WriteLog[ [], twrite ['{}-phenix',filebase], 'init'];
    local residueList = ResiduePreparation[];
    
    if opt.enableCIFprotons then
        opt.notProtAtomList = aNumber ProtonateBasedOnCif[residueList,ciffiles];
    endif
    qbPrepareSystem [opt];

    // set the occupancy based upon the occupancy of the heavy atom to which the proton is bound.
    aSetOccupancy [Atoms [] | aAtomicNumber Atoms[] == 1, aOccupancy aBonds Atoms [] | aAtomicNumber Atoms [] == 1];
    return WriteInputFiles[residueList,ciffiles,filebase,opt];
endfunction

global function qbPhenixPrepFile[inpdbfile,opt,ciffiles]
    opt = tagcat[opt, PREPDEFAULTS];
    if not ReadInputFiles[inpdbfile,opt] then
        return;
    endif

    qbPhenixPrep[fbase inpdbfile,opt,ciffiles];
endfunction

global function qbPostPhenix [inpdbfile,trFile]
    if isnull trFile then
        trFile = twrite ['{}.translation',fbase inpdbfile];
    endif

    local fileHandle = fopenr [trFile];
    local line;
    while length (line = freadb [fileHandle, 'line', 1]) loop
        line = cat line;
        if line(1) <> "#" then
            local newName = first wordsplit [line, " "];
            local oldName = third wordsplit [line, " "];
            newName = token newName;
            oldName = token oldName;
            WriteLog[twrite ['  INFO: rename {} to {}', newName, oldName]];
            rSetName [Residues [] | rName Residues [] == newName,oldName];
        endif
    endloop
    fclose fileHandle;
endfunction

global function qbPostPhenixFile [inpdbfile,trFile]
    oDestroy Chains[];
    if not length ReadAuto[inpdbfile] then;
        return;
    endif
    qbPostPhenix[inpdbfile,trFile];
endfunction

// lmw - GUI window tool kit functions associated with our DivCon/Phenix MOE interface.

local function GenerateBatchScript [opt,batchfilename,inMainPDB,inLigPDBs,moeLog,ciffiles]

    local shscr = fopenw batchfilename;
              //             1         2         3         4         5         6         7         8
              //    12345678901234567890123456789012345678901234567890123456789012345678901234567890
    fwrite [shscr, '#!/bin/bash\n\n'];
    fwrite [shscr, 'QBPHENIX={}/bin/qbphenix\n',getenv 'QBHOME'];
    fwrite [shscr, 'QBMOEBATCH={}/bin/qbmoebatch\n',getenv 'QBHOME'];
    
    if not isnull getenv 'PHENIX' then
        fwrite [shscr, 'QBPHENIX_ENV={}/phenix_env.sh\n',getenv 'PHENIX'];
    else
        fwrite [shscr, 'QBPHENIX_ENV=\n'];
    endif
    fwrite [shscr, 'mtzFileName={}\n', ftail opt.mtzFile];
    fwrite [shscr, 'pdbFileName={}\n',ftail inMainPDB];
    fwrite [shscr, 'phenixFileName={}\n',ftail opt.phenix_success.phenixFile];
    local allKeys,allValues;
    if not isnull opt.phenix_success.phenixOptions then
        allKeys = first untag opt.phenix_success.phenixOptions;
        allValues = second untag opt.phenix_success.phenixOptions;
        fwrite [shscr, 'phenixOptions="{}"\n',apt twrite ['{}={}',allKeys, allValues]];
    else
        fwrite [shscr, 'phenixOptions=\n'];
    endif
    
    fwrite [shscr, 'moeLogName={}\n',ftail moeLog];
    fwrite [shscr, 'regionRefine={}\n',opt.regionRefine];
    fwrite [shscr, 'qmCore={}\n',opt.qmCore];
    fwrite [shscr, 'qmBuffer={}\n',opt.qmBuffer];
    fwrite [shscr, 'macroSkip={}\n',opt.onoff_macroskip];
    fwrite [shscr, 'setNP={}\n',opt.setNP];
    fwrite [shscr, 'setMem={}\n',opt.setMem];
    fwrite [shscr, 'macroCount={}\n',opt.macroCount];
    fwrite [shscr, 'selection="{}"\n',droplast swrite['{}', apt twrite ['chain {} and resname {} and resid {},',
        qb_cLetter rChain opt.coreList, rName opt.coreList, rUID opt.coreList]]];
    fwrite [shscr, 'labelList="{}"\n',opt.labelList];
    fwrite [shscr, '    \n'];
    
                        //             1         2         3         4         5         6         7         8
                        //    12345678901234567890123456789012345678901234567890123456789012345678901234567890
    fwrite [shscr, 'errorOut()    \n'];
    fwrite [shscr, '{}\n',"{"];
    fwrite [shscr, '    if [ $regionRefine -eq 1 ] ; then regionNote="E"  ; else  regionNote="D" ;   fi    \n'];    
    fwrite [shscr, '    if [ $macroSkip -eq 1 ] ; then cycleNote="D"  ; else  cycleNote="E" ;   fi    \n'];
    fwrite [shscr, '    echo    \n'];
    fwrite [shscr, '    echo "Usage: ./{} [--np=4]"    \n',batchfilename];
    fwrite [shscr, '    echo     \n'];
    fwrite [shscr, '    echo "Optional Command line arguments:"    \n'];
    fwrite [shscr, '    echo " --help           * Show this help and exit.           "\n'];
    fwrite [shscr, '    echo " --np=#           * Number of processors in simulation.           Current: $setNP"\n'];
    fwrite [shscr, '    echo " --m=#            * Amount of memory to use in GB.                Current: $setMem"\n'];
    fwrite [shscr, '    echo " --qmCore=#       * QM Region size (beyond core residue).         Current: $qmCore"\n'];
    fwrite [shscr, '    echo " --qmBuffer=#     * QM Buffer size (beyond core region).          Current: $qmBuffer"\n'];
    fwrite [shscr, '    echo " --macroCount=#   * Number of macrocyles to run until refined.    Current: $macroCount"\n'];
    fwrite [shscr, '    echo     \n'];
    fwrite [shscr, '    echo " --enable|disable-region  * Enable/Disable region refinement.     Current: $regionNote"\n'];
    fwrite [shscr, '    echo " --enable|disable-mcycle  * Enable/Disable QM on first macrocycle.Current: $cycleNote"\n'];
    fwrite [shscr, '    echo     \n'];
    fwrite [shscr, '    echo " see: http://www.quantumbioinc.com/support/manual-phenixdc"    \n'];
    fwrite [shscr, '    echo     \n'];
    fwrite [shscr, '    exit 1    \n'];
    fwrite [shscr, '}    \n'];
    fwrite [shscr, '        \n'];

    fwrite [shscr, 'while test $# -gt 0; do\n'];
    fwrite [shscr, '    case "$1" in\n'];
    fwrite [shscr, '        -*=*) optarg=`echo "$1" | sed \'s/[-_a-zA-Z0-9]*=//\'` ;;\n'];
    fwrite [shscr, '        *) optarg= ;;\n'];
    fwrite [shscr, '    esac\n'];
    fwrite [shscr, '    case $1 in\n'];
    fwrite [shscr, '        --help)    \n'];
    fwrite [shscr, '            errorOut    \n'];
    fwrite [shscr, '            ;;    \n'];
    fwrite [shscr, '        --np=*) \n'];
    fwrite [shscr, '            setNP=$optarg   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        --m=*) \n'];
    fwrite [shscr, '            setMem=$optarg   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        --qmCore=*) \n'];
    fwrite [shscr, '            qmCore=$optarg   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        --qmBuffer=*) \n'];
    fwrite [shscr, '            qmBuffer=$optarg   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        --macroCount=*) \n'];
    fwrite [shscr, '            macroCount=$optarg   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        --disable-region) \n'];
    fwrite [shscr, '            regionRefine=0   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        --enable-region) \n'];
    fwrite [shscr, '            regionRefine=1   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        --diable-mcycle) \n'];
    fwrite [shscr, '            macroSkip=1   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        --enable-mcycle) \n'];
    fwrite [shscr, '            macroSkip=0   \n'];
    fwrite [shscr, '            ;;  \n'];
    fwrite [shscr, '        *)  \n'];
    fwrite [shscr, '            echo "ERROR: $optarg option unknown."  \n'];
    fwrite [shscr, '            errorOut  \n'];
    fwrite [shscr, '    esac    \n'];
    fwrite [shscr, '    shift   \n'];
    fwrite [shscr, 'done    \n'];
    fwrite [shscr, '        \n'];
    
    fwrite [shscr, 'function RunPhenix ()  \n'];
    fwrite [shscr, '{}   \n',"{"];
    fwrite [shscr, '    if [ -z "${}" ] ; then  \n', "{PHENIX}"];
    fwrite [shscr, '        if [ -e $QBPHENIX_ENV ] ; then      \n'];
    fwrite [shscr, '            source $QBPHENIX_ENV            \n'];
    fwrite [shscr, '        fi          \n'];
    fwrite [shscr, '    fi          \n'];
    fwrite [shscr, '    if ! hash phenix.refine 2>/dev/null; then   \n'];
    fwrite [shscr, '        echo "ERROR: Phenix must be installed as per its documentation."\n'];
    fwrite [shscr, '        errorOut  \n'];
    fwrite [shscr, '    fi          \n'];
    fwrite [shscr, '    if [ ! -e $QBPHENIX ] ; then    \n'];
    fwrite [shscr, '        if ! hash qbphenix 2>/dev/null; then   \n'];
    fwrite [shscr, '            echo "ERROR: qbphenix executable not found in PATH!"    \n'];
    fwrite [shscr, '            errorOut  \n'];
    fwrite [shscr, '        else  \n'];
    fwrite [shscr, '            QBPHENIX=`which qbphenix`  \n'];
    fwrite [shscr, '        fi  \n'];
    fwrite [shscr, '    fi  \n'];
    fwrite [shscr, '        \n'];
    fwrite [shscr, '    qbphenixopt="--sfFile $mtzFileName --pdbFile $pdbFileName --protonation PostMOE --NP $setNP --m ${}gb --ncycles $macroCount "\n','{setMem}'];
    fwrite [shscr, '    if [ $regionRefine -eq 1 ] ; then    qbphenixopt="$qbphenixopt  --selection \'$selection\' --region-radius $qmCore --buffer-radius $qmBuffer"  ;   fi    \n'];
    fwrite [shscr, '    if [ $macroSkip -eq 1 ] ; then    qbphenixopt="$qbphenixopt  --skipcycle 1"  ;   fi    \n'];
    fwrite [shscr, '    if [ ! -z "${}" ] ; then    qbphenixopt="$qbphenixopt  --paramFile $phenixFileName"  ;   fi    \n',"{phenixFileName}"];
    fwrite [shscr, '    if [ ! -z "${}" ] ; then    qbphenixopt="$qbphenixopt  --phenixOptions \'$phenixOptions\'"  ;   fi    \n',"{phenixOptions}"];
    fwrite [shscr, '    if [ ! -z "${}" ] ; then    qbphenixopt="$qbphenixopt  --labels \'$labelList\'"  ;   fi    \n',"{labelList}"];
    fwrite [shscr, '    eval $QBPHENIX $qbphenixopt  \n'];
    fwrite [shscr, '}   \n'];
    fwrite [shscr, '        \n'];

    fwrite [shscr, 'function ProcessPackageFile    \n'];
    fwrite [shscr, '{}    \n',"{"];
    fwrite [shscr, '    outFileName=$1    \n'];
    fwrite [shscr, '    outFile=$2    \n'];
    fwrite [shscr, '        \n'];
    fwrite [shscr, '    if [ ! -e $outFileName ] ; then    \n'];
    fwrite [shscr, '        baseTranslatorTmp=`which openssl`    \n'];
    fwrite [shscr, '        if [ ! -z "${}" ] ; then    \n', "{baseTranslatorTmp}"];
    fwrite [shscr, '            baseTranslator="$baseTranslatorTmp base64 -d"    \n'];
    fwrite [shscr, '        else    \n'];
    fwrite [shscr, '            baseTranslatorTmp=`which base64`    \n'];
    fwrite [shscr, '            if [ ! -z "${}" ] ; then    \n', "{baseTranslatorTmp}"];
    fwrite [shscr, '                baseTranslator="$baseTranslatorTmp -d"    \n'];
    fwrite [shscr, '            else    \n'];
    fwrite [shscr, '                echo "ERROR: Script requires standard system installation of openssl or base64."    \n'];
    fwrite [shscr, '                echo "   Install openssl or place $outFileName in current directory and re-run."    \n'];
    fwrite [shscr, '                errorOut  \n'];
    fwrite [shscr, '            fi    \n'];
    fwrite [shscr, '        fi    \n'];
    fwrite [shscr, '        echo "$outFile" | $baseTranslator > $outFileName    \n'];
    fwrite [shscr, '    fi    \n'];
    fwrite [shscr, '}    \n'];
    fwrite [shscr, '        \n'];
    
    fwrite [shscr, '\nmtzFile=\'\n'];
    apt fwrite [shscr, '{}\n', r64_encodeln freadb [opt.mtzFile,'char',INT_MAX]];
    fwrite [shscr, '\'\n'];
    fwrite [shscr, 'ProcessPackageFile $mtzFileName "$mtzFile"\n'];
    
    fwrite [shscr, '\nmoeLog=\'\n'];
    apt fwrite [shscr, '{}\n', r64_encodeln freadb [moeLog,'char',INT_MAX]];
    fwrite [shscr, '\'\n'];
    fwrite [shscr, 'ProcessPackageFile $moeLogName "$moeLog"\n'];
    
    if not isnull opt.phenix_success.phenixFile then
        fwrite [shscr, '\nphenixFile=\'\n'];
        apt fwrite [shscr, '{}\n', r64_encodeln freadb [opt.phenix_success.phenixFile,'char',INT_MAX]];
        fwrite [shscr, '\'\n'];
        fwrite [shscr, 'ProcessPackageFile $phenixFileName "$phenixFile"\n'];
    endif

    fwrite [shscr, '\npdbFile=\'\n'];
    apt fwrite [shscr, '{}\n', r64_encodeln freadb [inMainPDB,'char',INT_MAX]];
    fwrite [shscr, '\'\n'];
    fwrite [shscr, 'ProcessPackageFile $pdbFileName "$pdbFile"\n'];

    local tmpLigFile;
    for tmpLigFile in inLigPDBs loop
        fwrite [shscr, '\nF{}=\'\n',fbase ftail tmpLigFile];
        apt fwrite [shscr, '{}\n', r64_encodeln freadb [tmpLigFile,'char',INT_MAX]];
        fwrite [shscr, '\'\n'];
        fwrite [shscr, 'ProcessPackageFile {} "$F{}"\n',ftail tmpLigFile,fbase ftail tmpLigFile];
    endloop
    
    for tmpLigFile in ciffiles loop
        fwrite [shscr, '\nF{}=\'\n',fbase ftail tmpLigFile];
        apt fwrite [shscr, '{}\n', r64_encodeln freadb [tmpLigFile,'char',INT_MAX]];
        fwrite [shscr, '\'\n'];
        fwrite [shscr, 'ProcessPackageFile {} "$F{}"\n',ftail tmpLigFile,fbase ftail tmpLigFile];
    endloop
    
    if first fstat transFileName <> '' then
        fwrite [shscr, '\ntranslationFile=\'\n'];
        apt fwrite [shscr, '{}\n', r64_encodeln freadb [transFileName,'char',INT_MAX]];
        fwrite [shscr, '\'\n'];
        fwrite [shscr, 'ProcessPackageFile transFileName "$translationFile"\n'];
    endif
    
    fwrite [shscr, 'RunPhenix\n'];
    
    fclose shscr;

endfunction

// Creates a "Create Batch File" panel.
// Returns the name of the proposed file if "Create" is pressed.
// Otherwise returns null.
// NOTE: based on dock_ui.svl available in MOE dist.
local function BatchPanel finame
    local wkey = WindowCreate [
        name: 'batchwin', windowName: 'batch',
        title: 'Phenix/DivCon: Create Batch File',
        text: ['Create', 'Cancel'],
        onTrigger: ['validate', 'return'],
        Hbox: [
            extendH: 1,
            FSBText: [
                name: 'batfile', len: 30,
                title: 'Batch File:',
                allowBlank: 0,
                mode: 'saveAs'
            ]
        ],

        Separator: [flushLeft: 1],

        Label: [ flushLeft: 1,
            text: 'See header of the batch file for usage information.'
        ]
    ];

    WindowSetData [wkey, [batfile: tok_cat [finame, '_batch.sh']]];
    WindowShow wkey;
    local [val, trig] = WindowWait wkey;
    WindowDestroy wkey;

    if val.batchwin == 'Create' then
        return val.batfile;
    else
        return [];
    endif
endfunction

local function cif_Window [wparent,residueList]
    static ciffiles;
    local wkey = WindowCreate
    [
        title: 'CIF Preparation',
        name: 'panel',
        text:   ['Run','Cancel'],
	    onTrigger: ['validate','return'],
	    bubbleHelp: [
		    'Run CIF-based atom typing and preparation.',
		    'Cancel without running CIF-based preparation.'
        ], 
        Label: [ name:'phenixStatus'],
        Vbox : 
        [
            title: 'CIF Files:',
            name: 'cifftxt',
            Listbox :
                [
                name: 'ciffilesBox',text: '',
                width:50,
                bubbleHelp:
                    'If PHENIX environment variable is set per PHENIX documentation,\n'
                    'CIF files will be used (not listed here). Additional CIF files can be chosen here.\n'
                    'NOTE: use of external CIF files will be ATTEMPTED, but any problems will be reported.'
                ],
            Button : [ name: 'browse_ciffiles', text: 'Browse...']
        ]
    ];
    local phenixdb;
    local cifFiles;
    if not isnull getenv 'PHENIX' then
        phenixdb = tok_cat [getenv 'PHENIX', '/chem_data/'];
        local filelist = getCIFlist[];
        local tmpResidue;
        for tmpResidue in residueList loop
            cifFiles = cat [cifFiles, GetCIFileFromList [filelist,tmpResidue]];
        endloop

    endif
    
    if isnull phenixdb then
        WindowSetAttr[wkey, [   phenixStatus: [text:'WARNING: Phenix NOT installed'] ] ];
    else
        WindowSetAttr[wkey, [   phenixStatus: [text:twrite ['Using Phenix installed at\n   {}',getenv 'PHENIX'] ] ] ];
    endif
    
    WindowSetAttr[wkey, [   ciffilesBox:    [text : cifFiles]   ]];   
    local success = []; 
    WindowShow wkey;
    loop
        local [values, trigger] = WindowWait wkey;
        if trigger === 'panel' then
            if values.panel == 'Cancel' then break; endif
            if values.panel == 'Run' then
                Warning 'After running CIF-based preparation,\nyou should (re-)run Protonate3D or double-check protonation.';
                aSetSelected [ ProtonateBasedOnCif[residueList,ciffiles] ,1 ]; 
                success = 1;
                break;
            endif        
        elseif trigger === 'browse_ciffiles' then
            ciffiles = FilePrompt [title:'Select User CIF Files', mode:'open', filter:'*.cif', multi:1];
            WindowSetAttr[wkey,[ciffilesBox: [text:ciffiles]]];
        endif
    endloop
    WindowDestroy wkey;
    return [ciffiles,success];
    
endfunction

local function phenix_Window [wparent]

    static ciffiles;
    local wkey = WindowCreate
    [
        title: '(Optional) Phenix-specific Settings',
        name: 'panel',
        text:   ['OK','Cancel'],
	    onTrigger: ['validate','return'],
	    bubbleHelp: [
		    'Return Phenix-specific configuration settings.',
		    'Cancel.'
        ], 
        Label: [ name:'phenixStatus'],
        Group:
        [
            Group : 
            [
                Vbox:   
                [
                    Listbox :
                        [
                        name: 'phenixOptionBox',
                        header: 'Option\tValue',
                        onTrigger: 'return',
                        type: 'modint',
                        multiSelect: 2,
                        sortEnable: 1,
                        resizeH: 1,
                        bubbleHelp:
                            'Phenix settings come in option=value pairs.\n'
                            'The use of these settings should be done at your own risk and\n'
                            'not all combinations have been tested in conjunctions with QM-based refinement.\n'
                            'For a full list of available options see:\n'
                            '   http://www.phenix-online.org/documentation/'
                        ]
                ],
                Hbox:
                [
                    columns:4,
                    Text:
                        [
                            name: 'optionKey',
                            emptyText:  'Phenix Option',
                            type:   'char',
                            len:    25,
                            allowBlank: 1,
                            bubbleHelp: 'Enter Phenix command line argument.'
                        ],
                    Text:
                        [
                            name: 'optionValue',
                            emptyText:  'Value',
                            type:   'char',
                            len:    5,
                            allowBlank: 1,
                            bubbleHelp: 'Enter value for Phenix command line argument.'
                        ],
                    Button:
                        [
                            name: 'optAddButton',
                            text: 'Add',
                            bubbleHelp: 'Add entered option to list.'
                        ],
                    Button:
                        [
                            name: 'optDeleteButton',
                            text: 'Delete',
                            bubbleHelp: 'Add selected option from list.'
                        ]

                ]
            ]
        ] ,
        Separator : [flushLeft:1],

        Hbox:
        [
            columns: 2,
            flushLeft:1,
            extendH:1,
            Text:
            [
                name: 'phenixFile',
                sensitive: 1,
                title: 'Phenix File:',
                type: 'char',
                extendH:1,
                allowBlank: 1,
                bubbleHelp:
                    '(Optional) Provide a Phenix Configuration/Scenario file.\n'
                    'Phenix/DivCon has been fully tested and deployed with default\n'
                    '  Phenix options. Changes to these defaults may lead to\n'
                    '  unexpected behavior.'
            ],
            Button:
            [
                name: 'button_selectPhenix', text : 'Browse...',
                bubbleHelp:
                    '(Optional) Provide a Phenix Configuration/Scenario file.\n'
                    'Phenix/DivCon has been fully tested and deployed with default\n'
                    '  Phenix options. Changes to these defaults may lead to\n'
                    '  unexpected behavior.'
            ]
        ]
    ];
    local phenixdb;
    local cifFiles;
    if not isnull getenv 'PHENIX' then
        phenixdb = tok_cat [getenv 'PHENIX'];
    endif
    
    if isnull phenixdb then
        WindowSetAttr[wkey, [   phenixStatus: [text:'WARNING: Phenix NOT installed'] ] ];
    else
        WindowSetAttr[wkey, [   phenixStatus: [text:twrite ['Using Phenix installed at\n   {}',phenixdb] ] ] ];
    endif
    
    local success = []; 
    local tmpFile;
    local phenixOptions;
    local allKeys, allValues;
    WindowShow wkey;
    loop
        local [values, trigger] = WindowWait wkey;
        if trigger === 'panel' then
            if values.panel == 'Cancel' then break; endif
            if values.panel == 'OK' then
                values.phenixOptions = phenixOptions;
                success = values;
                break;
            endif
        elseif trigger === 'button_selectPhenix' then
            tmpFile = FilePrompt [title:'Select Phenix File', mode:'open', filter:'*', multi:0];
            if not isnull tmpFile then
                WindowSetAttr [wkey,[ phenixFile:    [value:tmpFile] ]];
            endif
        elseif trigger === 'optAddButton' then
            if not isnull values.optionKey and not isnull values.optionValue then
                phenixOptions.(values.optionKey) = values.optionValue;
                allKeys = first untag phenixOptions;
                allValues = second untag phenixOptions;
                WindowSetAttr[wkey,[ phenixOptionBox: [ text:   apt twrite ['{}\t{}',allKeys, allValues] ]]];
            endif        
        elseif trigger === 'optDeleteButton' then
            phenixOptions = diff [phenixOptions, phenixOptions[first values.phenixOptionBox]];
            allKeys = first untag phenixOptions;
            allValues = second untag phenixOptions;
            WindowSetAttr[wkey,[ phenixOptionBox: [ text:   apt twrite ['{}\t{}',allKeys, allValues] ]]];
        elseif trigger === 'phenixOptionBox' then
            local selectedOptionID = bitshr [second values.phenixOptionBox,WMOD_NBITS];
            if selectedOptionID > 0 then
                 WindowSetAttr[wkey,[
                    optionKey:      [value:first untag phenixOptions[selectedOptionID]],
                    optionValue:    [value:second untag phenixOptions[selectedOptionID]]
                    ]];
            endif
        endif        
    endloop
    WindowDestroy wkey;
    return success;

endfunction

global function qbPhenixPrepPanel[]

	if WindowShow ['PhenixDivConPanel', 1] then
	    return;
	endif
	
// this function requires that the user already have a PDB file open and ready to run.
    if isnull Atoms[] then
        Warning 'Error:\nUse File->Open to open a molecule of interest\nprior to attempting refinement.';
        return;
    endif

    local pdbfile = cTag first Chains[];
    if isnull pdbfile then
        pdbfile = 'unknown.pdb';
    endif
    WriteLog[ [], twrite ['{}-phenix',fbase ftail pdbfile], 'init'];

    local config = gr_icon ['$MOE/lib/icon/config.ico', 12, 'foreground'];
    local cif_info = 'Warning: no CIFs entered';
    local phenix_info = 'Status: Phenix configuration not provided.';
    
    local strprep_info;
    
    local function PercentProton []
        local totalAtomCnt = length cat Atoms[];
        local hAtomCnt = length cat [Atoms [] | aElement Atoms[] == 'H'];
        return hAtomCnt/totalAtomCnt;
    endfunction
    
    local hPercent = PercentProton[];
    const hCutOff = 0.49;
    strprep_info = twrite['Not performed and {f.1}% of atoms are protons',100*hPercent];

    local residueList = ResiduePreparation[];

    local testResidues = cat
        [pro_StandardRes[],'HOH','ASH','CYX','DA','DT','DG','DC','A','U','G','C','SO4'];
//    local coreList = uniq (Residues[] | m_join [rName Residues [], testResidues] == 0);
    local coreList = uniq aResidue _Atoms '$$ligand';
	local wkey = WindowCreate
	[
	    name: 'panel',
	    title: 'Phenix/DivCon Preparation',
	    windowName: 'PhenixDivConPanel',
	    text: ['Help','Batch...','Cancel'],
	    onTrigger: ['return','validate','exit'],
	    bubbleHelp: [
	    'Help, Guidelines, and Support',
		'Generate Batch script for Phenix/DivCon...',
		'Cancel without creating Phenix/DivCon run script.'
	    ],
        Group :
        [
            Vbox:
            [
                columns: 1,
                flushLeft: 1,
                extendH: 1,
                Text:
                [
                    name: 'baseName',
                    sensitive: 1,
                    title: 'Base Filename:',
                    type: 'char',
                    extendH: 1,
                    allowBlank: 0,
                    bubbleHelp:
                        'Choose base filename for use in refinement. Note: any spaces will be replaced with underscores.'
                ]
            ],
        Separator : [flushLeft:1],
            Vbox:
            [
                columns: 2,
                flushLeft:1,
                extendH:1,
                Text:
                [
                    name: 'mtzFile',
                    sensitive: 1,
                    title: 'MTZ/SF File:',
                    type: 'char',
                    extendH:1,
                    allowBlank: 0,
                    bubbleHelp:
                        'Read in structure factor file (MTZ or CIF/SF) you wish to use for refinement.'
                ],
                Button:
                [
                    name: 'button_selectMTZ', text : 'Browse...',
                    bubbleHelp:
                        'Read in structure factor file (MTZ or CIF/SF) you wish to use for refinement.'
                ]
            ],
            Vbox:
            [
                columns: 2,
                Option:
                [
                    name: 'column_F',
                    title: 'SF Column:',
                    type: 'int',
                    bubbleHelp: 'Structure factor column within MTZ file.'
                ],
                Option:
                [
                    name: 'column_Q',
                    title: 'Sigma Column:',
                    type: 'int',
                    bubbleHelp: 'Sigma column within MTZ file.'
                ]
            ],
        Separator : [flushLeft:1],
            Mbox:
            [
                columns: 2,
                Button:
                [
                    title: 'CIF Preparation', name: 'button_CIFsetup', graphics: config,
                    bubbleHelp: 
                        'Configure and run the CIF-based preparation.\n'
                        '   This function includes both user-entered CIFs and \n'
                        '   Phenix-supplied CIF files as long as Phenix has been installed as per its documentation.'
                ],
                Label : 
                [   
                    name: 'cif_info', text: cif_info,
                    bubbleHelp: 
                        'Configure and run the CIF-based preparation.\n'
                        '   This function includes both user-entered CIFs and \n'
                        '   Phenix-supplied CIF files as long as Phenix has been installed as per its documentation.'
                ],
                Button:
                [
                    title: 'Structure Preparation', name: 'button_MOEPreparation', graphics: config,
                    bubbleHelp: 
                        'Configure and run the MOE-based structure preparation.\n'
                        '   Warning, if less then 49% the atoms are protons. FIX: Run Protonate3D.\n'
                        '   Noted, if there was no change to the structure before and after structure preparation.\n'
                        '   Noted, if not performed.'
                ],
                Label :
                [ 
                    name: 'strprep_info', text: strprep_info, 
                    bubbleHelp: 
                        'Configure and run the MOE-based structure preparation.\n'
                        '   Warning, if less then 40% the atoms are protons. FIX: Run Protonate3D.\n'
                        '   Noted, if there was no change to the structure before and after structure preparation.\n'
                        '   Noted, if not performed.'
                ]
            ]
        ],

        Separator : [flushLeft:1],
        
        Group:
        [
            Checkbox: [ name: 'regionRefine', text: 'Region Refinement',onTrigger: 'return'],
            Group : 
            [
                Vbox:   
                [
                title: 'Core Residues:',
                name: 'coreResidues',
                    Button:
                        [
                            name: 'retrieveSelection', 
                            text: 'Retrieve Selection',
                            bubbleHelp: 'Retrieve selected residues and add them to region refinement.'
                        ],
                    Listbox :
                        [
                        name: 'coreResiduesBox',
                        text: '',
                        width:30,
                        header: 'Chain\tRes\tUID',
                        onTrigger: 'return',
                        type: 'modint',
                        multiSelect: 1,
                        sortEnable: 1,
                        bubbleHelp:
                            'This list of residues automatically includes ligand(s), cofactor(s), and metals.\n'
                            '   All selected residues will be included as core residues in the QM Region Refinement.\n'
                            '   To remove a residue from the list, simply unselect it.\n'
                            '   The list may be expanded by selecting additional residues in the MOE window and \n'
                            '   pressing the Retrieve Selection button above.'
                        ]
                ],
                Hbox:
                [
                    name: 'regionSizes',
                    columns:4,
                    Text:
                        [
                            name: 'qmCore',
                            title:  'QM Region (A): ',
                            type:   'real',
                            onTrigger: 'return',
                            allowBlank: 0,
                            shortcut: ['5.0','4.0','3.0','2.0','1.0','0.0'],
                            bubbleHelp: 'Size of QM region beyond core residues noted above.'
                        ],
                    Button:
                        [
                            name: 'button_ShowRegionAtoms', text: '?', font: 'mediumBold',
                            bubbleHelp: 'Displays the approximate number of atoms that will be treated quantum mechanically.'
                        ],
                    Text:
                        [
                            name: 'qmBuffer',
                            title:  'Buffer (A): ',
                            type:   'real',
                            onTrigger: 'return',
                            allowBlank: 0,
                            shortcut: ['2.5','3.0','3.5','0.0'],
                            bubbleHelp: 'Size of QM buffer beyond QM Region.'
                        ],
                    Button:
                        [
                            name: 'button_ShowBufferAtoms', text: '?', font: 'mediumBold',
                            bubbleHelp: 'Displays the approximate number of atoms that will be treated quantum mechanically.'
                        ]
                ]
            ]
        ] ,
        Separator : [flushLeft:1],
        Mbox:
        [
            columns:2,
            Hbox:
            [
                columns:1,
                flushLeft:0, 
                Text:
                [
                        name: 'macroCount',
                        title: 'Macrocycle Count: ',
                        type:   'int',
                        allowBlank: 0,
                        shortcut: ['1','2','3','4','5'],
                        bubbleHelp: 'Phenix will run this number of macrocycles before convergence.'
                ],
                Checkbox: 
                [ 
                    title: 'Skip First Macrocyle: ', 
                    name: 'onoff_macroskip',
                    bubbleHelp: 
                        'QM will not be used for the first macrocycle in order to address\n'
                        'starting structures of questionable quality.'
                ]
            ],
            Hbox:
            [
                columns:1,
                flushLeft:0, 
                Text:
                    [
                        name: 'setNP',
                        title: 'Processor Count: ',
                        type:   'int',
                        onTrigger: 'return',
                        allowBlank: 0,
                        shortcut: ['1','2','4','8','16'],
                        bubbleHelp: 'The QM calculation is fully threaded for multiple processors.'
                    ],
                Label:
                    [
                        name: 'setMemLabel',
                        title: 'Memory (GB): ',
                        text: '--',
                        bubbleHelp: 'The amount approximately equates to the maximum amount of memory for the QM calculation and \n'
                                    '   the value does not include memory for Phenix or other calculations.\n'
                                    '   If less then this amount of memory is provided, the calculation may still proceed but\n'
                                    '   consume more time. For queuing systems (PBS, SGE, etc), account for this memory and \n'
                                    '   add a reasonable cushion for additional tools.'
                    ],Data : [name:'setMem']
            ]
        ],
            Mbox:
            [
                columns: 2,
                Button:
                [
                    title: 'Phenix Configuration', name: 'button_PhenixSetup', graphics: config,
                    bubbleHelp: '(Optional) Provide Phenix-specific settings for the refinement.'
                ],
                Label : [ name: 'phenix_info', text: phenix_info ]
            ],
            Separator : [flushLeft:1],
            Mbox:
            [
                columns: 2,
                Button:
                [
                    title: 'Atom Count', name: 'button_ShowAtomCount', text: '?', font: 'mediumBold',
                    bubbleHelp: 'Displays the approximate number of atoms that will be treated quantum mechanically.'
                ],
                Label : [ name: 'atomcount_info' ]
            ],
            Mbox:
            [
                columns: 2,
                Button:
                [
                    title: 'Warnings', name: 'button_ShowWarnings', text: '?', font: 'mediumBold',
                    bubbleHelp: 'If there are any warnings, they will appear here.'
                ],
                Label : [ name: 'warning_info' ]
            ]
	];
	
	local function updateCoreResidueList [coreList]
	    return apt twrite ['{}\t{}\t{}',cName rChain coreList, rName coreList, rUID coreList];
	endfunction
    
    local function ShowWarnings [wkey,trigger,values,status,allAtoms]
    
            local message = [];
            
            local alt_atoms = cat app oGetCollection findmatch ['PDB_ALTLOC_[A-Z,a-z,0-9]', oCollections[]];
            local commonAtoms = join [alt_atoms,allAtoms];
            if not isnull commonAtoms then
                local inResidues = uniq cat aResidue commonAtoms;
                message = twrite ['Residues {} have alternative conformations.\nDisorder in the QM Region is not supported at this time and will be removed at runtime\n(e.g. highest occupied or "A" conformation will be included in QM calculation).\n\n',
                    apt twrite ['{}:{}:{}',cName rChain inResidues, rName inResidues, rUID inResidues]];
            endif
            
            if isnull status.cif_success then
                message = twrite['{}CIF preparation was not executed.\n\n',message];
            endif
            
            if isnull status.phenix_success then
                message = twrite ['{}Phenix configuration was not executed.\n\n',message];
            endif
            
            if not status.ran_protonate then
                message = twrite ['{}Protonate3D was not executed during this session.\n\n',message];
            endif
            
            if not status.ran_structprep then
                message = twrite ['{}Structure preparation was not executed during this session.\n\n',message];
            elseif not status.structprep_changed then
                message = twrite ['{}Structure preparation was executed, but no changes were observed in structure.\n\n',message];
            endif
            
            if not isnull message then
                message = twrite ['WARNING(S):\n\n{}',message];
                WindowSetAttr[wkey, [ warning_info: [text:'Click to see detailed warnings', foreground:'red']   ]];
                if trigger === 'inbatch' then
                    message = twrite ['{}Continue?\n',message];
                    return NoYes message;
                elseif trigger === 'button_ShowWarnings' then
                    Warning message;
                endif
            else
                WindowSetAttr[wkey, [ warning_info: [text:'None']   ]];
            endif
            return 1;
    endfunction

	local function updateAtomCount [wkey, values, coreList]
	    local atomList;
	    local qmCoreAtoms;
	    local qmBufferAtoms;
	    if not values.regionRefine then
	        atomList = Atoms[];
	    else
	        qmCoreAtoms = qbGetResidueOnRadius[filterInert cat rAtoms coreList[first values.coreResiduesBox],values.qmCore];
	        qmBufferAtoms = diff [qbGetResidueOnRadius[qmCoreAtoms,values.qmBuffer],qmCoreAtoms];
	        atomList = uniq cat [qmCoreAtoms,qmBufferAtoms];
        endif
	    WindowSetAttr[wkey, 
	    [ 
	        atomcount_info: [text:twrite ['{} QM atoms ({} residues)',length cat atomList,length uniq aResidue cat atomList]]	        
	    ]];
	    return [atomList,qmCoreAtoms,qmBufferAtoms];
	endfunction
	
	local function highlightAtoms [wkey, values, trigger, coreList]
	    local [allAtoms,qmCoreAtoms,qmBufferAtoms] = updateAtomCount [wkey, values, coreList];
	    aSetSelected [Atoms[], 0];
	    if trigger === 'button_ShowRegionAtoms' then
            aSetSelected [qmCoreAtoms, 1];
        elseif trigger === 'button_ShowBufferAtoms' then
            aSetSelected [qmBufferAtoms,1];
        elseif trigger === 'button_ShowAtomCount' then
            aSetSelected [allAtoms,1];
        endif
    endfunction
    	
    WindowSetAttr[wkey,
        [
            coreResiduesBox:
                [text : updateCoreResidueList[coreList],value: [igen length coreList]],
            regionRefine: [value: 1],
            qmCore: [value: 3.0],
            qmBuffer: [value: 2.5],
            setNP: [value:2],
            setMem: [value:2],
            macroCount: [value:3],
            onoff_macroskip: [value:0],
            column_F:   [sensitive:0],
            column_Q:   [sensitive:0],
            baseName:   [value:fbase ftail pdbfile]
        ]
    ];
    local values, trigger, allAtoms,qmCoreAtoms,qmBufferAtoms;
    local ynMemIsSet = 0;
    values = WindowValues wkey;
    [allAtoms,qmCoreAtoms,qmBufferAtoms] = updateAtomCount[wkey,values,coreList];
	local status;
	status.cif_success = []; status.phenix_success = [];status.ran_protonate = 0;status.ran_structprep = 0;status.structprep_changed = 0;
	
    if second task_fork [] == 'child' then
        task_settitle [ task_key -1, 'update_QBmemory'];
        status.memory = qbCalcMemoryRequirementsInGB[allAtoms,values.setNP];
        WindowSetAttr[wkey, [ setMemLabel: [text: [twrite['{}',status.memory] ]], setMem: [value: [twrite['{}',status.memory]]] ]];
        ShowWarnings [wkey,trigger,values,status,allAtoms];
        exit[];
    endif
    
	WindowShow wkey;
	local ciffiles;
	local tmpFile;
	local mtzFColumns = [];
	local mtzQColumns = [];
    loop
        [values, trigger] = WindowWait wkey;
//  write ['DEBUG: {} | {}\n', values, trigger];
        if trigger === 'button_CIFsetup' then
            local tmpcif_success;
            [ciffiles,tmpcif_success] = cif_Window[wkey,residueList];
            status.cif_success = tmpcif_success;
            if isnull status.cif_success then
                WindowSetAttr[wkey,[cif_info: [text:cif_info]]];
            else
                WindowSetAttr[wkey,[cif_info: [text:'Finished with CIF preparation']]];
            endif
        elseif trigger === 'button_ShowAtomCount' 
                or trigger === 'button_ShowRegionAtoms' 
                or trigger === 'button_ShowBufferAtoms' then
            highlightAtoms [wkey, values, trigger, coreList];
        elseif trigger === 'button_MOEPreparation' then
            local before_run = length cat Atoms[];
            StructurePreparationGUI[cmd:'interactive'];
            status.ran_structprep = 1;
            sleep 2.0;      // needs a couple of seconds to init StructurePrep function
            WindowShow [wkey, 0];
            while WindowKey 'Structure Preparation' loop
                sleep 0.15;
                if WindowKey 'Protonate3D' then
                    status.ran_protonate = 1;
                endif
            endloop
            hPercent = PercentProton[];
            local after_run = length cat Atoms[];
            if hCutOff > hPercent then
                WindowSetAttr[wkey,[strprep_info: [text:twrite['Warning: only {}% of atoms are protons', 100*hPercent]]]];
            elseif before_run == after_run then
                WindowSetAttr[wkey,[strprep_info: [text:'Note: no change in structure.']]];
                status.structprep_changed = 0;
            else
                WindowSetAttr[wkey,[strprep_info: [text:'MOE preparation Ran']]];
                status.structprep_changed = 1;
            endif
            WindowShow[wkey,1];
        elseif trigger === 'regionRefine' then
            if values.regionRefine then
                WindowSetAttr[wkey,[coreResidues: [sensitive:1]]];
                WindowSetAttr[wkey,[regionSizes: [sensitive:1]]];
            else
                WindowSetAttr[wkey,[coreResidues: [sensitive:0]]];
                WindowSetAttr[wkey,[regionSizes: [sensitive:0]]];
            endif
        elseif trigger === 'coreResiduesBox' then
            local selectedResidueID = bitshr [second values.coreResiduesBox,WMOD_NBITS];
            if selectedResidueID > 0 then
                Isolate [coreList(selectedResidueID),Atoms[]];
            endif
        elseif trigger === 'retrieveSelection' then
            local newSelected = diff[Residues [] | rSelected Residues [],coreList];
            local prevLenCoreList = length coreList;
            coreList = cat [coreList, newSelected];
            WindowSetAttr[wkey,[
                coreResiduesBox: [
                    text:   updateCoreResidueList[coreList],
                    value:  [cat [first values.coreResiduesBox, igen length newSelected + prevLenCoreList]]
                    ]]];
        elseif trigger === 'button_selectMTZ' then
            tmpFile = FilePrompt [title:'Select Structure Factor File', mode:'open', filter:'', multi:0];
            if not isnull tmpFile then
                WindowSetAttr [wkey,
                [
                    mtzFile:    [value:tmpFile],
                    column_F:   [text:'',sensitive:0],
                    column_Q:   [text:'',sensitive:0]
                 ]];              
                if fext tmpFile == 'mtz' then
                    local mtzContents = mtz_Read tmpFile;
                    mtzFColumns = first mtzContents.cdata | second mtzContents.cdata == 'F';
                    mtzQColumns = first mtzContents.cdata | second mtzContents.cdata == 'Q';
                    WindowSetAttr [wkey,
                    [
                        column_F:   [text:mtzFColumns, sensitive:1],
                        column_Q:   [text:mtzQColumns, sensitive:1]
                    ]];
                endif
            endif
        elseif trigger === 'button_PhenixSetup' then
            status.phenix_success = phenix_Window[wkey];
            if isnull status.phenix_success then
                WindowSetAttr[wkey,[phenix_info: [text:phenix_info]]];
            else
                WindowSetAttr[wkey,[phenix_info: [text:'Finished with Phenix Configuration']]];
            endif
        elseif trigger === 'panel' then
            if values.(trigger) == 'Batch...' then
                local baseNameString = swrite ['{}', values.baseName];
                baseNameString[cat indicesof[" ",baseNameString]] = "_";
                values.baseName = token baseNameString;
                WindowSetAttr[wkey, [ baseName:   [value:values.baseName]  ]];
                
                local batchname = [];
                if ShowWarnings [wkey,'inbatch',values,status,allAtoms] then
                    batchname = BatchPanel values.baseName;
                endif

                if not isnull batchname then
                    WriteLog[twrite ['Creating {}',batchname],twrite ['{}-phenix',values.baseName]];
                    local [mainPDBfilename,resPDBfilenames] = WriteInputFiles[residueList,ciffiles,values.baseName,values];
                    values.coreList = coreList[first values.coreResiduesBox];
                    if fext values.mtzFile == 'mtz' then
                        values.labelList = twrite['{},{}',mtzFColumns[values.column_F],mtzQColumns[values.column_Q]];
                    else
                        values.labelList = '';
                    endif
                    values.phenix_success = status.phenix_success;
                    GenerateBatchScript[values,batchname,mainPDBfilename,resPDBfilenames,WriteLog[[],[],'getname'],ciffiles];
                    break;
                endif
            elseif values.(trigger) == 'Help' then
                LaunchDocument '$QBHOME/doc/help-refine.html';
            endif
        endif
        [allAtoms,qmCoreAtoms,qmBufferAtoms] = updateAtomCount[wkey,values,coreList];
        
        task_kill (task_keylist [] | task_title task_keylist [] == 'update_QBmemory');    // kill other memory update tasks
        if second task_fork[master:'parent'] == 'child' then
            task_settitle [ task_key -1, 'update_QBmemory'];
            
            if second task_fork [master:'parent'] === 'child' then          // this will give the user some feedback
                task_settitle [ task_key -1, 'mem_progress'];
                local loopCount = '|';
                loop
                    sleep 0.5;
                    if loopCount == '|' then
                        loopCount = '/';
                    elseif loopCount == '/' then
                        loopCount = '-';
                    elseif loopCount == '-' then
                        loopCount = '\\';
                    elseif loopCount == '\\' then
                        loopCount = '|';
                    endif
                    WindowSetAttr[wkey, [ setMemLabel: [text: [twrite['{}',loopCount] ]], setMem: [value: [twrite['-10']]] ]];
                endloop
            endif

            status.memory = qbCalcMemoryRequirementsInGB [allAtoms,values.setNP];
            task_kill (task_keylist [] | task_title task_keylist [] == 'mem_progress');
            WindowSetAttr[wkey, [ setMemLabel: [text: [twrite['{}',status.memory] ]], setMem: [value: [twrite['{}',status.memory]]] ]];
            ShowWarnings [wkey,trigger,WindowValues wkey,status,allAtoms];
            exit[];
        endif
    endloop
    WindowDestroy wkey;
endfunction

#eof

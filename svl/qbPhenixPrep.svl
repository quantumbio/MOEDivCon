#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2013 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif   


// example: qbmoebatch -exec "run ['qbPhenixPrep.svl',['1A2C.pdb'],'qbPhenixPrepFile']" -exit

// example: qbmoebatch -exec "run ['qbPhenixPrep.svl',['1A2C.pdb'],'qbPostPhenixFile']" -exit

function _Atoms;
function Protonate3D;
function fwrite_PDB;
function pro_StandardRes;

function CIF_fread_cif_all;
function cif_ExtractInfo;

// QB tool box
function qbPrepareSystem;

const PREPDEFAULTS = [
    enableAutoPrep:0,       // Run the MOE structure preparation tool.
    enableProtonate:1,      // Turns on Protonate3D
    enableLigFix:0          // Fixes the ligand protonation
];

// Source code between  // ===================== lines based on code provided by CCG 1/2013
// ===================== 
const MONLIB_CIF_DICT = [
    '_chem_comp.number_atoms_all':'int',
    '_chem_comp.number_atoms_nh':'int',
    '_chem_comp_atom.charge':'float',
    '_chem_comp_atom.partial_charge':'float',
    '_chem_comp_atom.x':'float',
    '_chem_comp_atom.y':'float',
    '_chem_comp_atom.z':'float',
    '_chem_comp_bond.value_dist':'float',
    '_chem_comp_bond.value_dist_esd':'float',
    '_chem_comp_angle.value_angle':'float',
    '_chem_comp_angle.value_angle_esd':'float',
    '_chem_comp_tor.value_angle':'float',
    '_chem_comp_tor.value_angle_esd':'float',
    '_chem_comp_tor.period':'float',
    '_chem_comp_plane_atom.dist_esd':'float'
];

local function applycif[ cif_file, root, atoms ]

	// First read the cif file and build a db_mol data structure

    local c = CIF_fread_cif_all [cif_file, MONLIB_CIF_DICT];

    local tt = tok_cat[ 'comp_', root ];
    local nn = length c.(tt).'_chem_comp_atom.atom_id';
    local x0 = rep[ 0, nn ];
    c.(tt).'_chem_comp_atom.x' = x0;
    c.(tt).'_chem_comp_atom.y' = x0;
    c.(tt).'_chem_comp_atom.z' = x0;

    local d = cif_ExtractInfo [c.(tt), [hetnam: string toupper root,
	type:'monlibcif', havechg: 1, verbose:1]];

    local mol = first d.models;

	// Map the names using unique smiles sorting

    local [sys_old, sys_new] = SystemPush atoms;
    atoms = Atoms[];

    local dict_ckeys = mol_Create mol;
    local dict_akeys = cat cAtoms dict_ckeys;

    local newnames = [];

    if length dict_akeys === length atoms then

        local x_smi_dict = aPrioSMI dict_akeys;
    
        local sorted_dictname = aName ( dict_akeys[ x_sort x_smi_dict ] );
    
        local x_smi_mol = aPrioSMI atoms;
        local x_mol = x_sort x_smi_mol;
        local sorted_akeys = atoms[ x_sort x_smi_mol ];
        newnames = sorted_dictname[ x_smi_mol ];
    endif

    SystemPop[ sys_old, sys_new ];
    return newnames;

endfunction

local function ProcessCIF[ cif_file, atoms ]
//    local cif_file = '~/Desktop/GOL.cif';
    if isnull atoms then
        atoms = Atoms[];
    endif
    local root = token first wordsplit[ string ftail[ cif_file], ".cif"];
    root = tolower root;
    local names = applycif[ cif_file, root, atoms ];
    
    if not isnull names then
        write [' INFO: Use  {} for residue {} {}\n', cif_file, rName first aResidue atoms, rUID first aResidue atoms];
        aSetName[ atoms, names ];
    else
        write ['WARNING: incomplete representation for {} residue {}\n', rName uniq aResidue atoms, rUID uniq aResidue atoms];
    endif
endfunction

local function recursiveDirectoryList[directory]
    local list = flist directory;
    local tmpdir, filelist;
    for tmpdir in list loop
        if ftype tmpdir == 'dir' then
            filelist = append [filelist, recursiveDirectoryList[tmpdir]];
        else
            filelist = append [filelist, tmpdir];
        endif
    endloop  
    return cat filelist;
endfunction

local function RenameBasedOnCIF [atoms]
    local phenixdb;
    if isnull phenixdb then
        if not isnull getenv 'PHENIX' then
            phenixdb = tok_cat [getenv 'PHENIX', '/chem_data/'];
        else
               //            1         2         3         4         5         6         7         8
               //   12345678901234567890123456789012345678901234567890123456789012345678901234567890
            write ['WARNING: In order to attempt the use of CIF-based naming, you must supply path \n'];
            write ['         to PHENIX cif database using $PHENIX environment variable as per \n'];
            write ['         PHENIX documentation.\n\n'];
            return[];
        endif
    endif
    write ['NOTE: Using Phenix cif database found at {}\n', phenixdb];

    local ligandResidues = uniq aResidue atoms;
    local tmpResidue;
    local filelist = recursiveDirectoryList[phenixdb];
    for tmpResidue in ligandResidues loop
        local cifFile = fabsname filelist | fbase ftail filelist == rName tmpResidue;
        if not isnull cifFile then
            ProcessCIF[cifFile,cat rAtoms tmpResidue];
        else
            write ['WARNING: no CIF file found for {} residue {} \n', rName tmpResidue, rUID tmpResidue];
        endif
    endloop
endfunction
// ===================== 

local function ProtonateResidue [tmpResidue]
    local mol = mol_Extract tmpResidue;
    local pdata = SystemPush [];
    local tmpChains = mol_Create mol;
    local tmpAtoms = cat cAtoms tmpChains;
    Protonate3D [tmpAtoms,tmpAtoms,tmpAtoms,[],[],[]];
    tmpAtoms = cat cAtoms tmpChains;        // must rebuild list to be used in subsequent steps.
//    RenameHforPDBv3[tmpAtoms];
//    fwrite_PDB [twrite ['{}.pdb',toupper rName aResidue first tmpAtoms],tmpChains];
    SystemPop pdata;
endfunction

// This function provides an APPROXIMATE renaming scheme for ligands to PDBv3 standards
//  in order to address a MOE foible which does not name new protons based on the heavy element
//  to which it is attached leading to non-unique atom names within a ligand.
local function RenameHforPDBv3 [allAtoms]
    local tmpAtm;
    for tmpAtm in allAtoms | aElement allAtoms == 'H' loop
        local boundHeavy = allAtoms | bOrder [tmpAtm, allAtoms];
        if not cat [aElement boundHeavy == 'C'] then
            if not strpos [string tok_cat ['H',aElement boundHeavy], string aName tmpAtm] then
                local newname = tok_cat['H',aElement boundHeavy,tok_drop[aName tmpAtm,1]];
//                write [' INFO: {} in {} {} changed to {}\n', aName tmpAtm, rName aResidue tmpAtm,rUID aResidue tmpAtm, newname];
                aSetName[tmpAtm,newname];
            endif
        endif
    endloop
endfunction

local function WriteResidue [outResidue,fileHandle]

    static newResidueName;
    if isnull newResidueName then newResidueName = '100'; endif;
    static savedResidueNameList;
    local residueName = toupper rName outResidue;
    if length pack indexof [savedResidueNameList,residueName] then
        local oldResidueName = residueName;
        residueName = totok [atoi newResidueName + 1];
        newResidueName = residueName;
        rSetName [outResidue, newResidueName];
        write ['NOTE (residue name conversion): {} = {} {}\n', newResidueName, oldResidueName, rUID outResidue];
        fwrite [fileHandle, ' {} = {} {}\n', newResidueName, oldResidueName, rUID outResidue];
    endif

    local mol = mol_Extract outResidue;
    local pdata = SystemPush [];
    savedResidueNameList = cat append [savedResidueNameList,residueName];
    fwrite_PDB [twrite ['{}.pdb',residueName],mol_Create mol];
    SystemPop pdata;
    write [' INFO: Use {}.pdb for residue {}\n', residueName, rName outResidue];

endfunction

local function WriteResiduePDBs[testResidue, residueList, fileHandle]
    if isnull testResidue then
        return;
    endif
    local tmpResidue;
    local resdiueListMask = [];
    for tmpResidue in residueList loop
        resdiueListMask = cat append [resdiueListMask, 0];
        if rName tmpResidue == rName testResidue then
        if sort aName rAtoms tmpResidue === sort aName rAtoms testResidue then
            resdiueListMask(length resdiueListMask) = 1;
        endif
        endif
    endloop
    local toSend = residueList | resdiueListMask;
    WriteResidue [first toSend, fileHandle];
    residueList = residueList | resdiueListMask == 0;
    
    WriteResiduePDBs [first residueList, residueList, fileHandle];
    
endfunction

function GetDistanceToLigand[inResidue]

    local ligandPositions = cat _Atoms '$$ligand';
    local residuePosiions = cat rAtoms inResidue;
    if isnull ligandPositions or isnull residuePosiions then
        return 'NONE';
    endif

    local atomA, atomB;
    local shortDistance = 10000;
    for atomA in ligandPositions loop
        for atomB in residuePosiions loop
            local tmpValue = sqrt add pow [sub [aPos atomA, aPos atomB],2];
            if tmpValue < shortDistance then
                shortDistance = tmpValue;
            endif
        endloop
    endloop
    
    return shortDistance;

endfunction

function pro_PeptideFlags;
local function FindPeptideBreaks[inChains]

    if isnull inChains then
        inChains = Chains[];
    endif
    local tmpChain;
    for tmpChain in inChains loop
        local residueList = cat cResidues tmpChain;
        residueList = residueList | rAtomCount residueList;
        residueList = diff [residueList, uniq aResidue _Atoms '$$solvent'];
        residueList = diff [residueList, uniq aResidue _Atoms '$$ligand'];
        local x = 1;
        while x < length residueList loop
            if not cat pro_PeptideFlags cat [residueList(x),residueList(x+1)] then
                write ['WARNING: No Peptide Bond: {} {} ({} A) and {} {} ({} A)\n',
                    rName residueList(x), rUID residueList(x), GetDistanceToLigand residueList(x),
                    rName residueList(x+1), rUID residueList(x+1),GetDistanceToLigand residueList(x+1)];
            endif
            x = x + 1;
        endloop
    endloop
    
endfunction

global function qbPhenixPrep [inpdbfile,opt]
    opt = tagcat[opt, PREPDEFAULTS];
//    local residueList = cat [Residues [] | indexof [rName Residues[], cat [pro_StandardRes[],'HOH']] == 0];
    local residueList = uniq cat aResidue _Atoms '$$ligand';
    
    qbPrepareSystem [opt];
    residueList = cat [residueList | indexof [rName residueList, cat [pro_StandardRes[],'HOH']] == 0];
    RenameHforPDBv3[cat rAtoms residueList];
    RenameBasedOnCIF[cat rAtoms residueList];
    FindPeptideBreaks[];
    
    local fileHandle = fopenw [twrite['{}-phenix.translation',fbase inpdbfile]];
                    //            1         2         3         4         5         6         7         8
                    //   12345678901234567890123456789012345678901234567890123456789012345678901234567890
    fwrite [fileHandle, '# The following is a list of temporary residue name translations. These \n'];
    fwrite [fileHandle, '# translations are provided in order to address Phenix atom/residue name \n'];
    fwrite [fileHandle, '# requirements. Upon completion of refinement, these translations can be \n'];
    fwrite [fileHandle, '# applied to recreate original using:\n'];
    fwrite [fileHandle, '# qbmoebatch -exec "run [\'qbPhenixPrep.svl\',[\'POSTPHENIX.pdb\',\'{}\'],\'qbPostPhenix\']"\n',twrite['{}-phenix.translation',fbase inpdbfile]];
    
    WriteResiduePDBs[first residueList, residueList, fileHandle];
    fclose fileHandle;
endfunction

global function qbPhenixPrepFile[inpdbfile,opt]
    oDestroy Chains[];
    ReadAuto[inpdbfile];
    qbPhenixPrep[inpdbfile,opt];
    WritePDB[twrite['{}-phenix.pdb',fbase inpdbfile]];
endfunction

global function qbPostPhenix [inpdbfile,trFile]
    if isnull trFile then
        trFile = twrite ['{}.translation',fbase inpdbfile];
    endif

    local fileHandle = fopenr [trFile];
    local line;
    while length (line = freadb [fileHandle, 'line', 1]) loop
        line = cat line;
        if line(1) <> "#" then
            local [newName, tmpEqual, oldName, resID] = wordsplit [line, " "];
            newName = token newName;
            oldName = token oldName;
            write ['  INFO: rename {} to {}\n', newName, oldName];
            rSetName [Residues [] | rName Residues [] == newName,oldName];
        endif
    endloop
    fclose fileHandle;
endfunction

global function qbPostPhenixFile [inpdbfile,trFile]
    oDestroy Chains[];
    ReadAuto[inpdbfile];
    qbPostPhenix[inpdbfile,trFile];
    WritePDB[twrite['{}-after.pdb',fbase inpdbfile]];
endfunction

#eof

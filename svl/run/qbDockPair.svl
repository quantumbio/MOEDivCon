#svl

//  USAGE: See below

global argv;

// forward declarations
function PartialCharge;
function ArgvPull;
function fwrite_TriposMOL2;
function mol_Create;
function MM;
function StructurePreparation;
function Protonate3D;
function db_ImportSD;
function db_ImportMOL2;
function db_Sort;
function db_Delete;
function db_ExportSD;
function DockAtoms;
function DockFile;

// infile forward declarations
function DockOpt;
function usage;
function checkMolecule;
function dockmdb2mol2;

const DEFAULT_OPT = [
    delwat      : 0,        // Delete waters prior to performing docking/placement but AFTER any optimization if -preopt chosen
    inducedfit  : 0,        // Run induced fit (optimized protein) on dock
    offormat    : 'pdb',    // output this version of output for induced fit (can be either 'pdb' or 'mol2')
    mtscorees   : 0,        // Run (1) 'MTScoreES dG [QuantumBio]' via qbWebService or (0) 'GBVI/WSA dG' for final score
    mtcsconf    : 0,        // Number of MTCS conformers to use (these are the best X conformers according to BFintensity). If zero (default) use ALL conformers (WARNING: this can be expensive.)
    maxpose     : 25,       // Number of poses to optimize (per posed conformer) prior to final score
//    maxpose     : 5,       // Number of poses to optimize (per posed conformer) prior to final score
    remaxpose   : 5,        // Max number of poses to return per conformer (after optimization)
    rigidlig    : 0,        // Run with the ligand/conformation treated rigidly
    preopt      : 0,        // Run an optimization of the protein:ligand complex prior to docking
    protonate   : 0,        // Run Protonate3D prior to docking/scoring
    forceexe    : 0,        // Force the calculation to proceed even if there are structural defects
    mtscoreexe  : 0,        // Run MTScoreE using the qmechanic commandline found in QBHOME
    testinp     : 0,        // Test the input but then quit.
    qbhome      : ''        // Path to QBHOME (if set - otherwise null)
    
];

local function usage []

    local defaults = DEFAULT_OPT;
    local opt = DockOpt[];
    
    pot_Load '$MOE/lib/Amber10EHT.ff.gz';
    
    local function yesno inVar
        if inVar then
            return 'YES';
        else
            return 'NO';
        endif
    endfunction
    
    local function yesnotoken inToken
        if isnull inToken then
            return 'NOT DEFINED';
        else
            return inToken;
        endif    
    endfunction
write [
#token

USAGE:
    $ moebatch -run ./DivConSuite/svl/run/qbDockPair.svl -rec receptor.pdb -lig placed_ligand.mol2

AVAILABLE OPTIONS

    -rec <file>         (Required) Receptor or Target:ligand in PDB or MOL2 format (DEFAULT: none)
    
    -lig <file>         (Optional) Placed Ligand in PDB or MOL2 format 
                            (DEFAULT: Ligand if -rec includes target:ligand)
    -novellig <file>    (Optional) One or more novel ligands in MOL2, MDB, or SDF
                            (DEFAULT: Whatever species is provided as the placed ligand)
    -conf <file>        (Optional) [MTCS] Conformers in SDF format. 
                            (DEFAULT: built-in MOE conformers)
    -o <filename>       Output base filename (DEFAULT: <ligand_filename>_dock.mdb)
    -delwat (bool)      Delete waters prior to docking (DEFAULT: {})
    -mtscoreexe <QBHOME> This option will execute QBHOME/bin/qmechanic as provided. If QBHOME is set in
                        the shell environment it can be used as well (command line argument takes
                        precedence).
                        Current QBHOME: {}
    
    -mtscorees (bool)   Use MTScoreES instead of MOE {} score (DEFAULT: {})
    -maxpose <num>      Number of poses to refine (per comformer if -conf) prior to final score (DEFAULT: {})
    -remaxpose <num>    Number of poses to return (per conformer if -conf) after refinement prior 
                            to final score (DEFAULT: {})
    -inducedfit (bool)  Use induced-fit (refined) target docking and return the associated PDB 
                            (DEFAULT: {})
    -rigidlig (bool)    Dock the ligand/conformer rigidly with no in-site optimization (DEFAULT: {})
    -preopt (bool)      Optimize the target:placed_ligand PRIOR to performing docking (DEFAULT: {})
    -protonate (bool)   Run Protonate3D on the target:placed_ligand PRIOR to docking (DEFAULT: {})
    -forceexe (bool)    Force execution even when Check Molecule process fails (DEFAULT: {})
    -help               Print this help screen and quit without running any further steps.

FILES RETURNED/GENERATED (to be used in MTScoreE)

    pro_<ligand>_predock.pdb    A fully prepared PDB file of the receptor 
                                    (e.g. AFTER -preopt or -protonate if these options are selected)
    lig_<ligand>_predock.mol2   A fully prepared mol2 file of the placed ligand 
                                    (e.g. AFTER -preopt or -protonate if these options are selected)
    <ligand>_dock.sdf           The docked ligand poses generated using the MOE docker if 
                                    -inducedfit is NOT selected
    <ligand>_dock_<num>.pdb     The docked target:ligand poses generated using the MOE docker if 
                                    -inducedfit IS selected
    
SUBSEQUENT USAGE (in MTScoreE [Ensemble] Score)

    Once the above noted files are generated

    * FOR RIGID RECEPTOR SCORING:
        $ /path/to/DivConSuite/bin/qmechanic pro_<ligand>_predock.pdb       \\
            --ligand lig_<ligand>_predock.mol2 --mtdock <ligand>_dock.sdf   \\
            --mtscore ensembe -v 2 --np 2

    * FOR INDICED FIT RECEPTOR SCORING:
        $ /path/to/DivConSuite/bin/qmechanic pro_<ligand>_predock.pdb       \\
            --ligand lig_<ligand>_predock.mol2 --mtdock <ligand>_dock_*.pdb \\
            --mtscore ensembe -v 2 --np 2

DOCUMENTATION
    The qbDockPair.svl script is used to encapsulate the steps required to use MOE to dock a
    ligand in preparation for MTScoreE (Ensemble) and MTScoreES (EndState). You may generate an
    SDF in another way or with an alternative docking function, but it is suggested that a
    similar workflow is used. In this case, the MOE software uses the following default settings:
    
        Potential:              {}
        Initial Placement:      {}
        Initial Score Function: {}
        Ligand Optimization:    {}  // NOTE: The ligand is optimized in the active site
        Final Score Function:   {}
    
#,   
        yesno defaults.delwat,
        yesnotoken getenv 'QBHOME',
        opt.rescoring, yesno defaults.mtscorees,
        defaults.maxpose,
        defaults.remaxpose,
        yesno defaults.inducedfit,
        yesno defaults.rigidlig,
        yesno defaults.preopt,
        yesno defaults.protonate,
        yesno defaults.forceexe,
        second first pot_Info[],
        opt.placement,
        opt.scoring,
        opt.refine,
        opt.rescoring
    ];

endfunction

local function DockOpt []

    local opt = [
        outrmsd: 1,
        sel_ent_only_rec: 0,
        sel_ent_only: 0,
        wall: [ '', 0, [ 0, 0, 0 ], [ 1000000, 1000000, 1000000 ], 0 ],
        csearch: 0,
        confGenMethod: 'None',
        ignoreMseq: 0,
//	    retainData: [ 1, 0, 1, 1],
        placement: 'Triangle Matcher',
        scoring: 'London dG',
        scoring_opt: [  ],
        dup_placement: 1,
        
    // RIGID BODY
//        placement_opt: [ timeout : 300,	nretpose : 10000 ],
//        maxpose: 300,
//        refine: 'None',
//        refine_opt: [ fixrec : '', rigidlig : 1,	rigidPlanar : 0 ],
    // Limited OPT
        placement_opt: [ timeout : 300,	nretpose : 5000 ],
        maxpose: 50,
        remaxpose: 5,
        refine: 'Rigid Receptor',
        refine_opt: [ 
            fixrec : 'Fix',	
            ed_map : 'Fo',	
            ed_f : 'Simulated',	
            ed_phi : 'Simulated',	
            ed_f2 : 'Simulated',	
            ed_path : '',	
            ed_res : 2.5,	
            ed_sfdata : [ [  ], [  ], [  ], 'Simulated', 'Simulated', 'Fo' ],	
            ed_surflevelD : 3,	
            cutoff : 6,	
            wholeres : 1,	
            mmgbvi : 1,	
            packsidechains : 1,	
            rigidlig : 0,	
            rigidPlanar : 0,	
            tether : 10,	
            gtest : 0.01,	
            maxit : 500,	
            OverrideSetup : 1,	
            k_potl : 100,	
            roffset : 0.4 
        ],
        rescoring: 'GBVI/WSA dG',
        rescoring_opt: [  ],
        dup_refine: 1,
        descexpr: '',
        receptor_mfield: '',
        ligand_mfield: 'mol',
        rxnFile: '',
        rxsite: [  ],
        edsupport: 1,
//        ed_data: [ ed_dockpath : '' ],
        check_pose_geom: [  ],
        multiLigand: 0,
        need_dmat: 1,
        gen_plif: 1,
        tempDB: '',
//        ph4: ph4file,
//        ligmdbname: ligmdbname,
//        recmdbname: recmdbname,
        BatchFile: 'dock_batch.svl'
    ];

    return opt;

endfunction

local function checkMolecule[]

    local sysbool = 1;

    local prepTypes = StructurePreparation [cmd:'_types'];
    prepTypes = diff [prepTypes, ['HCount','Charge','FF']];
    local SPREP_prob = StructurePreparation [disableTypes:prepTypes,batch_protonate3d:0, cmd:'_items'];
    
    if length SPREP_prob(4) > 0 then
        write ['ERROR: MOE reports the following structural/chemical problems are found in this structure.\n'];
        write ['\t/Chain/ResName/ResUID/AtmName/\tProblem\n'];
        local i = 1;
        while i <= length SPREP_prob(4) loop
            local errorText = SPREP_prob(3)(i);
            apt write ['\t\t/{}/{}/{}/{}/\t\t{}\n',  fext cName aChain SPREP_prob(4)(i), rName aResidue SPREP_prob(4)(i), rUID aResidue SPREP_prob(4)(i), aName SPREP_prob(4)(i),errorText]; //, SPREP_prob(3)];
        i = i+1;
        endloop
        sysbool = 0;
    endif
     
    return sysbool;
    
endfunction

local function dockmdb2mol2 [db_file,mol2_file,ligID,targ_pdb,mainopt]
    local mdb = db_Open db_file;
    local mfield = '';

	// make sure that our database contains the right exportable field
	// and then open the output file
    local [fldnames, fldtypes] = db_Fields mdb;

    mfield = fldnames | fldtypes == 'molecule';

	// run through the database and write the data to the file

    local ent = 0;
    local count = 0;
    local mol = [];
    local targ_chains = [];
    local lig_chains = [];
    local chains = [];
    local inopt;
    local pdata;
    local filelist = [];
    
    while (ent = db_NextEntry [mdb, ent]) loop
        local psys = SystemPush [];
        
        count = count + 1;
        local outmol2 = twrite ['{}_{}.{}', fbase mol2_file, count, fext mol2_file];
        filelist = cat [filelist, outmol2];
        write['Translating .... {}\n',outmol2];
        pdata = tag [fldnames, db_ReadFields [mdb, ent, fldnames]];
    
        inopt.pdata = pdata | m_diff [tags pdata, mfield];
        
        if length mfield == 2 then
            mol =  pdata.(second mfield);       // receptor in dock.mdb
            targ_chains = mol_Create mol;
            cSetName [targ_chains | cName targ_chains == '', mol(1)(MOL_NAME)];
        else
            ReadAuto targ_pdb;
            if mainopt.delwat then
                write ['NOTE: SOLVENT REMOVED PRIOR TO DOCKING (used -delwat to remove solvent)\n'];
                oDestroy uniq cat aResidue _Atoms '$$solvent';
            else
                write ['NOTE: SOLVENT NOT REMOVED PRIOR TO DOCKING (use -delwat to remove solvent)\n'];
            endif
            targ_chains = Chains[];
        endif
        
        mol =  pdata.(first mfield);        // ligand in dock.mdb
        lig_chains = mol_Create mol;
        cSetName [lig_chains | cName lig_chains == '', mol(1)(MOL_NAME)];
        
        local ligResidue = first cat cResidues lig_chains;
        local ligChain = rChain ligResidue;
        
        rSetINS [ligResidue, ligID.rINS];
        rSetName [ligResidue, ligID.rName];
        rSetType [ligResidue, ligID.rType];
        rSetUID [ligResidue, ligID.rUID];

        cSetName [ligChain, ligID.cName];
        cSetGroup [ligChain, ligID.cGroup];
        cSetNumber [ligChain, ligID.cNumber];
        cSetTag [ligChain, ligID.cTag];

        chains = cat [targ_chains,lig_chains];

        if fext mol2_file == 'pdb' then
            fwrite_PDB [outmol2,chains,inopt];
        else
            fwrite_TriposMOL2 [outmol2,chains,inopt];
#if 0
            // START: (TEMPORARY KLUDGE ALERT) clean up '****' SUBSTRUCTURE "problem"
            local tmpMol2 = twrite ['{}-tmp.mol2', fbase outmol2];
            local fnum = fopenrz outmol2;
            local foutnum = fopenw tmpMol2;
        
            local ldata;
            local field_array;
            local bSubStructure = 0;
            while length (ldata = freadb [fnum, 'line', 1]) loop
                ldata = swrite ['{}',ldata];
                if strpos ["@<TRIPOS>SUBSTRUCTURE", ldata] == 1 then
                    bSubStructure = 1;
                elseif strpos ["@<TRIPOS>", ldata] == 1 then
                    bSubStructure = 0;
                endif
                if bSubStructure then
                    field_array = wordsplit [ldata, " "];
                    if length field_array == 8 then
                        if field_array(7) === "****" then       // For now we need to translate this to the residue code
                            if field_array(2)(1) == "Q" and isscalarnum atoi twrite ['{}',field_array(2)(2)] then       // translate this MOE/Sybil-ism back to the original code
                                field_array(2) = dropfirst field_array(2);
                            endif
                            while length field_array(2) < 4 loop
                                field_array(2) = cat [field_array(2), " "];
                            endloop
                            // just want the last set of "****" (which corresponds to the residue)
                            ldata = reverse ldata;
                            ldata = splice [ldata, strpos ["****",ldata], 4, reverse field_array(2)];
                            ldata = reverse ldata;
                        endif
                    endif
                endif
                fwriteb [foutnum, 'line', ldata];        
            endloop
            fclose fnum;
            fclose foutnum;
            freplace [tmpMol2, outmol2];    // replace the old file with the new file (no need to keep both around)
            // END: (TEMPORARY KLUDGE ALERT) clean up '****' SUBSTRUCTURE "problem"
#endif
        endif
        oDestroy chains;
        
        SystemPop psys;
    endloop
    
    return filelist;
endfunction

local function runDock [inopt, rec, lig]

endfunction

local function main []
    local startcputime = cpuclock[];
    local starttime = clock[];
    local inopt;
    ArgvReset ArgvExpand argv;
    // -------
//        Command line processing in MOE appears to be a multi-step process depending upon whether we are removing arguments from the stream (for error trapping)
//            and whether we are trying to determine whether an option is chosen. This is specifically the case when it comes to -mtscoreexe which can take an argument or not. 
//              Steps:
//            1. Just read or Get whether it is set (yes/no bool)
//            2. Skip it in the main argument processing since it may have an argument or it may not (depending on whether QBHOME is used)
//            3. Finally remove it from the stream, and place a set path in a variable if one is chosen (if not, it is just null).
    // -------
    local [mtscoreexe] = ArgvGet [ ['-mtscoreexe'], [0]];
    local [recfilename, ligfilename, novelligfname, conffilename, dockedligfname, outf, delwat, mtscorees, maxpose, mtcsconf, remaxpose, inducedfit, rigidlig, dockmdb, offormat, preopt, protonate, forceexe, printhelp, testinp] = 
        ArgvPull [ ['-rec', '-lig','-novellig','-conf','-dockedlig','-o','-delwat','-mtscorees','-maxpose','-mtcsconf', '-remaxpose','-inducedfit','-rigidlig','-dockmdb','-offormat','-preopt','-protonate','-forceexe','-help','-testinp'], 
        [1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,0,0,0,0,0] ];
    local [runqmechanic] = ArgvPull [ ['-mtscoreexe'], [1] ];
    local remaining = ArgvAll [];
    if not isnull remaining then
        usage[];
        exit twrite ['ERROR: Unknown command line options: {}\n',remaining];
    endif
    if printhelp then
        usage[];
        exit[];
    endif
    inopt.delwat = delwat;
    inopt.inducedfit = inducedfit;
    inopt.mtscorees = mtscorees;
    inopt.maxpose = atoi maxpose;
    inopt.mtcsconf = atoi mtcsconf;
    inopt.remaxpose = atoi remaxpose;
    inopt.rigidlig = rigidlig;
    inopt.offormat = offormat;
    inopt.preopt = preopt;
    inopt.protonate = protonate;
    inopt.forceexe = forceexe;
    inopt.mtscoreexe = mtscoreexe;
    inopt.testinp = testinp;
    
    inopt.recfilename = recfilename;
    inopt.ligfilename = ligfilename;
    inopt.novelligfname = novelligfname;
    inopt.conffilename = conffilename;
    inopt.dockedligfname = dockedligfname;
    inopt.outf = outf;
    inopt.dockmdb = dockmdb;

    // In the event that no conformers are provided we will use the standard docking function.
    //  With that in mind, we should bump up the defaults.
    local defaults = DEFAULT_OPT;
    if isnull inopt.conffilename then
        defaults.maxpose = ceil (DEFAULT_OPT.maxpose * (DEFAULT_OPT.maxpose/DEFAULT_OPT.remaxpose));
        defaults.remaxpose = ceil (DEFAULT_OPT.remaxpose * (DEFAULT_OPT.maxpose/DEFAULT_OPT.remaxpose));
    endif
    
    if inducedfit then
        defaults.offormat = 'pdb';
    else
        defaults.offormat = 'sdf';
    endif
    
    inopt = tagcat [inopt, defaults];
    
    write ['inopt: {}\n',inopt];

    if not isnull inopt.recfilename then
        local rec = cat cat cAtoms ReadAuto inopt.recfilename;
        if isnull rec then
            exit twrite ['Cannot read receptor file {}', inopt.recfilename];
        endif
    else
        exit twrite ['Use -rec command line argument to provide an input file for RECEPTOR'];
    endif
    
    if inopt.mtscoreexe then
        if not isnull runqmechanic then
            inopt.qbhome = runqmechanic;
        elseif not isnull getenv ['QBHOME'] then
            inopt.qbhome = getenv ['QBHOME'];
        else
            usage [];
            exit twrite ['Envionrment variable QBHOME is not set. Either set this shell variable or provide the path to QBHOME in -mtscoreexe argument.\n'];
        endif
        local qmechanicexec = twrite ['{}/bin/qmechanic', inopt.qbhome];
        local file_info = fstat qmechanicexec;
        if file_info(1) <> 'file' then
            usage [];
            exit twrite ['Executable: {} does not exist\n\tPlease correctly set your QBHOME enivronment variable or -mtscoreexe argument.\n',qmechanicexec];
        endif
        if not bitand [file_info(3), 0x04] then
            usage [];
            exit twrite ['Executable: {} is not allowed to be executed\n',qmechanicexec];
        endif
    endif
    
    // perform some house cleaning
//      oDestroy (Residues [] | rName Residues[] == 'EOH');
//      oDestroy (Residues [] | rName Residues[] == 'GOL');
//      oDestroy (Residues [] | rName Residues[] == 'DMS');
//      oDestroy (Residues [] | rName Residues[] == 'SO4');
    rec = rec | oValid rec;
    
    local lig, ligResidue, ligfext;
    if not isnull inopt.ligfilename then
        lig = cat cat cAtoms ReadAuto inopt.ligfilename;
        ligResidue = aResidue first lig;
        ligfext = fext inopt.ligfilename;
        oReparent [diff [lig, first lig], ligResidue];  // MOE appears to need all lignad atoms in a single residue
        if isnull lig then
            exit twrite ['Cannot read receptor file {}', inopt.ligfilename];
        endif
    elseif length uniq aResidue _Atoms '$$ligand' == 1 then
        lig = _Atoms '$$ligand';
        ligResidue = aResidue first lig;
        inopt.ligfilename = rName ligResidue;
        ligfext = 'mol2';       // when no file is provided for the ligand we will default to writing out a mol2
        write ['WARNING: Using Ligand {} found in {}. Use -lig command line argument to provide an input file for LIGAND\n', rName ligResidue, inopt.recfilename];
    elseif length uniq aResidue _Atoms '$$ligand' > 1 then
        exit twrite ['{} Ligands found in {}. Use -lig command line argument to provide an input file for LIGAND\n', length uniq aResidue _Atoms '$$ligand', inopt.recfilename];
    else
        exit twrite ['No Ligand found in {}. Use -lig command line argument to provide an input file for LIGAND\n', inopt.recfilename];
    endif
    
    rec = diff [rec,lig];   // make sure the receptor does not include the ligand.

    if isnull inopt.outf and isnull inopt.novelligfname then
        inopt.outf = twrite ['{}_dock.mdb',fbase ftail inopt.ligfilename];
    elseif isnull inopt.outf and not isnull inopt.novelligfname then
        inopt.outf = twrite ['{}_dock.mdb',fbase ftail inopt.novelligfname];
    else
        inopt.outf = twrite ['{}.mdb',fbase inopt.outf];
    endif;
        
    // Need the UID, etc of the ligand read in so the write process can rename back (this circumvents the SDF problem which effectively "washes" out these terms).
    local ligChain = rChain ligResidue;
    local ligID;
    ligID.rINS = rINS ligResidue;
    ligID.rName = rName ligResidue;
    ligID.rNumber = rNumber ligResidue;
    ligID.rType = rType ligResidue;
    ligID.rUID = rUID ligResidue;
    
    ligID.cName = fext cName ligChain;
    ligID.cGroup = cGroup ligChain;   
    ligID.cNumber = cNumber ligChain;   
    ligID.cTag = cTag ligChain;
    
    // if the user provides a inopt.dockmdb then we assume they wish to perform the final translation to qmechanic-readabe output (SDF or MOL2 depending)
    if isnull inopt.dockmdb then

        local opt = DockOpt[];
        opt = tagcat [ [maxpose: inopt.maxpose], opt ];
        opt = tagcat [ [remaxpose: inopt.remaxpose], opt ];
        
        if inopt.protonate then
//            Protonate3D [Atoms[],rec,rec,lig,[],[]];    // Only manipulate protonation of the target (the ligand is left as is)
            Protonate3D [Atoms[],rec,rec,[],[],[]];    // protonate both the protein and the ligand
        endif

        local bool_DelNovelligmdb = 0;
        if not isnull inopt.conffilename then
            local confmdbname = twrite ['{}.mdb',fbase ftail inopt.conffilename];
            db_ImportSD [db_Open [ confmdbname,'create' ],inopt.conffilename,'mol',
                ['BFIntensity','BFIRank','Energy','Z_L','SumBFIntensity','SumNonbondedIntensity'],
                ['BFIntensity','BFIRank','Energy','Z_L','SumBFIntensity','SumNonbondedIntensity'],
                ['double','int','double','char','double','double']        
            ];
// TODO: Provide a mechanism to limit the number of conformers used.
//            db_Sort [confmdbname,'BFIRank',1];
//            if inopt.mtcsconf > 0 then
//                if (db_nEntries confmdbname) > inopt.mtcsconf then
//                    db_Delete [confmdbname, (db_Entries confmdbname)[igen ((db_nEntries confmdbname)-inopt.mtcsconf)]];
//                endif
//            endif
//            db_Sort [confmdbname,'BFIRank',0];
            write ['NOTE: Using {} conformers provided in {}.\n', db_nEntries confmdbname, confmdbname];
            opt.retainData = not (first db_Fields confmdbname == 'mol');
        elseif not isnull inopt.dockedligfname then
            local dockedligmdbname = twrite ['{}.mdb',fbase ftail inopt.dockedligfname];
            db_ImportSD [db_Open [ dockedligmdbname,'create' ],inopt.dockedligfname,'mol'];
        elseif not isnull inopt.novelligfname then
            local novelligmdbname;
            if fext ftail inopt.novelligfname <> 'mdb' then
                novelligmdbname = twrite ['1234567890-{}.mdb',fbase ftail inopt.novelligfname];
                if fext ftail inopt.novelligfname == 'sdf' then
                    db_ImportSD [db_Open [ novelligmdbname,'create' ], inopt.novelligfname,'mol'];
                elseif fext ftail inopt.novelligfname == 'mol2' then
                    db_ImportMOL2 [inopt.novelligfname, db_Open [ novelligmdbname,'create' ],'mol'];
                endif
                bool_DelNovelligmdb = 1;
            else
                novelligmdbname = inopt.novelligfname;
            endif                
        endif

        // For older versions of MOE - need to rename BFIRank to mseq so it can be used in MTCS calculation    
        if MOE_VERSION < 2018 then
            db_RenameField [confmdbname,'BFIRank','mseq'];
        endif

        if inopt.inducedfit then
            opt.refine='Induced Fit';
            opt.refine_opt.fixrec='Tether';   
        endif
        
        if inopt.rigidlig then
            opt.refine_opt.rigidlig=1;   
            opt.refine_opt.rigidPlanar=1;   
        endif            
    
        if mtscorees then
            opt = tagcat [ [rescoring: 'MTScoreES dG [QuantumBio]'], opt ];
        endif
        
        pot_Load '$MOE/lib/Amber10EHT.ff';

        // Note that the following is the general potential set up only.
        // Individual stages like refinement may use a modified set up.
        pot_Setup [
            strEnable: 1,
            angEnable: 1,
            stbEnable: 1,
            oopEnable: 1,
            torEnable: 1,
            vdwEnable: 1,
            eleEnable: 1,
            solEnable: 0,
            resEnable: 1,
            strWeight: 1,
            angWeight: 1,
            stbWeight: 1,
            oopWeight: 1,
            torWeight: 1,
            vdwWeight: 1,
            eleWeight: 1,
            solWeight: 1,
            resWeight: 1,
            cutoffEnable: 1,
            cutoffOn: 8,
            cutoffOff: 10,
            eleDist: 2,
            vdwScale14: 0.5,
            vdwBuffer1: 0,
            vdwBuffer2: 0,
            eleScale14: 0.833333,
            eleDielectric: 1,
            eleBuffer: 0,
            solDielectric: 80,
            solDielectricOffset: 0,
            state0: 1,
            state1: 0,
            state2: 1,
            threadCount: 0
        ];
        pot_SetCharges [];

        // Check system to make sure it is ready to roll - and throw error with suggested ways around it
        local sysbool = checkMolecule[];

        if not sysbool then
            write ['\tDouble check molecular input in GUI and run Structure Prep as required.\n'];  
            if not inopt.forceexe then
                write ['\tYou may choose to force the calculation to proceed using -forceexe command line.\n'];
                return[];
            else
                write ['WARNING: You have chosen to -forceexe the calculation to proceed without fixing the problems noted.\n'];
            endif
        else
            write ['Molecular system parameterized.'];
        endif
        
        if inopt.testinp then
            write ['Input test complete (remove -testinp to run simulation as reqested)\n'];
        endif
        
        if inopt.preopt then
            write ['NOTE: RUNNING MM OPT with {}\n', 'Amber10EHT.ff'];
            local tetherWeight = rep [opt.refine_opt.tether, length Atoms[]];
            local moveMask = aAtomicNumber Atoms[] <= 1;
            (tetherWeight | moveMask) = 0;
            MM[gtest:opt.refine_opt.gtest,maxit:opt.refine_opt.maxit, tetherWeight:tetherWeight ];
        else
            write ['NOTE: Skipping MM complex minimization prior to docking (use -preopt to turn ON optimization)\n'];
        endif

        if inopt.delwat then
            write ['NOTE: SOLVENT REMOVED PRIOR TO DOCKING (used -delwat to remove solvent)\n'];
            oDestroy uniq cat aResidue _Atoms '$$solvent';
        else
            write ['NOTE: SOLVENT NOT REMOVED PRIOR TO DOCKING (use -delwat to remove solvent)\n'];
        endif
        lig = lig | oValid lig;
        rec = rec | oValid rec;
        write ['STARTING SIZE:   {} | {}\n', length rec, length lig];
        lig = cat cat rAtoms (uniq aResidue lig);     // address any changes which may have been made to the ligand (protons, etc)
        rec = cat cat rAtoms (uniq aResidue rec);     // address any changes which may have been made to receptor (protons, etc)
        write ['ENDING SIZE:     {} | {}\n', length rec, length lig];
        local site = lig;
        
        // Write the _predock versions of any input PDB & mol2 files so that these can be used in qmechanic
        local syskeys = SystemPush rec;
        local pro_predock = twrite ['pro_{}_predock.{}', fbase inopt.ligfilename, fext inopt.recfilename];
        write ['{}\n', pro_predock];
        WriteAuto [pro_predock];
        SystemPop syskeys;

        local lig_predock = twrite ['lig_{}_predock.{}', fbase inopt.ligfilename, ligfext];
        write ['{}\n', lig_predock];
        syskeys = SystemPush lig;
        WriteAuto [lig_predock];
        SystemPop syskeys;

        write ['NOTE: RUNNING {} Docking with {} as MOE/Dock Final Scoring Function\n', opt.refine, opt.rescoring];
        if not isnull confmdbname then
            opt = tagcat [ [ligmdbname: confmdbname], opt ];
            DockFile [rec, site, confmdbname, inopt.outf, opt];
        elseif not isnull dockedligmdbname then
            opt = tagcat [ [ligmdbname: dockedligmdbname, placement: 'None'], opt ];
            DockFile [rec, site, dockedligmdbname, inopt.outf, opt];
        elseif not isnull novelligmdbname then
            DockFile [rec, site, novelligmdbname, inopt.outf, opt];
            if bool_DelNovelligmdb then
                fdelete novelligmdbname;
            endif
        else
            DockAtoms [ rec,  site,  lig, inopt.outf, opt];
        endif
        // For older versions of MOE - need to rename mseq to BFIRank so it can be used in MTCS calculation
        if MOE_VERSION < 2018 then
            db_RenameField [inopt.outf,'mseq','BFIRank'];
        endif
        inopt.dockmdb = inopt.outf;
    endif
    
    db_Sort [inopt.dockmdb,'S',0];
    local dockfiles;
    if inopt.inducedfit then
        dockfiles = dockmdb2mol2 [inopt.dockmdb,twrite ['{}.{}',fbase ftail inopt.outf,inopt.offormat],ligID,inopt.recfilename,inopt];
    else
        dockfiles = twrite ['{}.sdf',fbase inopt.outf];
        db_ExportSD [ inopt.dockmdb, dockfiles];
        if inopt.offormat <> 'sdf' then
            dockfiles = dockmdb2mol2 [inopt.dockmdb,twrite ['{}.{}',fbase ftail inopt.outf,inopt.offormat],ligID,inopt.recfilename,inopt];
        endif
write ['test: {}\n', dockfiles];
        local mdbdata = db_Read [inopt.dockmdb,first db_Entries inopt.dockmdb];
        fwrite_TriposMOL2 [twrite ['{}.mol2',fbase ftail inopt.outf],mol_Create mdbdata.mol];
    endif

    write ['Docking finished in {} seconds & {} CPUseconds.\n', clock[] - starttime, cpuclock[] - startcputime];
    
    if inopt.mtscoreexe then
        starttime = clock[];
        startcputime = cpuclock[];
        
        local qme_command = twrite ['{} {} --ligand {} -h garf --mtdock {} --mtscore ensemble --np 2 -v 2 -O',qmechanicexec, pro_predock, lig_predock, dockfiles];
        write ['Running: {}\n',qme_command];
        local pkey = exe_open_shell[qme_command,cd [],[],0];
        local out_fno = exe_stdout pkey;
        write '    -----------------------\n';
        while exe_status pkey loop
            local outline;
            while not isnull (outline = freadb [out_fno, 'line', 1]) loop
                write ['    {}\n', outline];
            endloop
        endloop
        write '    -----------------------\n';
        exe_close pkey;
        
        write ['MTScoreE finished in {} seconds.\n', clock[] - starttime];
    endif
endfunction


#svl

//  USAGE:
//      moebatch -run qbDockPair.svl -rec receptor.pdb -lig ligand.mol2 -conf conformers.sdf

global argv;

// forward declarations
function PartialCharge;
function ArgvPull;
function fwrite_TriposMOL2;
function mol_Create;
function MM;
function StructurePreparation;
function Protonate3D;

local function DockOpt []

    local opt = [
        outrmsd: 1,
        sel_ent_only_rec: 0,
        sel_ent_only: 0,
        wall: [ '', 0, [ 0, 0, 0 ], [ 1000000, 1000000, 1000000 ], 0 ],
        csearch: 0,
        confGenMethod: 'None',
        ignoreMseq: 0,
//	    retainData: [ 1, 0, 1, 1],
        placement: 'Triangle Matcher',
        scoring: 'London dG',
        scoring_opt: [  ],
        dup_placement: 1,
        
    // RIGID BODY
//        placement_opt: [ timeout : 300,	nretpose : 10000 ],
//        maxpose: 300,
//        refine: 'None',
//        refine_opt: [ fixrec : '', rigidlig : 1,	rigidPlanar : 0 ],
    // Limited OPT
        placement_opt: [ timeout : 300,	nretpose : 5000 ],
        maxpose: 50,
        remaxpose: 5,
        refine: 'Rigid Receptor',
        refine_opt: [ 
            fixrec : 'Fix',	
            ed_map : 'Fo',	
            ed_f : 'Simulated',	
            ed_phi : 'Simulated',	
            ed_f2 : 'Simulated',	
            ed_path : '',	
            ed_res : 2.5,	
            ed_sfdata : [ [  ], [  ], [  ], 'Simulated', 'Simulated', 'Fo' ],	
            ed_surflevelD : 3,	
            cutoff : 6,	
            wholeres : 1,	
            mmgbvi : 1,	
            packsidechains : 1,	
            rigidlig : 0,	
            rigidPlanar : 0,	
            tether : 10,	
            gtest : 0.01,	
            maxit : 500,	
            OverrideSetup : 1,	
            k_potl : 100,	
            roffset : 0.4 
        ],
        rescoring: 'GBVI/WSA dG',
        rescoring_opt: [  ],
        dup_refine: 1,
        descexpr: '',
        receptor_mfield: '',
        ligand_mfield: 'mol',
        rxnFile: '',
        rxsite: [  ],
        edsupport: 1,
        ed_data: [ ed_dockpath : '' ],
        check_pose_geom: [  ],
        multiLigand: 0,
        need_dmat: 1,
        gen_plif: 1,
        tempDB: '',
//        ph4: ph4file,
//        ligmdbname: ligmdbname,
//        recmdbname: recmdbname,
        BatchFile: 'dock_batch.svl'
    ];

    return opt;

endfunction

local function checkMolecule[]

    local sysbool = 1;

    local prepTypes = StructurePreparation [cmd:'_types'];
    prepTypes = diff [prepTypes, ['HCount','Charge','FF']];
    local SPREP_prob = StructurePreparation [disableTypes:prepTypes,batch_protonate3d:0, cmd:'_items'];
    
    if length SPREP_prob(4) > 0 then
        write ['ERROR: MOE reports the following structural/chemical problems are found in this structure.\n'];
        write ['\t/Chain/ResName/ResUID/AtmName/\tProblem\n'];
        local i = 1;
        while i <= length SPREP_prob(4) loop
            local errorText = SPREP_prob(3)(i);
            apt write ['\t\t/{}/{}/{}/{}/\t\t{}\n',  fext cName aChain SPREP_prob(4)(i), rName aResidue SPREP_prob(4)(i), rUID aResidue SPREP_prob(4)(i), aName SPREP_prob(4)(i),errorText]; //, SPREP_prob(3)];
        i = i+1;
        endloop
        sysbool = 0;
    endif
     
    return sysbool;
    
endfunction

function db_ImportSD;
function db_Sort;
function db_Delete;
function db_ExportSD;
function DockAtoms;
function DockFile;

local function dockmdb2mol2 [db_file,mol2_file,ligID,targ_pdb,mainopt]
    local mdb = db_Open db_file;
    local mfield = '';

	// make sure that our database contains the right exportable field
	// and then open the output file
    local [fldnames, fldtypes] = db_Fields mdb;

    mfield = fldnames | fldtypes == 'molecule';

	// run through the database and write the data to the file

    local ent = 0;
    local count = 0;
    local mol = [];
    local targ_chains = [];
    local lig_chains = [];
    local chains = [];
    local inopt;
    local pdata;
    while (ent = db_NextEntry [mdb, ent]) loop
        local psys = SystemPush [];
        
        count = count + 1;
        local outmol2 = twrite ['{}_{}.{}', fbase mol2_file, count, fext mol2_file];
        write['Translating .... {}\n',outmol2];
        pdata = tag [fldnames, db_ReadFields [mdb, ent, fldnames]];
    
        inopt.pdata = pdata | m_diff [tags pdata, mfield];
        
        if length mfield == 2 then
            mol =  pdata.(second mfield);       // receptor in dock.mdb
            targ_chains = mol_Create mol;
            cSetName [targ_chains | cName targ_chains == '', mol(1)(MOL_NAME)];
        else
            ReadAuto targ_pdb;
            if mainopt.delwat then
                write ['NOTE: SOLVENT REMOVED PRIOR TO DOCKING\n'];
                oDestroy uniq cat aResidue _Atoms '$$solvent';
            else
                write ['NOTE: SOLVENT NOT REMOVED PRIOR TO DOCKING\n'];
            endif
            targ_chains = Chains[];
        endif
        
        mol =  pdata.(first mfield);        // ligand in dock.mdb
        lig_chains = mol_Create mol;
        cSetName [lig_chains | cName lig_chains == '', mol(1)(MOL_NAME)];
        
        local ligResidue = first cat cResidues lig_chains;
        local ligChain = rChain ligResidue;
        
        rSetINS [ligResidue, ligID.rINS];
        rSetName [ligResidue, ligID.rName];
        rSetType [ligResidue, ligID.rType];
        rSetUID [ligResidue, ligID.rUID];

        cSetName [ligChain, ligID.cName];
        cSetGroup [ligChain, ligID.cGroup];
        cSetNumber [ligChain, ligID.cNumber];
        cSetTag [ligChain, ligID.cTag];

        chains = cat [targ_chains,lig_chains];

        if fext mol2_file == 'pdb' then
            fwrite_PDB [outmol2,chains,inopt];
        else
            fwrite_TriposMOL2 [outmol2,chains,inopt];
#if 0
            // START: (TEMPORARY KLUDGE ALERT) clean up '****' SUBSTRUCTURE "problem"
            local tmpMol2 = twrite ['{}-tmp.mol2', fbase outmol2];
            local fnum = fopenrz outmol2;
            local foutnum = fopenw tmpMol2;
        
            local ldata;
            local field_array;
            local bSubStructure = 0;
            while length (ldata = freadb [fnum, 'line', 1]) loop
                ldata = swrite ['{}',ldata];
                if strpos ["@<TRIPOS>SUBSTRUCTURE", ldata] == 1 then
                    bSubStructure = 1;
                elseif strpos ["@<TRIPOS>", ldata] == 1 then
                    bSubStructure = 0;
                endif
                if bSubStructure then
                    field_array = wordsplit [ldata, " "];
                    if length field_array == 8 then
                        if field_array(7) === "****" then       // For now we need to translate this to the residue code
                            if field_array(2)(1) == "Q" and isscalarnum atoi twrite ['{}',field_array(2)(2)] then       // translate this MOE/Sybil-ism back to the original code
                                field_array(2) = dropfirst field_array(2);
                            endif
                            while length field_array(2) < 4 loop
                                field_array(2) = cat [field_array(2), " "];
                            endloop
                            // just want the last set of "****" (which corresponds to the residue)
                            ldata = reverse ldata;
                            ldata = splice [ldata, strpos ["****",ldata], 4, reverse field_array(2)];
                            ldata = reverse ldata;
                        endif
                    endif
                endif
                fwriteb [foutnum, 'line', ldata];        
            endloop
            fclose fnum;
            fclose foutnum;
            freplace [tmpMol2, outmol2];    // replace the old file with the new file (no need to keep both around)
            // END: (TEMPORARY KLUDGE ALERT) clean up '****' SUBSTRUCTURE "problem"
#endif
        endif
        oDestroy chains;
        
        SystemPop psys;
    endloop

endfunction

const DEFAULT_OPT = [
    delwat      : 0,        // Delete waters prior to performing docking/placement but AFTER any optimization if -preopt chosen
    inducedfit  : 0,        // Run induced fit (optimized protein) on dock
    ifformat    : 'pdb',    // output this version of output for induced fit (can be either 'pdb' or 'mol2')
    mtscorees   : 0,        // Run (1) 'MTScoreES dG [QuantumBio]' via qbWebService or (0) 'GBVI/WSA dG' for final score
    mtcsconf    : 5,        // Number of MTCS conformers to use (these are the best X conformers according to BFintensity).
    maxpose     : 50,       // Number of poses to optimize (per posed conformer) prior to final score
    remaxpose   : 5,        // Max number of poses to return per conformer (after optimization)
    rigidlig    : 0,        // Run with the ligand/conformation treated rigidly
    preopt      : 0,        // Run an optimization of the protein:ligand complex prior to docking
    protonate   : 0,        // Run Protonate3D prior to docking/scoring
    forceexe    : 0         // Force the calculation to proceed even if there are structural defects
];

local function main []
    local startcputime = cpuclock[];
    local starttime = clock[];
    local inopt;
    ArgvReset ArgvExpand argv;
    local [recfilename, ligfilename, conffilename, outf, delwat, mtscorees, maxpose, mtcsconf, remaxpose, inducedfit, rigidlig, dockmdb, ifformat, preopt, protonate, forceexe] = ArgvPull [ ['-rec', '-lig','-conf','-o','-delwat','-mtscorees','-maxpose','-mtcsconf', '-remaxpose','-inducedfit','-rigidlig','-dockmdb','-ifformat','-preopt','-protonate','-forceexe'], [1,1,1,1,0,0,1,1,1,0,0,1,1,0,0,0] ];
    local remaining = ArgvAll [];
    if not isnull remaining then
        exit twrite ['ERROR: Unknown command line options: {}\n',remaining];
    endif
    inopt.delwat = delwat;
    inopt.inducedfit = inducedfit;
    inopt.mtscorees = mtscorees;
    inopt.maxpose = atoi maxpose;
    inopt.mtcsconf = atoi mtcsconf;
    inopt.remaxpose = atoi remaxpose;
    inopt.rigidlig = rigidlig;
    inopt.ifformat = ifformat;
    inopt.preopt = preopt;
    inopt.protonate = protonate;
    inopt.forceexe = forceexe;

    // In the event that no conformers are provided we will use the standard docking function.
    //  With that in mind, we should bump up the defaults.
    local defaults = DEFAULT_OPT;
    if isnull conffilename then
        defaults.maxpose = ceil (DEFAULT_OPT.maxpose * (DEFAULT_OPT.maxpose/DEFAULT_OPT.remaxpose/2));
        defaults.remaxpose = ceil (DEFAULT_OPT.remaxpose * (DEFAULT_OPT.maxpose/DEFAULT_OPT.remaxpose/2));
    endif
    
    inopt = tagcat [inopt, defaults];
    
    write ['inopt: {}\n',inopt];

    if not isnull recfilename then
        local rec = cat cat cAtoms ReadAuto recfilename;
        if isnull rec then
            exit twrite ['Cannot read receptor file {}', recfilename];
        endif
    else
        exit twrite ['Use -rec command line argument to provide an input file for RECEPTOR'];
    endif
    
    // perform some house cleaning
//     oDestroy (Residues [] | rName Residues[] == 'EOH');
//     oDestroy (Residues [] | rName Residues[] == 'GOL');
//     oDestroy (Residues [] | rName Residues[] == 'DMS');
//     oDestroy (Residues [] | rName Residues[] == 'SO4');
    rec = rec | oValid rec;
    
    local lig, ligResidue, ligfext;
    if not isnull ligfilename then
        lig = cat cat cAtoms ReadAuto ligfilename;
        ligResidue = aResidue first lig;
        ligfext = fext ligfilename;
        oReparent [diff [lig, first lig], ligResidue];  // MOE appears to need all lignad atoms in a single residue
        if isnull lig then
            exit twrite ['Cannot read receptor file {}', ligfilename];
        endif
    elseif length uniq aResidue _Atoms '$$ligand' == 1 then
        lig = _Atoms '$$ligand';
        ligResidue = aResidue first lig;
        ligfilename = rName ligResidue;
        ligfext = 'mol2';       // when no file is provided for the ligand we will default to writing out a mol2
        write ['WARNING: Using Ligand {} found in {}. Use -lig command line argument to provide an input file for LIGAND\n', rName ligResidue, recfilename];
    elseif length uniq aResidue _Atoms '$$ligand' > 1 then
        exit twrite ['{} Ligands found in {}. Use -lig command line argument to provide an input file for LIGAND\n', length uniq aResidue _Atoms '$$ligand', recfilename];
    else
        exit twrite ['No Ligand found in {}. Use -lig command line argument to provide an input file for LIGAND\n', recfilename];
    endif

    if isnull outf then
        outf = twrite ['{}_dock.mdb',fbase ftail ligfilename];
    else
        outf = twrite ['{}.mdb',fbase outf];
    endif;
        
    // Need the UID, etc of the ligand read in so the write process can rename back (this circumvents the SDF problem which effectively "washes" out these terms).
    local ligChain = rChain ligResidue;
    local ligID;
    ligID.rINS = rINS ligResidue;
    ligID.rName = rName ligResidue;
    ligID.rNumber = rNumber ligResidue;
    ligID.rType = rType ligResidue;
    ligID.rUID = rUID ligResidue;
    
    ligID.cName = fext cName ligChain;
    ligID.cGroup = cGroup ligChain;   
    ligID.cNumber = cNumber ligChain;   
    ligID.cTag = cTag ligChain;
    
    // if the user provides a dockmdb then we assume they wish to perform the final translation to qmechanic-readabe output (SDF or MOL2 depending)
    if isnull dockmdb then

        local opt = DockOpt[];
        opt = tagcat [ [maxpose: inopt.maxpose], opt ];
        opt = tagcat [ [remaxpose: inopt.remaxpose], opt ];
        
        if inopt.protonate then
//            Protonate3D [Atoms[],rec,rec,lig,[],[]];    // Only manipulate protonation of the target (the ligand is left as is)
            Protonate3D [Atoms[],rec,rec,[],[],[]];    // protonate both the protein and the ligand
        endif

        if not isnull conffilename then
            local confmdbname = twrite ['{}.mdb',fbase ftail conffilename];
            db_ImportSD [db_Open [ confmdbname,'create' ],conffilename,'mol',
                ['BFIntensity','BFIRank','Energy','Z_L','SumBFIntensity','SumNonbondedIntensity'],
                ['BFIntensity','BFIRank','Energy','Z_L','SumBFIntensity','SumNonbondedIntensity'],
                ['double','int','double','char','double','double']        
            ];
            db_Sort [confmdbname,'BFIRank',1];
            if (db_nEntries confmdbname) > inopt.mtcsconf then
                db_Delete [confmdbname, (db_Entries confmdbname)[igen ((db_nEntries confmdbname)-inopt.mtcsconf)]];
            endif
            db_Sort [confmdbname,'BFIRank',0];
            opt.retainData = not (first db_Fields confmdbname == 'mol');
        endif

        // For older versions of MOE - need to rename BFIRank to mseq so it can be used in MTCS calculation    
        if MOE_VERSION < 2018 then
            db_RenameField [confmdbname,'BFIRank','mseq'];
        endif

        if inopt.inducedfit then
            opt.refine='Induced Fit';
            opt.refine_opt.fixrec='Tether';   
        endif
        
        if inopt.rigidlig then
            opt.refine_opt.rigidlig=1;   
            opt.refine_opt.rigidPlanar=1;   
        endif            
    
        if mtscorees then
            opt = tagcat [ [rescoring: 'MTScoreES dG [QuantumBio]'], opt ];
        endif
        
        pot_Load '$MOE/lib/Amber10EHT.ff';

        // Note that the following is the general potential set up only.
        // Individual stages like refinement may use a modified set up.
        pot_Setup [
            strEnable: 1,
            angEnable: 1,
            stbEnable: 1,
            oopEnable: 1,
            torEnable: 1,
            vdwEnable: 1,
            eleEnable: 1,
            solEnable: 0,
            resEnable: 1,
            strWeight: 1,
            angWeight: 1,
            stbWeight: 1,
            oopWeight: 1,
            torWeight: 1,
            vdwWeight: 1,
            eleWeight: 1,
            solWeight: 1,
            resWeight: 1,
            cutoffEnable: 1,
            cutoffOn: 8,
            cutoffOff: 10,
            eleDist: 2,
            vdwScale14: 0.5,
            vdwBuffer1: 0,
            vdwBuffer2: 0,
            eleScale14: 0.833333,
            eleDielectric: 1,
            eleBuffer: 0,
            solDielectric: 80,
            solDielectricOffset: 0,
            state0: 1,
            state1: 0,
            state2: 1,
            threadCount: 0
        ];
        pot_SetCharges [];

        // Check system to make sure it is ready to roll - and throw error with suggested ways around it
        local sysbool = checkMolecule[];

        if not sysbool then
            write ['\tDouble check molecular input in GUI and run Structure Prep as required.\n'];  
            if not inopt.forceexe then
                write ['\tYou may choose to force the calculation to proceed using -forceexe command line.\n'];
                return[];
            else
                write ['WARNING: You have chosen to -forceexe the calculation to proceed without fixing the problems noted.\n'];
            endif
        else
            write ['Molecular system parameterized.'];
        endif
        
        if inopt.preopt then
            write ['NOTE: RUNNING MM OPT with {}\n', 'Amber10EHT.ff'];
            local tetherWeight = rep [opt.refine_opt.tether, length Atoms[]];
            local moveMask = aAtomicNumber Atoms[] <= 1;
            (tetherWeight | moveMask) = 0;
            MM[gtest:opt.refine_opt.gtest,maxit:opt.refine_opt.maxit, tetherWeight:tetherWeight ];
        else
            write ['NOTE: Skipping MM complex minimization prior to docking (use -preopt to turn ON optimization)\n'];
        endif

        if inopt.delwat then
            write ['NOTE: SOLVENT REMOVED PRIOR TO DOCKING\n'];
            oDestroy uniq cat aResidue _Atoms '$$solvent';
        else
            write ['NOTE: SOLVENT NOT REMOVED PRIOR TO DOCKING\n'];
        endif
        lig = lig | oValid lig;
        rec = rec | oValid rec;
        write ['STARTING SIZE:   {} | {}\n', length rec, length lig];
        lig = cat cat cAtoms (uniq aChain lig);     // address any changes which may have been made to the ligand (protons, etc)
        rec = cat cat cAtoms (uniq aChain rec);     // address any changes which may have been made to receptor (protons, etc)
        write ['ENDING SIZE:     {} | {}\n', length rec, length lig];
        local site = lig;
        
        // Write the _predock versions of any input PDB & mol2 files so that these can be used in qmechanic
        local syskeys = SystemPush rec;
        write ['pro_{}_predock.{}\n', fbase ligfilename, fext recfilename];
        WriteAuto [twrite ['pro_{}_predock.{}', fbase ligfilename, fext recfilename]];
        SystemPop syskeys;

        write ['lig_{}_predock.{}\n', fbase ligfilename, ligfext];
        syskeys = SystemPush lig;
        WriteAuto [twrite ['lig_{}_predock.{}', fbase ligfilename, ligfext]];
        SystemPop syskeys;

        write ['NOTE: RUNNING {} Docking with {} as MOE/Dock Final Scoring Function\n', opt.refine, opt.rescoring];
        if not isnull confmdbname then
            opt = tagcat [ [ligmdbname: confmdbname], opt ];
            DockFile [rec, site, confmdbname, outf, opt];
        
            // For older versions of MOE - need to rename mseq to BFIRank so it can be used in MTCS calculation
            if MOE_VERSION < 2018 then
                db_RenameField [outf,'mseq','BFIRank'];
            endif

        else
            DockAtoms [ rec,  site,  lig, outf, opt];
        endif
        dockmdb = outf;
    endif
    
    db_Sort [dockmdb,'S',0];
    if inopt.inducedfit then
        dockmdb2mol2 [dockmdb,twrite ['{}.{}',fbase ftail outf,inopt.ifformat],ligID,recfilename,inopt];
    else
        db_ExportSD [ dockmdb, twrite ['{}.sdf',fbase outf] ];
        local mdbdata = db_Read [dockmdb,first db_Entries dockmdb];
        fwrite_TriposMOL2 [twrite ['{}.mol2',fbase ftail outf],mol_Create mdbdata.mol];
    endif

    write ['Docking finished in {} seconds & {} CPUseconds.\n', starttime-clock[], startcputime-cpuclock[] ];

endfunction


#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.

 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information,
 including trade secrets, belonging to QuantumBio Inc. and/or its
 affiliates.

 Use, duplication, or disclosure of this source code is strictly
 prohibited without prior written authorization by the management of
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif

#set title   'QuantumBio Analysis Interface'
#set class   'QuantumBio'
#set version '2010.02'
#set main 'qb_PWDAnalysis'

function qb_GetEnvAnal;
function qb_GetCoreEnv;
function qb_GetPoseFields;
function qb_GetRecFields;
function qb_IsModeManyToMany;
function qb_SaveAnalysisData;
function qb_GetChainsByTag;
function pro_Align_Prompt;

const ENGERGIES =
    [
    "E_AB", "E_ABp", "E_ABc", "E_R6", "E_R12", "E_ELE"
    ];
    
global function qb_PWDAnalysis [qmsfilename]

    local plsdata = [], sardata = [], interdata = [], actdata = [], optLV = [];
    local errmess = "";

    //  exe_open child process inherits parent's environment.
    local process_key = exe_open ['moedivconanalysis', '.', [], 1];
    local process_keys = [process_key];
    local status = exe_status process_keys;

    local prios = exe_getpriority process_keys;
    exe_setpriority [process_keys, prios];

    local stdin = exe_stdin process_keys;
    local stdout = exe_stdout process_keys;
    local stderr = exe_stderr process_keys;

    //  Get necessary data from Database
    local qmsdbkey = db_Open [qmsfilename, 'read-write'];
    local [recmol, ligmol, s, coreopts, c] = qb_GetCoreEnv [qmsdbkey];
    local pwdopts = qb_GetEnvAnal qmsdbkey;
    local numpairs = db_nEntries qmsdbkey;

    local recmols = [];
    if qb_IsModeManyToMany [coreopts] then
        local [recfld, rcf] = qb_GetRecFields [];
        recmols = db_ReadColumn [qmsdbkey, recfld];
    else
        recmols = append [recmols, recmol];
    endif
    
    local [ligfld, lcf] = qb_GetPoseFields [];
    local ligmols = db_ReadColumn [qmsdbkey, ligfld]; 

    //  NOTE:  Rscript can handle only one ligand residue - TEST!
    local lm;
    for lm in ligmols loop
        if length lm(2)(MOL_CHAIN_NAME) > 1 then
            db_Close qmsdbkey;
            exe_kill  [process_key, 0];
            exe_kill  process_key;
            exe_close process_keys;
            return "Ligands/poses can have only one chain.";
        elseif lm(2)(MOL_CHAIN_NRES)(1) > 1 then
            db_Close qmsdbkey;
            exe_kill  [process_key, 0];
            exe_kill  process_key;
            exe_close process_keys;
            return "Ligands/poses can have only one residue.";
        endif
    endloop

    local activities = db_ReadColumn [qmsdbkey, pwdopts.expact_hdr]; 
    local energies = ENGERGIES | [pwdopts.sf_e_ab, pwdopts.sf_e_abp,
        pwdopts.sf_e_abc, pwdopts.sf_e_r6, pwdopts.sf_e_r12,
        pwdopts.sf_e_ele];

    local scorepath = fbase qmsfilename;
    scorepath = twrite ['{}.h5', scorepath];
    
    local chainsList;
    local curChain;

    //  Pass the target-ligand pairs, activities and options to 
    //  QuantumBio's DivCon PWD Analysis
    local handshake, success = 0;
    local idx;
    fwrite [stdin, '{c:}\n', 'pwd'];
    fwrite [stdin, '{c:}\n', scorepath];
    fwrite [stdin, '{c:}\n', pwdopts.title];
    fwrite [stdin, '{n:}\n', pwdopts.prune_zero / 100];
    fwrite [stdin, '{n:}\n', pwdopts.prune_sd];
    fwrite [stdin, '{n:}\n', pwdopts.numtopres];
    fwrite [stdin, '{n:}\n', pwdopts.numcomps];
    fwrite [stdin, '{n:}\n', pwdopts.trainingset];
    fwrite [stdin, '{n:}\n', length energies];
    for idx = 1, length energies, 1 loop
        fwrite [stdin, '{c:}\n', energies[idx]];
    endloop

    fwrite [stdin, '{n:}\n', numpairs];
    local sysResidueCount = 0;
    for idx = 1, numpairs, 1 loop
        if qb_IsModeManyToMany [coreopts] then
            fwrite [stdin, '{c:}\n', recmols(idx)(1)(MOL_NAME)];
        else
            fwrite [stdin, '{c:}\n', recmol(1)(MOL_NAME)];
        endif

        fwrite [stdin, '{c:}\n', ligmols(idx)(1)(MOL_NAME)];
        fwrite [stdin, '{n:}\n', activities[idx]];
    endloop

    sysResidueCount = maxE cat cAlignmentPositions Chains [];

    [[handshake]] = fread [stdout, '{n:}\n'];
    local resIdx = 0;
    local rowdata = [];
    local sequence = [];
    local rownames = [];
    local colnames = [];
    local rowvals = [];
    
    sequence = igen sysResidueCount;
    recmol = [];
    for idx = 1, numpairs, 1 loop
        if length recmols === 1 then
            recmol = recmols(1);
        else
            recmol = recmols(idx);
        endif
        rowvals = [];
        colnames = [];
        for resIdx = 1, sysResidueCount, 1 loop
            rowvals(resIdx) = 0;
            colnames(resIdx) = 'GAP';
        endloop
            
        local tablename, numcols, numrows;
        local sequenceNumberForA = [], val, sequenceNumberForB = [], val2, values = [];
        [[numcols]] = fread [stdout, '{n:}'];
        local numcols7th=numcols/7;
        for numcols7th loop
             [[val]] = fread [stdout, '{n:}'];
             sequenceNumberForA = append [sequenceNumberForA, val];
             [[val]] = fread [stdout, '{n:}'];
             sequenceNumberForB = append [sequenceNumberForB, val];
        endloop
        for numcols loop
             [[val]] = fread [stdout, '{n:}'];
             values = append [values, val];
        endloop
        
        if length values > 0 then
    
    // Go through and create a new set based on the new values
//            chainsList = Chains[] | cTag Chains[] == recmol(2)(MOL_CHAIN_TAG)(1);
            chainsList = Chains[] | cTag Chains[] == recmol(1)(MOL_NAME);
            chainsList = recmol;
            chainsList = chainsList | app allfalse apt m_join [cAtoms chainsList, nest oGetCollection 'QB_LIGAND'];
            local residueCount = 0, tmpPos;
            local resPositions = cat cAlignmentPositions chainsList;
            rSetPos [cat oResidues chainsList, cat cAlignmentPositions chainsList];        
            for curChain in chainsList loop
                for tmpPos in cat oResidues curChain loop
                    residueCount = residueCount + 1;
                    rowvals(rPos tmpPos)  = values(residueCount * 7 - 7 + 1);
                    colnames(rPos tmpPos) = twrite ['{}{}', rName tmpPos, rUID tmpPos];   
                endloop
            endloop
            rowdata = append [rowdata, [token ligmols(idx)(1)(MOL_NAME), rowvals, colnames]];
        endif

    endloop

    interdata = [sequence, rowdata];
    
    // @todo: there is currently no way to capture errors.
    success = 1;

    exe_kill  [process_key, 0];
    exe_kill  process_key;
    exe_close process_keys;
    
    //  Always save new data, even if null, to match saved parameters
    //qb_SaveAnalysisData [qmsdbkey, 'pwd', 'pls', plsdata];
    //qb_SaveAnalysisData [qmsdbkey, 'pwd', 'sar', sardata];
    qb_SaveAnalysisData [qmsdbkey, 'pwd', 'inter', interdata];
    //qb_SaveAnalysisData [qmsdbkey, 'pwd', 'act', actdata];
    //qb_SaveAnalysisData [qmsdbkey, 'pwd', 'optlv', optLV];
    db_Close qmsdbkey;

    if success === 0 and isnull errmess then
        errmess = "Unknown error!";
    endif

    return errmess;
endfunction


#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.

 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information,
 including trade secrets, belonging to QuantumBio Inc. and/or its
 affiliates.

 Use, duplication, or disclosure of this source code is strictly
 prohibited without prior written authorization by the management of
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif

#set title   'QuantumBio Analysis Interface'
#set class   'QuantumBio'
#set version '2010.02'
#set main 'qb_PWDAnalysis'

function qb_GetEnvAnal;
function qb_GetCoreEnv;
function qb_GetPoseFields;
function qb_GetRecFields;
function qb_SaveAnalysisData;

const ENGERGIES =
    [
    "E_AB", "E_ABp", "E_ABc", "E_R6", "E_R12", "E_ELE"
    ];

global function qb_PWDAnalysis [qmsfilename]

    local plsdata = [], sardata = [], interdata = [], actdata = [], optLV = [];
    local errmess = "";

    //  exe_open child process inherits parent's environment.
    local process_key = exe_open ['moedivconanalysis', '.', [], 1];
    local process_keys = [process_key];
    local status = exe_status process_keys;

    local prios = exe_getpriority process_keys;
    exe_setpriority [process_keys, prios];

    local stdin = exe_stdin process_keys;
    local stdout = exe_stdout process_keys;
    local stderr = exe_stderr process_keys;

    //  Get necessary data from Database
    local qmsdbkey = db_Open [qmsfilename, 'read-write'];
    local [recmol, lm, s, coreopts, c] = qb_GetCoreEnv [qmsdbkey];
    local pwdopts = qb_GetEnvAnal qmsdbkey;
    local numpairs = db_nEntries qmsdbkey;

    local recmols = [];
    if coreopts === 'Many-to-Many' then
        local [recfld, rcf] = qb_GetRecFields [];
        recmols = db_ReadColumn [qmsdbkey, recfld];
    endif

    local [ligfld, lcf] = qb_GetPoseFields [];
    local ligmols = db_ReadColumn [qmsdbkey, ligfld]; 

    local activities = db_ReadColumn [qmsdbkey, pwdopts.expact_hdr]; 
    local energies = ENGERGIES | [pwdopts.sf_e_ab, pwdopts.sf_e_abp,
        pwdopts.sf_e_abc, pwdopts.sf_e_r6, pwdopts.sf_e_r12,
        pwdopts.sf_e_ele];

    local scorepath = fbase qmsfilename;
    scorepath = twrite ['{}.h5', scorepath];

    //  Pass the target-ligand pairs, activities and options to 
    //  QuantumBio's Divcon PWD Analysis
    local handshake, success = 0;
    local idx;
    fwrite [stdin, '{c:}\n', 'pwd'];
    fwrite [stdin, '{c:}\n', scorepath];
    fwrite [stdin, '{c:}\n', pwdopts.title];
    fwrite [stdin, '{n:}\n', pwdopts.prune_zero / 100];
    fwrite [stdin, '{n:}\n', pwdopts.prune_sd];
    fwrite [stdin, '{n:}\n', pwdopts.numtopres];
    fwrite [stdin, '{n:}\n', pwdopts.numcomps];
    fwrite [stdin, '{n:}\n', pwdopts.trainingset];
    fwrite [stdin, '{n:}\n', length energies];
    for idx = 1, length energies, 1 loop
        fwrite [stdin, '{c:}\n', energies[idx]];
    endloop

    fwrite [stdin, '{n:}\n', numpairs];
    for idx = 1, numpairs, 1 loop
        if coreopts === 'Many-to-Many' then
            fwrite [stdin, '{c:}\n', recmols(idx)(1)(MOL_NAME)];
        else
            fwrite [stdin, '{c:}\n', recmol(1)(MOL_NAME)];
        endif

        fwrite [stdin, '{c:}\n', ligmols(idx)(1)(MOL_NAME)];
        fwrite [stdin, '{n:}\n', activities[idx]];
    endloop

    [[handshake]] = fread [stdout, '{n:}\n'];

write ['Handshake: {}\n', handshake];//DEBUG
write ['Parameters exe_status:  {}\n', exe_status process_keys];//DEBUG

    local return_statement;
    local sleep_time = -1;
    local divconerrmess = "";
    while exe_status process_key loop
        if not MOE_BATCH then
            sleep sleep_time;
        endif

        [[return_statement]] = fread [stdout, '{c:*}'];

        write ['Divcon: {}\n', return_statement];//DEBUG

        if return_statement === "updateanalysis" then
            local title, numtables;

            [[title]] = fread [stdout, '{c:*}'];
            title = token title;
            if neL [title, pwdopts.title] then
                db_Close qmsdbkey;
                exe_kill  [process_key, 0];
                exe_kill  process_key;
                exe_close process_keys;
                return swrite ['Unrecognized title:  {}\nShould be:  {}\n', 
                    title, pwdopts.title];
            endif

            [[optLV]] = fread [stdout, '{n:}'];
            [[numtables]] = fread [stdout, '{n:}'];

            for numtables loop
                local tablename, numcols, numrows;
                local name, colnames = [], rownames = [], rowdata = [];
                [[tablename]] = fread [stdout, '{c:*}'];
                tablename = token tablename;
                if not anytrue (tablename == ['PLSTable', 'ActTable', 
                        'InterMap', 'SARMap']) then
                    db_Close qmsdbkey;
                    exe_kill  [process_key, 0];
                    exe_kill  process_key;
                    exe_close process_keys;
                    return swrite ['Unrecognized table name:  {}\n', tablename];
                endif

                [[numcols]] = fread [stdout, '{n:}'];
                [[numrows]] = fread [stdout, '{n:}'];
print 'Column Names';//DEBUG
                for numcols loop
                    [[name]] = fread [stdout, '{t:}'];
                    colnames = append [colnames, name];
print name;//DEBUG
                endloop
print 'Row Names\n';//DEBUG
                for numrows loop
                    [[name]] = fread [stdout, '{t:}'];
                    rownames = append [rownames, name];
print name;//DEBUG
                endloop

                local ith;
                for ith = 1, numrows, 1 loop
                    local rowvals = [], val;
                    for numcols loop
                        [[val]] = fread [stdout, '{n:}'];
                        rowvals = append [rowvals, val];
                    endloop

                    rowdata = append [rowdata, [rownames(ith), rowvals]];
                endloop

                if tablename === 'PLSTable' then
                    plsdata = [colnames, rowdata];
                elseif tablename === 'ActTable' then
                    actdata = [colnames, rowdata];
                elseif tablename === 'InterMap' then
                    interdata = [colnames, rowdata];
                elseif tablename === 'SARMap' then
                    sardata = [colnames, rowdata];
                endif
            endloop

            success = 1;
            fwrite [stdin, '{c:}\n', 'Ok'];

        elseif return_statement === "error" then
            [[return_statement]] = fread [stdout, '{c:*}'];
            if neL [return_statement, "Analysis done."] then
                divconerrmess = cat [divconerrmess, return_statement];
                [[return_statement]] = fread [stdout, '{c:*}'];
            endif
            while neL [return_statement, "Analysis done."] loop
                divconerrmess = cat [divconerrmess, "\n", return_statement];
                [[return_statement]] = fread [stdout, '{c:*}'];
            endloop;
            fwrite [stdin, '{c:}\n', 'Ok'];
        endif
    endloop

    //  Look for error messages from stderr.
    local [[newerror]] = fread [stderr, '{c:*}'];
    while length newerror > 0 loop
        write ['MOEDivcon: {}\n', newerror];//DEBUG
        errmess = cat [newerror, errmess];
        [[newerror]] = fread [stderr, '{c:*}'];
    endloop

write ['Results exe_status:  {}\n', exe_status process_keys];//DEBUG

    exe_kill  [process_key, 0];
    exe_kill  process_key;
    exe_close process_keys;

    if success === 1 then
        if not isnull plsdata then
            qb_SaveAnalysisData [qmsdbkey, 'pwd', 'pls', plsdata];
        endif

        if not isnull sardata then
            qb_SaveAnalysisData [qmsdbkey, 'pwd', 'sar', sardata];
        endif

        if not isnull interdata then
            qb_SaveAnalysisData [qmsdbkey, 'pwd', 'inter', interdata];
        endif

        if not isnull actdata then
            qb_SaveAnalysisData [qmsdbkey, 'pwd', 'act', actdata];
        endif

        if not isnull optLV then
            qb_SaveAnalysisData [qmsdbkey, 'pwd', 'optlv', optLV];
        endif
    else
        if isnull divconerrmess then divconerrmess = "Unknown error!"; endif
    endif

    db_Close qmsdbkey;

    return errmess;
endfunction


#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2012 QuantumBio Inc. and/or its affiliates.

 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information,
 including trade secrets, belonging to QuantumBio Inc. and/or its
 affiliates.

 Use, duplication, or disclosure of this source code is strictly
 prohibited without prior written authorization by the management of
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif

#set title   'QuantumBio Analysis Interface'
#set class   'QuantumBio'
#set version '2010.02'
#set main 'qb_PWDAnalysis'

function qb_GetEnvAnal;
function qb_GetCoreEnv;
function qb_GetPoseFields;
function qb_GetRecFields;
function qb_IsModeManyToMany;
function qb_SaveAnalysisData;
function qb_GetChainsByTag;
function pro_Align_Prompt;
function qb_GetCoreOpts;

const ENGERGIES =
    [
    "E_AB", "E_ABp", "E_ABc", "E_R6", "E_R12", "E_ELE"
    ];

global function qb_PWDAnalysis [qmsfilename, G_surface]

    local plsdata = [], sardata = [], interdata = [], actdata = [], optLV = [];
    local errmess = "";

    //  exe_open child process inherits parent's environment.
    local process_key = exe_open ['moedivconanalysis', '.', [], 1];
    local process_keys = [process_key];
    local status = exe_status process_keys;

    local prios = exe_getpriority process_keys;
    exe_setpriority [process_keys, prios];

    local stdin = exe_stdin process_keys;
    local stdout = exe_stdout process_keys;
    local stderr = exe_stderr process_keys;

    //  Get necessary data from Database
    local qmsdbkey = db_Open [qmsfilename, 'read-write'];
	local coreopts = qb_GetCoreOpts qmsdbkey;
    local pwdopts = qb_GetEnvAnal qmsdbkey;
    local numpairs = length G_surface.ligmols;

    local recmols = G_surface.recmols;
    local ligmols = G_surface.ligmols;

    //  NOTE:  Rscript can handle only one ligand residue - TEST!
    local lm;
    for lm in G_surface.ligChains loop
        if length cName lm > 1 then
            db_Close qmsdbkey;
            exe_kill  [process_key, 0];
            exe_kill  process_key;
            exe_close process_keys;
            return "Ligands/poses can have only one chain.";
        elseif cResidueCount lm > 1 then
            db_Close qmsdbkey;
            exe_kill  [process_key, 0];
            exe_kill  process_key;
            exe_close process_keys;
            return "Ligands/poses can have only one residue.";
        endif
    endloop

    local activities = db_ReadColumn [qmsdbkey, pwdopts.expact_hdr]; 
    local energies = ENGERGIES | [pwdopts.sf_e_ab, pwdopts.sf_e_abp,
        pwdopts.sf_e_abc, pwdopts.sf_e_r6, pwdopts.sf_e_r12,
        pwdopts.sf_e_ele];

    local scorepath = fbase qmsfilename;
    scorepath = twrite ['{}.h5', scorepath];
    
    local chainsList;
    local curChain;

    //  Pass the target-ligand pairs, activities and options to 
    //  QuantumBio's DivCon PWD Analysis
    local handshake, success = 0;
    local idx;
    fwrite [stdin, '{c:}\n', 'pwd'];
    fwrite [stdin, '{c:}\n', scorepath];
    fwrite [stdin, '{c:}\n', pwdopts.title];
    fwrite [stdin, '{n:}\n', pwdopts.prune_zero / 100];
    fwrite [stdin, '{n:}\n', pwdopts.prune_sd];
    fwrite [stdin, '{n:}\n', pwdopts.numtopres];
    fwrite [stdin, '{n:}\n', pwdopts.numcomps];
    fwrite [stdin, '{n:}\n', pwdopts.trainingset];
    fwrite [stdin, '{n:}\n', length energies];
    for idx = 1, length energies, 1 loop
        fwrite [stdin, '{c:}\n', energies[idx]];
    endloop

    fwrite [stdin, '{n:}\n', numpairs];
    local sysResidueCount = 0;
    for idx = 1, numpairs, 1 loop
        if qb_IsModeManyToMany [coreopts] then
            fwrite [stdin, '{c:}\n', cName G_surface.recChains(idx)];
        else
            fwrite [stdin, '{c:}\n', cName G_surface.recChains(1)];
        endif
        fwrite [stdin, '{c:}\n', cName G_surface.ligChains(idx)];
    endloop

    sysResidueCount = maxE cat cAlignmentPositions Chains [];

    [[handshake]] = fread [stdout, '{n:}\n'];
    local resIdx = 0;
    local rowdata = [];
    local sequence = [];
    local rownames = [];
    local colnames = [];
    local rowvals = [];
    
    sequence = igen sysResidueCount;
    local recChain, ligChain;
    for idx = 1, numpairs, 1 loop
        if length G_surface.recChains === 1 then
			recChain = G_surface.recChains(1);
        else
			recChain = G_surface.recChains(idx);
        endif
        ligChain = G_surface.ligChains(idx);
        rowvals = [];
        colnames = [];
        for resIdx = 1, sysResidueCount, 1 loop
            rowvals(resIdx) = 0;
            colnames(resIdx) = 'GAP';
        endloop
            
        local tablename, numcols, numrows;
        local sequenceNumberForA = [], val, sequenceNumberForB = [], val2, values = [];
        [[numcols]] = fread [stdout, '{n:}\n'];
        local numcols7th=numcols/7;
        for numcols7th loop
             [[val]] = fread [stdout, '{n:}\n'];
             sequenceNumberForA = append [sequenceNumberForA, val];
             [[val]] = fread [stdout, '{n:}\n'];
             sequenceNumberForB = append [sequenceNumberForB, val];
        endloop
        for numcols loop
             [[val]] = fread [stdout, '{n:}\n'];
             values = append [values, val];
        endloop
        
        if length values > 0 then
    
    // Go through and create a new set based on the new values
            chainsList = recChain;
            if length chainsList then
                chainsList = chainsList | app allfalse apt m_join [cAtoms chainsList, nest oGetCollection 'QB_LIGAND'];
            endif
            local residueCount = 0, tmpPos;
            rSetPos [cat oResidues chainsList, cat cAlignmentPositions chainsList];        
            for curChain in chainsList loop
                for tmpPos in cat oResidues curChain loop
                    residueCount = residueCount + 1;
                    rowvals(rPos tmpPos)  = values(residueCount * 7 - 7 + 1);
                    colnames(rPos tmpPos) = twrite ['{}{}', rName tmpPos, rUID tmpPos];   
                endloop
            endloop
            rowdata = append [rowdata, [token cName ligChain, rowvals, colnames]];
        endif

    endloop

    interdata = [sequence, rowdata];
    // @todo: there is currently no way to capture errors.
    success = 1;

    exe_kill  [process_key, 0];
    exe_kill  process_key;
    exe_close process_keys;
    
    //  Always save new data, even if null, to match saved parameters
    //qb_SaveAnalysisData [qmsdbkey, 'pwd', 'pls', plsdata];
    //qb_SaveAnalysisData [qmsdbkey, 'pwd', 'sar', sardata];
    qb_SaveAnalysisData [qmsdbkey, 'pwd', 'inter', interdata];
    //qb_SaveAnalysisData [qmsdbkey, 'pwd', 'act', actdata];
    //qb_SaveAnalysisData [qmsdbkey, 'pwd', 'optlv', optLV];
    db_Close qmsdbkey;

    if success === 0 and isnull errmess then
        errmess = "Unknown error!";
    endif

    return errmess;
endfunction


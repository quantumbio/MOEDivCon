#set main 'qm_optdivcon_Run'

const BOHR_TO_ANG = 0.529177249;
const ANG_TO_BOHR = inv BOHR_TO_ANG;
const AU_TO_KCALMOL = 627.5095;
const KCALMOL_TO_AU = inv AU_TO_KCALMOL;
const AU_TO_EV = 27.211396;
const EV_TO_AU = inv AU_TO_EV;


local function divcon_IsAvailable []
    local g_dir = token getenv 'CHEMIXDIR';
    local g_exec = token 'moedivcongeomopt';
//    if g_dir == '' then g_dir = token GetRC ['gaussian.dir', '']; endif
//    if g_exec == '' then g_exec = token GetRC ['gaussian.exec', '']; endif
    if g_dir == '' or g_exec == '' then return 0; endif
    if ftype tok_cat ['./bin/', g_exec] == '' then return 0; endif
    return 1;
endfunction


global function divcon_Run param

local [cfg, cmd, act] = param;

local a = Atoms[];
local mol = mol_Extract Chains[];

if tok_length cfg.jobtitle == 0 then
    Warning 'Empty job title.';
    return cfg;
endif

//@todo the env and master need to be defined
local process_key = exe_open ['moedivcongeomopt', '.', [], 1];
local process_keys = [process_key];
local status	= exe_status   process_keys;

local prios	= exe_getpriority process_keys;
exe_setpriority [ process_keys, prios ];

local stdin    = exe_stdin process_keys;
local stdout   = exe_stdout process_keys;
local stderr   = exe_stderr process_keys;

write ['garbage {c:}\n', getenv 'LD_LIBRARY_PATH'];
//pass over options
fwrite [stdin, '{t:}\n', cfg.jobtitle];
fwrite [stdin, '{t:}\n', cfg.basisname];
local solvent_model = cfg.solvent_model;
if length solvent_model ==0 then
	fwrite [stdin, '{n:}\n', 0];
else
	fwrite [stdin, '{n:}\n', 1];
	fwrite [stdin, '{c:}\n', solvent_model(1)];
	fwrite [stdin, '{n:}\n', solvent_model(2)];
endif
fwrite [stdin, '{n:}\n', act.optimize];
fwrite [stdin, '{n:}\n', act.vibfreq];

print act;
//pass the backbone to QuantumBio's divcon qm geometry optimizer

fwrite [stdin, '{n:}\n', mol_cCount mol];
local count = 1;
local residueIndex = 1;
local atomIndex = 0;
for  mol_cCount mol loop
	local chain = mol(2);
	print count;
        local residueCount = chain(MOL_CHAIN_NRES)(count);
	print residueCount;
	fwrite [stdin, '{n:}\n', residueCount];
	for  residueCount loop
		//print mol(3)(MOL_RES_NATOMS)(residueIndex);
        	local residueAtomCount = mol(3)(MOL_RES_NATOMS)(residueIndex);
        	fwrite [stdin, '{c:} {n:} {n:}\n', mol(3)(MOL_RES_NAME)(residueIndex), mol(3)(MOL_RES_UID)(residueIndex), residueAtomCount];
                //print  mol_aCount chain(residueIndex);
		residueIndex=residueIndex+1;
		for  residueAtomCount loop
                atomIndex = atomIndex + 1;
		//print mol(4)(MOL_ATOM_X)(atomIndex);
        	fwrite [stdin, '{c:} {c:} {n:.5f}\n',  mol(4)(MOL_ATOM_NAME)(atomIndex), mol(4)(MOL_ATOM_EL)(atomIndex), mol(4)(MOL_ATOM_CHARGE)(atomIndex)];
        	fwrite [stdin, '{n:.5f} {n:.5f} {n:.5f}\n', mol(4)(MOL_ATOM_X)(atomIndex), mol(4)(MOL_ATOM_Y)(atomIndex), mol(4)(MOL_ATOM_Z)(atomIndex)];
		endloop
	endloop
	count = count + 1;
endloop

local retValue;
local endit;
[retValue] = fread [stdout, '{n:}'];

print "returned from moestdiodivcon init ";
print retValue;

//divcon([mol_aCount mol, aPos a]);


    local sleep_time = 0.05, sleep_inc = 0.05;
    local return_statement;
    while exe_status process_key loop
	sleep sleep_time;
	sleep_time = min [1, sleep_time + sleep_inc];

        [[return_statement]] = fread [stdout, '{c:*}'];
        if cfg.verbose then print return_statement; endif;
        if return_statement === "updatecoordinates" then
		local totalEnergy;
		local heatOfFormation;
 		[[totalEnergy, heatOfFormation]] = fread [stdout, '{n:}{n:}'];
        	print [totalEnergy, heatOfFormation];
		cfg.energy =  KCALMOL_TO_AU * totalEnergy;
		cfg.heat_of_formation = heatOfFormation;
		local atomCount = atomIndex;
        	print atomCount;
		atomIndex=1;
     	        local atoms = [[], [], [], [], []];
     	        local mullikens = [];
     	        local cm1s = [];
     	        local cm2s = [];
                for atomCount loop
			local elementIndex;
			local x;
			local y;
			local z;
			local mullikenCharge;
			local cm1Charge;
			local cm2Charge;
                	[[elementIndex, x, y, z, mullikenCharge, cm1Charge, cm2Charge]]= fread [stdout, '{n:}{n:}{n:}{n:}{n:}{n:}{n:}'];
                	atoms = apt cat [atoms, cat [
		   	'X', elementIndex, ANG_TO_BOHR * x, ANG_TO_BOHR * y, ANG_TO_BOHR * z]];
			mullikens = cat [ mullikens, [mullikenCharge]];
			cm1s = cat [ cm1s, [cm1Charge]];
			cm2s = cat [ cm2s, [cm2Charge]];
                	atomIndex = atomIndex + 1;
                endloop
//	    atoms[[3,4,5]] = atoms[[3,4,5]] * ANG_TO_BOHR;
	        atoms(1) = ELEMENT_SYM[atoms(2)];
	        cfg.atoms = atoms;
	        cfg.natoms = l_length atoms;
		cfg.charge_model.Mulliken = mullikens;
		cfg.charge_model.CM1 = cm1s;
		cfg.charge_model.CM2 = cm2s;
		local eigenCount;
 		[eigenCount] = fread [stdout, '{n:}'];
		print ['eigenCount', eigenCount];
		cfg.nao = eigenCount ;
		cfg.eigenvalues = [];
		cfg.eigenvectors = [];
		cfg.density_matrix = [];
		cfg.overlap_integrals = [];
		cfg.slater_orbitals = [];
		local eigval = rep [rep [0, cfg.nao ], 2];
		local part = 1;
                for eigenCount loop
			local eigenIndex;
			local eigenValue;
			local eigenVectorSq;
                	[[eigenIndex, eigenValue, eigenVectorSq]]= fread [stdout, '{n:}{n:}{n:}'];
		    eigval(part) = put [
		    	eigval(part), 
			eigenIndex, 
			EV_TO_AU * eigenValue
		    ];
		    if cfg.verbose then print [eigenIndex, eigenValue, eigenVectorSq]; endif;
                endloop
		cfg.eigenvalues = eigval(part);
 		[eigenCount] = fread [stdout, '{n:}'];
		//cfg.nao = eigenCount ;
		print ['eigenCount', eigenCount];
		local i = 1;
		local j = 1;
	        local eigvec = rep [rep [rep [0,eigenCount], eigenCount], 2];
	        //local eigvec = rep [rep [0,eigenCount], eigenCount];
	        local eigmask = rep [0, cfg.nao];
                for eigenCount loop
			local eigenVector;
                	[[eigenIndex]]= fread [stdout, '{n:}'];
		    for i = 1, eigenCount loop
                	[[eigenVector]]= fread [stdout, '{n:}'];
			// !!! switch to column-based interpretation
			//eigvec(part)(i) = put [eigvec(part)(i), eigenIndex, eigenVector];
			eigvec(part)(j)(i) = EV_TO_AU * eigenVector;
		    endloop
		    j = j + 1;
                endloop
		print [cfg.nao, 'eigvec', length eigvec, length eigvec(1)];
		//cfg.eigenvectors = 0.5 * add app tr eigvec;
		cfg.eigenvectors = eigvec(part);
		//print ['eigvec', cfg.eigenvectors];
		local densityCount;
 		[densityCount] = fread [stdout, '{n:}'];
		print ['densityCount', densityCount];
	        local density = rep [rep [rep [0,densityCount], densityCount], 2];
		i = 1;
		j = 1;
                for densityCount loop
			local p;
			local pIndex;
                	[[pIndex]]= fread [stdout, '{n:}'];
		    for i = 1, densityCount loop
                	[[p]]= fread [stdout, '{n:}'];
			// !!! switch to column-based interpretation
			density(part)(j)(i) = EV_TO_AU * p;
		    endloop
		    j = j + 1;
                endloop
		cfg.density_matrix = density(part);
		//print ['density', cfg.density_matrix];
	        local overlap = rep [rep [rep [0,densityCount], densityCount], 2];
		i = 1;
		j = 1;
                for densityCount loop
			local op;
			local opIndex;
                	[[opIndex]]= fread [stdout, '{n:}'];
		    for i = 1, densityCount loop
                	[[op]]= fread [stdout, '{n:}'];
			// !!! switch to column-based interpretation
			overlap(part)(j)(i) = EV_TO_AU * op;
		    endloop
		    j = j + 1;
                endloop
		cfg.overlap_integrals = overlap(part);
 		print ['overlap'];
               for densityCount loop
			local atidx;
			local atno;
			local mx;
			local my;
			local mz;
			local mr;
			local zeta;
			local N;
                	[[atidx, atno, x, y, z, mx, my, mz, mr, zeta, N]]= fread [stdout, '{n:}{n:}{n:}{n:}{n:}{n:}{n:}{n:}{n:}{n:}{n:}'];
			cfg.slater_orbitals = cat [cfg.slater_orbitals , [atidx, atno, x, y, z, mx, my, mz, mr, zeta, N]];
                endloop
		//cfg.slater_orbitals = app tr cfg.slater_orbitals;
 		print ['cfg.slater_orbitals', cfg.slater_orbitals];
        	fwrite [stdin, '{c:}\n', 'Ok'];
        endif
    endloop
print "killing moestdiodivcon ";
//local exit_codes	= exe_exitcode process_keys;
exe_kill  [process_key, 0];
exe_kill  process_key;
exe_close process_keys;
return cfg;
endfunction

// ---------------------------- External interface ----------------------------

global function scf_EngineDivcon param
    if isnull param then
    	return [
	    wavefn: 	1,
	    geomopt: 	1,
	    molorb: 	1,
	    eldens: 	1,
    	    basis:  	['RM1', 'PM6', 'AM1', 'PM3', 'MNDO', 'MNDO/d'],
	    basfunc: 	'Slater',
	    bascoord: 	'Angstrom',
    	    uhf:    	0,
	    dft:    	0,
	    vibfreq: 	1,
//	    dft_types:  ['B3LYP', 'LSDA', 'B3PW91'],
	    keywords: 	0,
	    chgmodels:	['Mulliken', 'CM1', 'CM2', 'BCC'],
	    solvmodels: ['PB'],
	    available:	divcon_IsAvailable []
	];
    endif

    local [cfg, cmd, act] = param;
        
	// preconfiguration
	
    cfg.nelectrons = add cfg.atoms(2) - cfg.charge;
    cfg.input_notes = [];
    cfg.output_notes = [];
    cfg.error_notes = [];

    if isnull cfg.filename_input then
//    	cfg.filename_input = tok_cat [TMP, '/gaussian.inp']; 
    endif
    if isnull cfg.filename_output then
//    	cfg.filename_output = tok_cat [TMP, '/gaussian.out']; 
    endif

    if cmd == 'pre' then return cfg; endif // nothing more to do
    if cmd == 'inp' then
  //  	gaussian_fwrite_Input [cfg, cmd, act];
	return cfg;
    endif
    if cmd == 'out' then
//    	return gaussian_fread_Output cfg;
	return cfg;
    endif

    	// write, run, parse
	
//    cfg.input_notes = gaussian_fwrite_Input [cfg, cmd, act];
    cfg = divcon_Run param;
//    cfg = gaussian_fread_Output cfg;

    return cfg;
endfunction

#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
	
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

//    nmrpanel.svl    User-interface entrypoint to NMRScore calculations

#set title   'QuantumBio NMRScore Panel'
#set class   'QuantumBio'
#set version '2010.02'
#set main    'qb_NMRScoreSetupPanel'

function qb_CoreHandler;
function qb_CutReceptor;
function qb_GetCoreEnv;
function qb_GetCorePanel;
function qb_GetDefaultsCore;
function qb_GetDefaultsStatus;
function qb_GetEnvApp;
function qb_GetEnvTag;
function qb_GetLigandAtomNames;
function qb_GetWhich;
function qb_InitCorePanel;
function qb_LoadCoreScoreDB;
function qb_SaveDivconStatus;
function qb_SetUpScoreDB;
function qb_TagCoreVals;
function qb_UpdateCorePanel;
function qb_VerifyCharges;

function qb_NMRScore;
function qb_NMRScoreBatch;

const NMR_NUM_FIELDS =
    [
    'NMRScore'
    ];


/*  NOTE:  If you change the Option lists here, you need to update the
 *         Keys in nmrinterface.svl.
 */

const NMRSCORE_OPT_DEFAULTS =
    [
    ['guess',        0             ],  // NMRScore defaults start here
    ['opt',          1             ],
    ['cut',          0             ],
    ['radius',       2.5           ]
    ];


const RUN_MODES =
    [
    'One-to-One',
    'One-to-Many',
    'Many-to-Many'
    ];

const GEOM_OPTS =
    [
    'none',
    'H only',
    'H and hetero',
    'all atoms'
    ];

const HEADER = 
    [
    name: 'panel', 
    title: 'NMRScore',
    windowName: 'NMRScorePanel',
    text: ['Run', 'Save', 'Load', 'Close'],
    onTrigger: ['validate', 'validate', 'return', 'return'],
    bubbleHelp: ['Execute NMRScore from MOE Window.',
        'Save run parameters in database\n'
        'for later execution on cluster.', 
        'Load run parameters from a NMRScore database.', 
        '']
    ];

const PANEL =
    [
    Hbox :
        [
        extendH: 1,
        Checkbox :
            [
            name: 'cut', text: 'Cut Receptor?',
            onTrigger: 'return',
            bubbleHelp:
                'Cut the receptor at the specified radius.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 0, margin:1
            ],
        Text :
            [
            name: 'radius', len: 7, extendH: 1, title: 'Radius:',
            type: 'real', allowBlank: 0,
            shortcut: ['2.5', '3.0', '3.5', '4.0', '4.5', '5.0'],
            bubbleHelp: 'Cut radius in angstrums.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 0, margin:1
            ],
        Button :
            [
            name: 'showcut', text: 'Show Cut',
            bubbleHelp: 'Perform cut and show in MOE Window.'
            ],
        Button :
            [
            name: 'original', text: 'Original',
            bubbleHelp: 'Revert back to original receptor/ligand complex.'
            ]
        ],

    Hbox :
        [
        Button :
            [
            name: 'experimental', text: 'Enter/Edit Experimental Data', 
            extendH: 1,
            bubbleHelp:
                'Open dialog to enter the data\n'
                'for the free and bound ligand.'
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        extendH: 1,
        Option :
            [
            name: 'opt', title: 'Geometry Optimization:', 
            text: GEOM_OPTS, type: 'int', minWidth: 11, extendH: 1,
            bubbleHelp:
            'Geometry optimization will often improve chances\n'
            'of convergence:\n'
            ' * none:  no optimization step is performed.\n'
            ' * H only:  all proton positions in the complex are\n'
            '     quantum mechanically optimized.  Heavy atoms\n'
            '     remain unchanged.\n'
            ' * H and hetero:  all non-C atom positions in the complex\n'
            '     are quantum mechanically optimized. NOTE: the ligand\n'
            '     pose should be considered a new pose.\n'
            ' * All atoms:  all atom positions in the complex are\n'
            '     quantum mechanically optimized. NOTE:  the ligand\n'
            '     pose should be considered a new pose.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 1, margin:1
            ],
        Checkbox :
            [
            name: 'guess', text: 'Guess',
            bubbleHelp:
                'Perform Single Point calculation to\n'
                'initialize density matrix.\n'
                'Warning: may not always\n'
                'improve convergence.'
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1]
    ];

//  Local Functions

/****************************************************************************
 *                          LoadDB
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
local function LoadDB [dbpath]

    local [dbkey, recset, ligand, status, coreopts, complex, mess] = 
        qb_LoadCoreScoreDB [dbpath, 'nmrscore'];
    if dbkey === 0 and status === [] and coreopts === [] then
        Warning mess;
        exit [];
    endif

    local nrmsopts = qb_GetEnvApp [dbkey];
    nrmsopts = tagcat [nrmsopts, tag tr NMRSCORE_OPT_DEFAULTS];

    return [dbkey, recset, ligand, status, coreopts, nrmsopts, complex];
endfunction

function qb_GetNMRSEnv;
function qb_SaveNMRScore;

/****************************************************************************
 *                          RunCalc
 *
 *  Run the One-to-One scoring from the MOE Window.
 *
 ****************************************************************************/
function RunCalc [dbkey, moeatomnames]
    local msgkey = Message [0, 'NMRScore is running ...'];
    sleep -1;    // Allow parent to close input window.

    local rowkey = first db_Entries [dbkey];
    local [recset, ligand, status, coreopts, nmrsopts, c]
        = qb_GetNMRSEnv [dbkey];

    local workdir;
    if coreopts.pwd === 1 then
        workdir = getenv 'PWD';
    else
        workdir = fabsname coreopts.workdir;
    endif

    coreopts.workdir = workdir;
    write ['Work Dir:  {}\n', workdir];  //DEBUG

    local [results, errmess] = qb_NMRScore [recset, ligand, coreopts, nmrsopts];


    if results === [] then
        if errmess === [] or errmess === '' then
            qb_SaveDivconStatus [dbkey, rowkey, "Error:  Unknown error!\n"];
            write ['NMRScore Error:  Unknown error!\n'];
        else
            qb_SaveDivconStatus [dbkey, rowkey, 
                swrite ['Error:  {}\n', errmess]];
            write ['NMRScore Error:  {}\n', errmess];
        endif
    else
        print results;  //DEBUG
        local atomindices = app first results;
        local atomnames = get [ligand(4)(MOL_ATOM_NAME), atomindices];
        if not alltrue eqE [atomnames, moeatomnames] then
            Warning twrite ['Atom names are inconsistent:\nMOE: {v}\n'
                'Divcon: {v}\n', moeatomnames, atomnames];
        else
            local cspvalues = app second results;
            qb_SaveNMRScore [dbkey, rowkey, 9.99, tag [atomnames, cspvalues]];
            local sucmess = cat [ "Success\n", errmess];
            if not isnull errmess then
                sucmess = cat [sucmess, errmess, "\n"];
            endif
            qb_SaveDivconStatus [dbkey, rowkey, sucmess];

        endif
    endif

    Message [msgkey, 'NMRScore is done.'];

    return;
endfunction

//  Global Functions

/****************************************************************************
 *                          qb_GetNMRSEnv
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
local function qb_GetNMRSEnv [dbkey]

    local [recset, ligand, status, coreopts, complex] = qb_GetCoreEnv [dbkey];
    local nmrsopts = qb_GetEnvApp [dbkey];
    nmrsopts = tagcat [nmrsopts, tag tr NMRSCORE_OPT_DEFAULTS];

    return [recset, ligand, status, coreopts, nmrsopts, complex];
endfunction

/****************************************************************************
 *                          qb_SaveNMRScore
 *
 *  Save just the score data in the NMRScore database.
 *
 ****************************************************************************/
global function qb_SaveNMRScore [mdbkey, rowkey, scoredata, atomdata]
    scoredata = cat [tag [NMR_NUM_FIELDS, scoredata], atomdata];
    db_Write [mdbkey, rowkey, scoredata];

endfunction

/****************************************************************************
 *
 *                          qb_NMRScoreSetupPanel
 *
 ****************************************************************************/
global function qb_NMRScoreSetupPanel []

    static status;                     //  Shared with child tasks.
    static nmrskey;
    static complexmol;
    static atomnames;

    if MOE_BATCH then return; endif
    if WindowShow ['NMRScorePanel', 1] then return; endif

    local coreopts = [], nmrsopts = [], browsetasks = []; 
    status = qb_GetDefaultsStatus [];
    local coredflts = qb_GetDefaultsCore [];
    local appdflts = tag tr NMRSCORE_OPT_DEFAULTS;
    coredflts = tagpoke [coredflts, 'scoredb', 'nmrscore.mdb'];
    nmrskey = 0;
    complexmol = mol_Extract Chains [];
    atomnames = [];

    local wkey = WindowCreate cat [HEADER, qb_GetCorePanel [], PANEL];
    status = qb_InitCorePanel [wkey, status, coredflts];
    WindowSetData [wkey, appdflts];
    WindowSetAttr [wkey, [
        radius: [sensitive: 0, allowBlank: 1],
        showcut: [sensitive: 0], original: [sensitive: 0],
        guess: [sensitive: 1], opt: [sensitive:1]]];
    WindowShow [wkey, 1];

    loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'cut' then
            if vals.cut === 0 then
                WindowSetAttr [wkey, [radius: [sensitive: 0, allowBlank: 1],
                    showcut: [sensitive: 0]]];
            else
                WindowSetAttr [wkey, [radius: [sensitive: 1, allowBlank: 0],
                    showcut: [sensitive: 1]]];
            endif

        elseif trig === 'showcut' then
            if second task_fork [statics:'share',
                    master: 'parent'] === 'child' then
                task_prio 0;

                local [cutrecmol, cutligmol, crerrmess] = qb_CutReceptor [0, 
                    vals.radius];
                if cutrecmol === [] or cutligmol === [] then
                    Warning crerrmess;
                    exit [];
                endif
                WindowSetAttr [wkey, [showcut: [sensitive: 0],
                    original: [sensitive: 1]]];
	            Close [force:1];
                local cutlig = mol_Create cutligmol;
                local cutligatoms = cat oAtoms cutlig;
                oSetCollection ['QB_LIGAND', cutligatoms];
                aSetNucleusLook [cutligatoms, 'small-sphere'];
                aSetBondLook [cutligatoms, 'cylinder'];
                mol_Create cutrecmol;
	            View [];
                exit [];
            endif

        elseif trig === 'original' then
            if second task_fork [statics:'share',
                    master: 'parent'] === 'child' then
                task_prio 0;

                if complexmol === [] then
                    Warning 'No original complex.';
                    exit [];
                endif
                WindowSetAttr [wkey, [showcut: [sensitive: 1],
                    original: [sensitive: 0]]];
	            Close [force:1];
                mol_Create complexmol;
	            View [];
                exit [];
            endif

        elseif trig === 'experimental' then
            if second task_fork [statics:'share',
                    master: 'parent'] === 'child' then

                if complexmol === [] then
                    Warning 'No original complex.';
                    exit [];
                endif
                atomnames = qb_GetLigandAtomNames ['H'];
write ['{v}', atomnames];//DEBUG
                Warning 'Pop up experimental window.';
                exit [];
            endif

       elseif trig === 'panel' then
            if vals.panel === 'Close' then 
                break;

            elseif vals.panel === 'Load' then 
                if second task_fork [statics:'share',
                        master: 'parent'] === 'child' then
                    task_prio 0;

                    local dbpath = FilePrompt [title: 'Load Database', 
                        filter: '*.mdb', allowEmptyList: 0];
                    if not isnull dbpath then
                        write ['Load database: {}\n', dbpath]; //DEBUG
                        local [ldkey, ldcutrec, ldlig, ldsts, ldcoreopts,
                            ldnmrsopts, ldcomplex, ldmess] = LoadDB [dbpath];

    	                Close [force:1];
                        if neL [ldcutrec, []] and neL [ldlig, []] then
                            local ldligmol = mol_Create ldlig;
                            local ldligatoms = cat oAtoms ldligmol;
                            oSetCollection ['QB_LIGAND', ldligatoms];
                            aSetNucleusLook [ldligatoms, 'small-sphere'];
                            aSetBondLook [ldligatoms, 'cylinder'];
                            mol_Create ldcutrec;
        	                View [];
                        endif

                        status = qb_UpdateCorePanel [wkey, ldsts, ldcoreopts];
                        complexmol = ldcomplex;
                        nmrskey = ldkey;
                        dbv_Open db_Filename nmrskey;
                        db_Close ldkey;
                        WindowSetData [wkey, ldnmrsopts];
                    endif

                exit [];
            endif

            elseif vals.panel === 'Run' then
                status = qb_VerifyCharges [wkey, status, vals];
                if not status.verifychg then continue; endif

                if second task_fork [statics:'share',
                        prio:3, idle:0] === 'child' then
                    coreopts = qb_TagCoreVals [vals];
                    nmrsopts = tag [first tr NMRSCORE_OPT_DEFAULTS, [
                        vals.guess, vals.opt, vals.cut, vals.radius]];

                    atomnames = qb_GetLigandAtomNames ['H'];
                    nmrskey = qb_SetUpScoreDB [status, coreopts, nmrsopts, 
                        complexmol, cat [NMR_NUM_FIELDS, atomnames],
                        'nmrscore'];
                    RunCalc [nmrskey, atomnames];
                    dbv_Open db_Filename nmrskey;
                    db_Close nmrskey;
                    exit [];
                else
                    break;
                endif

            elseif vals.panel === 'Save' then
                status = qb_VerifyCharges [wkey, status, vals];
                if not status.verifychg then continue; endif

                if second task_fork [statics:'share'] === 'child' then
                    task_prio 0;

                    atomnames = qb_GetLigandAtomNames ['H'];
                    coreopts = qb_TagCoreVals [vals];
                    nmrsopts = tag [first tr NMRSCORE_OPT_DEFAULTS, [
                        vals.guess, vals.opt, vals.cut, vals.radius]];
                    nmrskey = qb_SetUpScoreDB [status, coreopts, nmrsopts, 
                        complexmol, cat [NMR_NUM_FIELDS, atomnames],
                        'nmrscore'];
                    dbv_Open db_Filename nmrskey;
                    db_Close nmrskey;
                    exit [];
                else
                    break;
                endif
            endif
        else
           [status, browsetasks] = qb_CoreHandler [wkey, trig, status, vals,
               browsetasks];
        endif
    endloop

    task_kill browsetasks;
    WindowDestroy wkey;

endfunction

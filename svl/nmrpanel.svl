#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2010 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif      

//    nmrpanel.svl    User-interface entrypoint to NMRScore calculations

#set title   'QuantumBio NMRScore Panel'
#set class   'QuantumBio'
#set version '2010.02'
#set main    'qb_NMRScoreSetupPanel'

function qb_AtomsToMols;
function qb_CoreHandler;
function qb_CutReceptor;
function qb_GetAnalysisData;
function qb_GetCoreEnv;
function qb_GetCorePanel;
function qb_GetDefaultsCore;
function qb_GetDefaultsStatus;
function qb_GetEnvApp;
function qb_GetEnvTag;
function qb_GetElemIndices;
function qb_GetLigandAtoms;
function qb_GetPoses;
function qb_GetWhich;
function qb_InitCorePanel;
function qb_IsModeOneToMany;
function qb_LoadCoreScoreDB;
function qb_SaveAnalysisData;
function qb_SaveDivconStatus;
function qb_SetModeStatus;
function qb_SetUpScoreDB;
function qb_TagCoreVals;
function qb_UpdateCharge;
function qb_UpdateCorePanel;
function qb_VerifyDivcon;

function qb_NMRScore;
function qb_NMRScoreBatch;

const NMR_NUM_FIELDS =
    [
    'NMRScore'
    ];

/*  NOTE:  If you change the Option lists here, you need to update the
 *         Keys in nmrinterface.svl.
 */

const NMRSCORE_OPT_DEFAULTS =
    [
    ['elemH',        1             ],
    ['elemC',        0             ],
    ['elemO',        0             ],
    ['elemN',        0             ],
    ['elemF',        0             ],
    ['guess',        0             ],
    ['opt',          1             ],
    ['cut',          0             ],
    ['radius',       5.0           ],
    ['allposes',     0             ]
    ];

const GEOM_OPTS =
    [
    'none',
    'H only',
    'H and hetero',
    'all atoms'
    ];

const ELEM_TYPES =
    [
    'H',
    'C',
    'O',
    'N',
    'F'
    ];

const HEADER = 
    [
    name: 'panel', 
    title: 'NMRScore',
    windowName: 'NMRScorePanel',
    text: ['Run', 'Save', 'Load', 'Close'],
    onTrigger: ['validate', 'validate', 'return', 'return'],
    bubbleHelp: ['Execute NMRScore from MOE Window.',
        'Save run parameters in database\n'
        'for later execution on cluster.', 
        'Load run parameters from a NMRScore database.', 
        '']
    ];

const PANEL =
    [
    Hbox :
        [
        extendH: 1,
        Checkbox :
            [
            name: 'cut', text: 'Cut?', title: 'Receptor:',
            onTrigger: 'return',
            bubbleHelp:
                'Cut the receptor at the specified radius.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 0, margin:1
            ],
        Text :
            [
            name: 'radius', len: 7, extendH: 1, title: 'Radius:',
            type: 'real', allowBlank: 0,
            shortcut: ['2.5', '5.0', '7.5', '10.0'],
            bubbleHelp: 'Cut radius in angstrums.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 0, margin:1
            ],
        Button :
            [
            name: 'showcut', text: 'Apply',
            bubbleHelp: 'Perform cut and show in MOE Window.'
            ],
        Button :
            [
            name: 'original', text: 'Original',
            bubbleHelp: 'Revert back to original receptor/ligand complex.'
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        Checkbox :
            [
            name: 'allposes', text: 'Show all poses?', title: 'Poses:',
            onTrigger: 'return',
            bubbleHelp:
                'Load all of the poses from the database\n'
                'and show them in the MOE Window.'
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        Checkbox :
            [
            name: 'elemH', text: 'H', title: 'Chemical Shift Atoms:',
            onTrigger: 'return',
            bubbleHelp:
                ''
            ],
        Checkbox :
            [
            name: 'elemC', text: 'C', onTrigger: 'return',
            bubbleHelp:
                ''
            ],
        Checkbox :
            [
            name: 'elemO', text: 'O', onTrigger: 'return',
            bubbleHelp:
                ''
            ],
        Checkbox :
            [
            name: 'elemN', text: 'N', onTrigger: 'return',
            bubbleHelp:
                ''
            ],
        Checkbox :
            [
            name: 'elemF', text: 'F', onTrigger: 'return',
            bubbleHelp:
                ''
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 0, margin:1
            ],
        Button :
            [
            name: 'experimental', text: 'Enter/Edit Experimental Data', 
            extendH: 0,
            bubbleHelp:
                'Open dialog to enter the data\n'
                'for the free and bound ligand.'
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1],

    Hbox :
        [
        extendH: 1,
        Option :
            [
            name: 'opt', title: 'Geometry Optimization:', 
            text: GEOM_OPTS, type: 'int', minWidth: 11, extendH: 1,
            bubbleHelp:
            'Geometry optimization will often improve chances\n'
            'of convergence:\n'
            ' * none:  no optimization step is performed.\n'
            ' * H only:  all proton positions in the complex are\n'
            '     quantum mechanically optimized.  Heavy atoms\n'
            '     remain unchanged.\n'
            ' * H and hetero:  all non-C atom positions in the complex\n'
            '     are quantum mechanically optimized. NOTE: the ligand\n'
            '     pose should be considered a new pose.\n'
            ' * All atoms:  all atom positions in the complex are\n'
            '     quantum mechanically optimized. NOTE:  the ligand\n'
            '     pose should be considered a new pose.'
            ],
        Separator : 
            [
            vertical:0, shadow:'noline', extendH: 1, margin:1
            ],
        Checkbox :
            [
            name: 'guess', text: 'Guess',
            bubbleHelp:
                'Perform Single Point calculation to\n'
                'initialize density matrix.\n'
                'Warning: may not always\n'
                'improve convergence.'
            ]
        ],

    Separator : [flushLeft:1, extendH:1, margin:1]
    ];

const EXP_HEADER = 
    [
    name: 'exppanel', 
    title: 'NMR Experimental Data',
    windowName: 'NMRExperimentalData',
    text: ['Okay', 'Cancel'],
    onTrigger: ['validate', 'return']
    ];

const EXP_BOXHDR = 
    [
    columnMajor: 1, columns: 3,
    uniformRows: 1, uniformRows: 1
    ];

const EXP_NAMELBL =
    [
    Label :
        [
        text: 'Name'
        ]
    ];

const EXP_FREELBL =
    [
    Label :
        [
        text: 'Free'
        ]
    ];

const EXP_BNDLBL =
    [
    Label :
        [
        text: 'Bound'
        ]
    ];

const EXP_BUTTONCELL =
    [
    Button :
        [
        name: 'name', text: 'H', extendH:1
        ]
    ];

const EXP_TEXTCELL =
    [
    Text :
        [
        name: 'name',
        len: 11, type: 'real', allowBlank: 0
        ]
    ];

//  Local Functions

/****************************************************************************
 *                          LoadDB
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
local function LoadDB [dbpath]

    local [dbkey, recset, ligand, status, coreopts, complex, mess] = 
        qb_LoadCoreScoreDB [dbpath, 'nmrscore'];
    if dbkey === 0 and status === [] and coreopts === [] then
        Warning mess;
        exit [];
    endif

    local nrmsopts = qb_GetEnvApp [dbkey];
    nrmsopts = tagcat [nrmsopts, tag tr NMRSCORE_OPT_DEFAULTS];
    local [free, bound] = qb_GetAnalysisData [dbkey, 'nmr', 'exp'];
    return [dbkey, recset, ligand, status, coreopts, nrmsopts, complex,
        free, bound];

endfunction

function qb_GetNMRSEnv;
function qb_SaveNMRScore;

/****************************************************************************
 *                          RunCalc
 *
 *  Run the One-to-One scoring from the MOE Window.
 *
 ****************************************************************************/
local function RunCalc [dbkey, moeindices, moeatomnames]
    local msgkey = Message [0, 'NMRScore is running ...'];
    sleep -1;    // Allow parent to close input window.

    local rowkey = first db_Entries [dbkey];
    local [recset, ligand, status, coreopts, nmrsopts, c]
        = qb_GetNMRSEnv [dbkey];

    local workdir;
    if coreopts.cwd === 1 then
        workdir = getenv 'PWD';
    else
        workdir = fabsname coreopts.workdir;
    endif

    coreopts.workdir = workdir;
    write ['Work Dir:  {}\n', workdir];  //DEBUG

    local [results, errmess] = qb_NMRScore [recset, ligand, coreopts, nmrsopts];


    if results === [] then
        if errmess === [] or errmess === '' then
            qb_SaveDivconStatus [dbkey, rowkey, "Error:  Unknown error!\n"];
            write ['NMRScore Error:  Unknown error!\n'];
        else
            qb_SaveDivconStatus [dbkey, rowkey, 
                swrite ['Error:  {}\n', errmess]];
            write ['NMRScore Error:  {}\n', errmess];
        endif
    else
write ['R:  {v}\n', results];  //DEBUG
        local indices = app first results;
write ['I:  {v}\n', indices];  //DEBUG
        if not alltrue eqE [indices, moeindices] then
            Warning twrite ['Atom indices are inconsistent:\nMOE: {v}\n'
                'Divcon: {v}\n', moeindices, indices];
        else
            local cspvalues = second tr results;
write ['C:  {v}\n', cspvalues];  //DEBUG
write ['N:  {v}\n', moeatomnames];  //DEBUG
            qb_SaveNMRScore [dbkey, rowkey, 9.99,
                tag [moeatomnames, cspvalues]];
            local sucmess = cat [ "Success\n", errmess];
            if not isnull errmess then
                sucmess = cat [sucmess, errmess, "\n"];
            endif
            qb_SaveDivconStatus [dbkey, rowkey, sucmess];

        endif
    endif

    Message [msgkey, 'NMRScore is done.'];

    return;
endfunction

/****************************************************************************
 *
 *                          SetupExpDataPanel
 *
 ****************************************************************************/
local function SetupExpDataPanel [ligatoms, indices, atomfree, atombound]

    if MOE_BATCH then return; endif
    if WindowShow ['NMRExperimentalData', 1] then return; endif

    local atomnames = get [aName ligatoms, indices];

write['Lig: {v}\nIdx: {v}\nAN: {v}\nAF: {v}\nAB: {v}\n',
aName ligatoms, indices, atomnames, atomfree, atombound];//DEBUG

    local curratom = 0;
    local buttons = EXP_NAMELBL;
    local freetexts = EXP_FREELBL;
    local boundtexts = EXP_BNDLBL;
    local fnames = [], bnames = [];
    local ith;
    for ith = 1, length indices, 1 loop
        local butname = twrite ['name{}', ith];
        local freename = twrite ['free{}', ith];
        local bndname = twrite ['bound{}', ith];

        local newbutton = tagpoke [EXP_BUTTONCELL, ['Button', 'name'], butname];
        newbutton = tagpoke [newbutton, ['Button', 'text'], atomnames(ith)];
        buttons = cat [buttons, newbutton];

        local newfreetext = tagpoke [EXP_TEXTCELL, ['Text', 'name'], freename];
        freetexts = cat [freetexts, newfreetext];

        local newbndtext = tagpoke [EXP_TEXTCELL, ['Text', 'name'], bndname];
        boundtexts = cat [boundtexts, newbndtext];

        fnames = append [fnames, freename];
        bnames = append [bnames, bndname];
    endloop

    local box = [Mbox: cat [EXP_BOXHDR, cat [buttons, freetexts, boundtexts]]];
    local expwkey = WindowCreate cat [EXP_HEADER, box];

    if length indices === length atomfree
            and length indices === length atombound then
        local prevvals = cat [tag [fnames, atomfree], tag [bnames, atombound]];
        WindowSetData [expwkey, prevvals];
    endif

    WindowShow [expwkey, 1];

    local free = [], bound = [];
    loop
        local [vals, trig] = WindowWait expwkey;
        if trig === 'exppanel' then
            if vals.exppanel === 'Cancel' then
                free = atomfree;
                bound = atombound;
                break;

            elseif vals.exppanel === 'Okay' then
                for ith = 1, length indices, 1 loop
                    freename = twrite ['free{}', ith];
                    free = append [free, tagpeek [vals, freename]];
                    bndname = twrite ['bound{}', ith];
                    bound = append [bound, tagpeek [vals, bndname]];
                endloop
                break;
            endif

        elseif 'name' === tok_keep [trig, 4] then
            local numtok = tok_drop [trig, 4];
            local atmidx = atoi numtok;
            if curratom > 0 then
                aSetLabelName [curratom, 0];
            endif

            curratom = ligatoms(indices(atmidx));
            aSetLabelName [curratom, 1];
            continue;
        endif
    endloop

    if curratom > 0 then
        aSetLabelName [curratom, 0];
    endif

    WindowDestroy expwkey;

    return [free, bound];
endfunction

/****************************************************************************
 *                          ShowLigPoses
 *
 *  Show either the ligand or all poses in the MOE Window.
 *
 ****************************************************************************/
local function ShowLigPoses [vals, ligmol, ligatoms, posemols, poseatoms]

    local errmess;
    if vals.allposes then
        if ligatoms === [] then
            return [ligatoms, posemols, poseatoms];
        endif

        if posemols === [] and qb_IsModeOneToMany [vals] then
            [posemols, errmess] = qb_GetPoses [vals];
            if posemols === [] then
                Warning errmess;
                exit [];
            endif
        endif

        oDestroy ligatoms;
        ligatoms = [];

        poseatoms = cat oAtoms app mol_Create posemols;
        oSetCollection ['QB_LIGAND', poseatoms];
        aSetNucleusLook [poseatoms, 'small-sphere'];
        aSetBondLook [poseatoms, 'cylinder'];

    else
        if poseatoms === [] then
            return [ligatoms, posemols, poseatoms];
        endif

        oDestroy poseatoms;
        poseatoms = [];

        ligatoms = cat oAtoms mol_Create ligmol;
        oSetCollection ['QB_LIGAND', ligatoms];
        aSetNucleusLook [ligatoms, 'small-sphere'];
        aSetBondLook [ligatoms, 'cylinder'];
    endif

    return [ligatoms, posemols, poseatoms];
endfunction

//  Global Functions

/****************************************************************************
 *                          qb_GetNMRSEnv
 *
 *  Get the core enviroment and application environment.
 *
 ****************************************************************************/
global function qb_GetNMRSEnv [dbkey]

    local [recset, ligand, status, coreopts, complex] = qb_GetCoreEnv [dbkey];
    local nmrsopts = qb_GetEnvApp [dbkey];
    nmrsopts = tagcat [nmrsopts, tag tr NMRSCORE_OPT_DEFAULTS];

    return [recset, ligand, status, coreopts, nmrsopts, complex];
endfunction

/****************************************************************************
 *                          qb_SaveNMRScore
 *
 *  Save just the score data in the NMRScore database.
 *
 ****************************************************************************/
global function qb_SaveNMRScore [mdbkey, rowkey, scoredata, atomdata]
    scoredata = cat [tag [NMR_NUM_FIELDS, scoredata], atomdata];
    db_Write [mdbkey, rowkey, scoredata];

endfunction

/****************************************************************************
 *
 *                          qb_NMRScoreSetupPanel
 *
 *  It is assumed that the user will not modify the receptor or ligand
 *  poses while the NMRScore panel is open.
 *
 ****************************************************************************/
global function qb_NMRScoreSetupPanel []

    static status;                     //  Shared with child tasks.
    static nmrskey;
    static cutrecmol;
    static origcomplex;
    static ligmol;
    static ligatoms;
    static posemols;
    static poseatoms;
    static elems;
    static indices;
    static atomfree;
    static atombound;

    if MOE_BATCH then return; endif
    if WindowShow ['NMRScorePanel', 1] then return; endif

    local errmess;
    origcomplex = mol_Extract Chains [];
    cutrecmol = [];
    [ligatoms, errmess] = qb_GetLigandAtoms [];
    if ligatoms === [] then
        Warning errmess;
        return;
    endif

    ligmol = mol_Extract ligatoms;
    posemols = [];
    poseatoms = [];
    atomfree = [];
    atombound = [];

    nmrskey = 0;
    status = qb_GetDefaultsStatus [];
    status = qb_SetModeStatus [status, [1,1,0]];
    local coredflts = qb_GetDefaultsCore [];
    local appdflts = tag tr NMRSCORE_OPT_DEFAULTS;
    coredflts = tagpoke [coredflts, 'scoredb', 'nmrscore.mdb'];

    elems = ELEM_TYPES | [appdflts.elemH, appdflts.elemC, appdflts.elemO, 
        appdflts.elemN, appdflts.elemF];;
    indices = qb_GetElemIndices [ligmol, elems];

    local coreopts = [], nmrsopts = [], browsetasks = [];
    local curatoms = [], curidx = [];
    local atomnames = [], indextoks = [];

//DEBUG
local num = length indices;
atomfree = rep [1.025, num];
atombound = rep [1.050, num];
//DEBUG

    local wkey = WindowCreate cat [HEADER, qb_GetCorePanel [], PANEL];
    status = qb_InitCorePanel [wkey, status, coredflts];
    WindowSetData [wkey, appdflts];
    WindowSetAttr [wkey, [
        radius: [sensitive: 0, allowBlank: 1],
        showcut: [sensitive: 0], original: [sensitive: 0],
        guess: [sensitive: 1], opt: [sensitive:1]]];
    WindowShow [wkey, 1];

    loop
        local [vals, trig] = WindowWait wkey;
        if trig === 'cut' then
            if vals.cut === 0 then
                WindowSetAttr [wkey, [radius: [sensitive: 0, allowBlank: 1],
                    showcut: [sensitive: 0]]];
            else
                WindowSetAttr [wkey, [radius: [sensitive: 1, allowBlank: 0],
                    showcut: [sensitive: 1]]];
            endif

        elseif trig === 'showcut' then
            if second task_fork [statics:'share',
                    master: 'parent'] === 'child' then
                task_prio 0;

                ViewSave 1;
                if posemols === [] and qb_IsModeOneToMany [vals] then
                    [posemols, errmess] = qb_GetPoses [vals];
                    if posemols === [] then
                        Warning errmess;
                        exit [];
                    endif
                endif

                [cutrecmol, errmess]
                    = qb_CutReceptor [posemols, vals.radius];
                if cutrecmol === [] then
                    Warning errmess;
                    exit [];
                endif

                status = qb_UpdateCharge [wkey, status, 1];

                WindowSetAttr [wkey, [showcut: [sensitive: 0],
                    original: [sensitive: 1]]];
                View [];
                exit [];
            endif

        elseif trig === 'original' then
            if second task_fork [statics:'share',
                    master: 'parent'] === 'child' then
                task_prio 0;

                if origcomplex === [] then
                    Warning 'No original complex.';
                    exit [];
                endif

                Close [force:1];
                mol_Create origcomplex;
                [ligatoms, errmess] = qb_GetLigandAtoms [];
                oSetCollection ['QB_LIGAND', ligatoms];
                aSetNucleusLook [ligatoms, 'small-sphere'];
                aSetBondLook [ligatoms, 'cylinder'];
                poseatoms = [];

                [ligatoms, posemols, poseatoms]
                    = ShowLigPoses [vals, ligmol, ligatoms,
                    posemols, poseatoms];

                status = qb_UpdateCharge [wkey, status, 1];

                WindowSetAttr [wkey, [showcut: [sensitive: 1],
                    original: [sensitive: 0]]];
                ViewLoad 1;
                View [];
                exit [];
            endif

        elseif droplast trig === 'elem' then
            elems = ELEM_TYPES | [vals.elemH, vals.elemC, vals.elemO, 
                vals.elemN, vals.elemF];
            indices = qb_GetElemIndices [ligmol, elems];


        elseif trig === 'experimental' then
            if vals.allposes then
                Warning 'Deselect the ligand option "Show all poses?"\n'
                    'before attempting to enter/edit experimental data.';
                continue;
            endif

            if second task_fork [statics:'share',
                    master: 'parent'] === 'child' then

                ViewSave 1;
                elems = ELEM_TYPES | [vals.elemH, vals.elemC, vals.elemO, 
                    vals.elemN, vals.elemF];
                indices = qb_GetElemIndices [ligmol, elems];
                if ligatoms === [] or indices === [] then
                    ViewLoad 1;
                    Warning errmess;
                    exit [];
                endif

                View ligatoms;
                [atomfree, atombound] = SetupExpDataPanel [ligatoms, indices,
                    atomfree, atombound];
                ViewLoad 1;
                exit [];
            endif

        elseif trig === 'allposes' then
            if not qb_IsModeOneToMany [vals] then
                WindowSetData [wkey, [allposes: 0]];
                continue;
            endif

            if second task_fork [statics:'share',
                    master: 'parent'] === 'child' then
                task_prio 0;

                [ligatoms, posemols, poseatoms]
                    = ShowLigPoses [vals, ligmol, ligatoms,
                    posemols, poseatoms];

                exit [];
            endif

       elseif trig === 'panel' then
            if vals.panel === 'Close' then 
                break;

            elseif vals.panel === 'Load' then 
                if second task_fork [statics:'share',
                        master: 'parent'] === 'child' then
                    task_prio 0;

                    local ldkey;
                    local dbpath = FilePrompt [title: 'Load Database', 
                        filter: '*.mdb', allowEmptyList: 0];
                    if not isnull dbpath then
                        [ldkey, cutrecmol, ligmol, status, coreopts,
                            nmrsopts, origcomplex, atomfree, atombound]
                            = LoadDB [dbpath];

                        Close [force:1];
                        if neL [cutrecmol, []] then
                            mol_Create cutrecmol;
                            ligatoms = cat oAtoms mol_Create ligmol;
                            oSetCollection ['QB_LIGAND', ligatoms];
                            aSetNucleusLook [ligatoms, 'small-sphere'];
                            aSetBondLook [ligatoms, 'cylinder'];
                        else
                            mol_Create origcomplex;
                            [ligatoms, errmess] = qb_GetLigandAtoms [];
                            oSetCollection ['QB_LIGAND', ligatoms];
                            aSetNucleusLook [ligatoms, 'small-sphere'];
                            aSetBondLook [ligatoms, 'cylinder'];
                        endif

                        poseatoms = [];
                        posemols = [];
                        [ligatoms, posemols, poseatoms]
                            = ShowLigPoses [nmrsopts, ligmol, ligatoms,
                            posemols, poseatoms];

                        elems = ELEM_TYPES | [nmrsopts.elemH,
                            nmrsopts.elemC, nmrsopts.elemO, 
                            nmrsopts.elemN, nmrsopts.elemF];
                        indices = qb_GetElemIndices [ligmol, elems];

                        if nmrskey > 0 then
                            db_Close nmrskey;
                        endif

                        nmrskey = ldkey;
                        dbv_Open db_Filename nmrskey;
                        status = qb_UpdateCorePanel [wkey, status, coreopts];
                        WindowSetAttr [wkey,
                            [showcut: [sensitive: nmrsopts.cut],
                            original: [sensitive: 0]]];

                        WindowSetData [wkey, nmrsopts];
                        View [];
                    endif

                exit [];
                endif

            elseif vals.panel === 'Run' then
                if vals.allposes then
                    Warning 'Deselect the ligand option "Show all poses?"\n'
                        'before attempting to run NMRScore.';
                    continue;
                endif

                if isnull atomfree or isnull atombound then
                    Warning 'Enter experimental values before runnning.';
                    continue;
                endif

                status = qb_VerifyDivcon [wkey, status, vals];
                if not status.verified then continue; endif

                if second task_fork [statics:'share',
                        prio:3, idle:0] === 'child' then

                    coreopts = qb_TagCoreVals [vals];
                    nmrsopts = tag [first tr NMRSCORE_OPT_DEFAULTS,
                        [vals.elemH, vals.elemC, vals.elemO, vals.elemN,
                        vals.elemF, vals.guess, vals.opt, vals.cut,
                        vals.radius, vals.allposes]];

                    //  Make sure atom names are unique for DB fields.
                    atomnames = get [aName ligatoms, indices];
                    indextoks = totok indices;
                    atomnames = tok_cat [indextoks, '-', atomnames];
                    if nmrskey > 0 then
                        db_Close nmrskey;
                    endif

                    nmrskey = qb_SetUpScoreDB [status, coreopts, nmrsopts, 
                        origcomplex, cat [NMR_NUM_FIELDS, atomnames],
                        'nmrscore', 0];
                    qb_SaveAnalysisData [nmrskey, 'nmr', 'exp',
                        [atomfree, atombound]];
                    RunCalc [nmrskey, indices, atomnames];
                    dbv_Open db_Filename nmrskey;
                    exit [];
                else
                    break;
                endif

            elseif vals.panel === 'Save' then
                if vals.allposes then
                    Warning 'Deselect the ligand option "Show all poses?"\n'
                        'before attempting to save NMRScore database.';
                    continue;
                endif

                if isnull atomfree or isnull atombound then
                    Warning 'Enter experimental values before saving.';
                    continue;
                endif

                status = qb_VerifyDivcon [wkey, status, vals];
                if not status.verified then continue; endif

                if second task_fork [statics:'share'] === 'child' then
                    task_prio 0;

                    coreopts = qb_TagCoreVals [vals];
                    nmrsopts = tag [first tr NMRSCORE_OPT_DEFAULTS,
                        [vals.elemH, vals.elemC, vals.elemO, vals.elemN,
                        vals.elemF, vals.guess, vals.opt, vals.cut, 
                        vals.radius, vals.allposes]];

                    //  Make sure atom names are unique for DB fields.
                    atomnames = get [aName ligatoms, indices];
                    indextoks = totok indices;
                    atomnames = tok_cat [indextoks, '-', atomnames];
                    if nmrskey > 0 then
                        db_Close nmrskey;
                    endif

                    nmrskey = qb_SetUpScoreDB [status, coreopts, nmrsopts, 
                        origcomplex, cat [NMR_NUM_FIELDS, atomnames],
                        'nmrscore', 1];
                    qb_SaveAnalysisData [nmrskey, 'nmr', 'exp',
                        [atomfree, atombound]];
                    dbv_Open db_Filename nmrskey;
                    exit [];
                else
                    break;
                endif
            endif
        else
           [status, browsetasks] = qb_CoreHandler [wkey, trig, status, vals,
               browsetasks];
        endif
    endloop

    if nmrskey > 0 then
        db_Close nmrskey;
    endif

    task_kill browsetasks;
    WindowDestroy wkey;

endfunction

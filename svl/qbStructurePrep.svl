#svl
#if 0
 // BEGIN COPYRIGHT
 /***********************************************************************
    Copyright (c) 1998-2013 QuantumBio Inc. and/or its affiliates.
    
 This source code is the property of QuantumBio Inc. and/or its affiliates
 and is considered secret.

 This source code contains proprietary and Confidential Information, 
 including trade secrets, belonging to QuantumBio Inc. and/or its 
 affiliates.

 Use, duplication, or disclosure of this source code is strictly 
 prohibited without prior written authorization by the management of 
 QuantumBio Inc. At no time are you authorized to repurpose the source
 code for use with software other then that which it was intended.

 Please see http://www.quantumbioinc.com/ for more information.

 ***********************************************************************/
 // END COPYRIGHT
#endif   

/****************************************************************************
 *                                qbStructurePrep.svl
 *
 *  Read in a PDB, MOL2, or any other file MOE supports, add protons using
 *  Protonate3D, and finally tether-minimize all atoms in the system. Two
 *  mol2 file are produced: 
 *      p_${basefilename}.mol2  - corresponds to protonated form.
 *      mp_${basefilename}.mol2 - corresponds to minimized form.
 *
 *  Main function:
 *
 *    qbStructurePrep [target_filename, ligand_filename, [options]]
 *
 *  Example moebatch call:
 *
 *  qbmoebatch -licwait -exec "run ['qbStructurePrep.svl',['target.mol2','ligand.mol2',[]]]" -exit
 *          Run the script on target.mol2 and ligand.mol2 files in CWD.
 *          This setup will use default options.
 *
 *  qbmoebatch -licwait -exec "run ['qbStructurePrep.svl',['D_glucose.mol2',[],[enableOpt:0,enableLigFix:0]]]" -exit
 *          Run the script on D_glucose.mol2 within the CWD.
 *          This setup will only run the job on a single ligand mol2 file, and it will turn off
 *              optimization and fixing the ligand protonation during protonation.
 *
 *  qbmoebatch -licwait -exec "run ['qbStructurePrep.svl',['HYP_reduce.pdb',[],[enableOpt:0,enableLigFix:0,enableProtonate:1,protAtomList:[3],enablePreciseHOH:0]]]" -exit
 *          The script can also be used to only protonate atoms you wish to protonate.
 *              protAtomList:[3] will protonate just the 3rd atom in the file. protAtomList:[3,5] will
 *              protonate both the 3rd and the 5th atoms in the file. (and so on).
 *
 *  qbmoebatch -licwait -exec "run ['$HOME/svl/qbStructurePrep.svl',['testing.moe',[],[enableOpt:0,enableProtonate:0,enableCropOnLig:0,enableCutWat:0]]]" -exit
 *          Simply splits the complex into target and ligand.
 *
 *  qbmoebatch  -exec "run ['qbStructurePrep.svl',['1AZM_PDB.pdb',[],[enableOpt:0,enableLigFix:0,outfiletype:'pdb',enableProtonate:1,protPH:7.4]]]" -exit
 *          Read in a PDB file and protonate it freely (with no optimization and now fixing of current protonation states) at pH=7.4.
 *              Also output pdb file instead of mol2 file
 *
 *  qbmoebatch -exec "run ['qbStructurePrep.svl',['1AZM_2.pdb',[],[enableOpt:0,enableCutWat:1,wat_radius:5.0,outfiletype:'pdb',renameLigand:'LIG',printRes:['LIG',5.0]]]]" -exit
 *          Process a PDB file and disable any options for protonation and optimization. Cut waters greater then 5.0A away from ligand. The ligand will be renamed to
 *              LIG, and the list of residues within the ligand will be written to a file with the res extension.
 *
 *  qbmoebatch -exec "run ['qbStructurePrep.svl',['pre_1X8X.pdb',[],[enableOpt:0,enableCutWat:1,wat_radius:5.0,outfiletype:'pdb',enableAmberName:1,renameLigand:'LIG',printRes:['LIG',5.0]]]]" -exit
 *          Same as above, but enables the AMBER atom/residue name option in the PDB writer.
 *
 *      NOTE: -licwait is used to wait for a license to free. It will wait forever.
 *
 ****************************************************************************/

#set main 'qbPrep2Files' 

function Protonate3D;
function _Atoms;
function fwrite_TriposMOL2;
function fwrite_PDB;
function pro_Align;
function pro_Join;
function MM;
function StructurePreparation;

// QB Toolbox:
function qbSelectOnRadius;
function qbCleanDelAtoms;
function qbSelectResidueOnRadius;
function qbNearby;
function qb_TestDivCon;
function qbSelectWatOnRadius;

// statics
static wasPDB;

const CORE_DEFAULTS = [
    enableStripLP:0,        // Remove LPs from file prior doing anything to the structure.
    enableAutoPrep:0,       // Run the MOE structure preparation tool.
    enableOpt:0,            // turn on optimization
    tether_val:100,         // tethers the heavy atoms at a certain restraint.
    enableProtonate:0,      // turns on Protonate3D
    protPH:[],             // set pH in Protonate3D to default
    enablePreciseHOH:0,     // turns on precise waters in Protonate3D (can cause LONG calc if turned on).
    enableLigFix:1,         // but fixes the ligand protonation
    enableCutWat:0,         // it will not remove all waters beyond ligand
    wat_radius:4.5,         // using this distance from ligand
    enableCropOnLig:0,      // turns off cropping target around ligand
    qmcrop_radius:0,        // acceptable distance around ligand to leave in
    renameLigand:[]        // rename ligand based upon the name of the name provided (e.g. LIG whatever)
];

const DEFAULTS = cat [CORE_DEFAULTS, [
    enableWatPart:0,        // partitions waters into each of the atoms/residues and reprotonates.
    protAtomList:[],        // list of atom indices to protonate
    notProtAtomList:[],        // list of atom indices not to protonate
    printAtms:[],           // ['LIG',5.0] print the atoms within 5A of residue LIG.
    printRes:[],           // ['LIG',5.0] print the atoms within 5A of residue LIG.
    residueRenumber:0,      // renumbers the residues (not implemented)
    hamiltonian:'pm6',     // the Hamiltonian to be used downstream
    qmApplication:[],       // the particular QM application to be used downstream
    quitonerror:0,          // by default, the run will continue even on error (not good if used in shell script)
    outfiletype:'mol2',     // output file type supported by script (can be either mol2 or PDB).
    enableAmberName:0,         // output amber names in PDB files.
    wasPDB:0,               // option set to 1 when pdb file is read in.
    prtElementList:[]       // [['H','C'],'L'] elements to print to atom list file (such as for NMR or belly)
    					// L = ligand, T = target/receptor, [] or other = all
]];

const HYDRATE_DEFAULTS = [
    calctype:1,
    distance:2.5,
    enableOpt:1,
    enablePocket:0,
    onlySolvExposed:1
];

local function writeElementList [outpat,chains,opt]
    local atmlist = [];
    local reslist = [];
    local allObjects;
    local objectMask;
    local tmpObjectMask;
    local Batoms;
    if not isnull opt.prtElementList then
    	allObjects = cat cAtoms chains;
        if second opt.prtElementList == 'L' then
            objectMask = m_join [allObjects, _Atoms '$$ligand'];
        elseif second opt.prtElementList == 'T' then
            objectMask = m_join [allObjects, _Atoms '$$receptor'];
        else
            objectMask = m_id allObjects;
        endif
	    atmlist = sort cat indicesof[first opt.prtElementList, mput [aElement allObjects,objectMask==0,0] ];
    elseif not isnull opt.printAtms then
        allObjects = cat cResidues chains;
        Batoms = allObjects[sort cat indicesof [first opt.printAtms,cat rName allObjects]];
        atmlist = aNumber uniq qbSelectResidueOnRadius[uniq cat rAtoms Batoms,second opt.printAtms,chains];
    elseif not isnull opt.printRes then
        allObjects = cat cResidues chains;
        Batoms = allObjects[sort cat indicesof [first opt.printRes,cat rName allObjects]];
        reslist = uniq rUID aResidue uniq qbSelectResidueOnRadius[uniq cat rAtoms Batoms,second opt.printRes,chains];
    endif
    
    local fileHDL;
    if not isnull atmlist then
        fileHDL = fopenw twrite ['{}.atms',fbase ftail outpat];
        local atmID;
        for atmID in atmlist loop
            fwrite [fileHDL,'    ATOM {}\n',atmID];
        endloop
        fclose fileHDL;
    endif    

    if not isnull reslist then
        fileHDL = fopenw twrite ['{}.res',fbase ftail outpat];
        local resID;
        for resID in reslist loop
            fwrite [fileHDL,'    RESIDUE {}\n',resID];
        endloop
        fclose fileHDL;
    endif    

endfunction

local function writeMol2 [outpat,chains,opt]

    if isnull chains then
        return;
    endif

    pot_SetCharges [];
    
    cSetTag [chains, cTag first chains];
//    cSetName [chains, cName first chains];
//    chains = pro_Join[chains];
    if opt.outfiletype === 'pdb' then
        write ['outfile: {}\n', twrite ['{}.pdb',outpat]];
        local outPDBopt = [];
        if wasPDB then outPDBopt.install_cryst = 1; endif;
        if opt.enableAmberName then outPDBopt.amber = 1; endif;
        fwrite_PDB [twrite ['{}.pdb',outpat],chains,outPDBopt];
    else
        write ['outfile: {}\n', twrite ['{}.mol2',outpat]];
        fwrite_TriposMOL2 [twrite ['{}.mol2',outpat],chains];
    endif
    writeElementList [outpat,chains,opt];
    
endfunction

local function qbWriteElementList [targ_patt,opt]
    opt = tagcat[opt, DEFAULTS];
    local srcfilelist_targ = flist [cd [], targ_patt];
    local fname_targ, targ_chains = [], lig_chains = [];
    for fname_targ in srcfilelist_targ loop
        oDestroy Chains [];
        write ['\nReading ... {}\n', fname_targ];
        targ_chains = ReadAuto [fname_targ,[multi_model:1]];
        local tmpChainTag = first cName targ_chains;
        writeElementList[twrite ['{}_rec.atms',tmpChainTag],targ_chains,opt];
    endloop
endfunction
    
local function qbVennStructures [targ_patt, opt, ligand_mdb]

    opt = tagcat[opt, DEFAULTS];

    local srcfilelist_targ = flist [cd [], targ_patt];
    local fname_targ, targ_chains = [], lig_chains = [];
    local tmpChainTag;

    // read in the targets
    for fname_targ in srcfilelist_targ loop
        write ['\nReading ... {}\n', fname_targ];
        local tmpRecChains = ReadAuto [fname_targ,[multi_model:1]];
        targ_chains = append [targ_chains,diff[tmpRecChains,join[tmpRecChains,uniq aChain _Atoms '$$ligand']]];
        lig_chains = append [lig_chains,join[tmpRecChains,uniq aChain _Atoms '$$ligand']];
    endloop
    
// process the mdb file if its provided
    if not isnull ligand_mdb then
        local mdb = db_Open ligand_mdb;
        local mfield = db_RequireFieldType [mdb, 'molecule'];
        local entCnt = 0;
        local ent = 0;
        while (ent = db_NextEntry [mdb, ent]) loop
            entCnt = entCnt + 1;
            local mol = first db_ReadFields [mdb, ent, mfield];
            local tmp_chains = mol_Create mol;
            cSetName [tmp_chains, twrite ['{}_{}',mol(1)(MOL_NAME),entCnt]];
            pot_SetCharges [];
            lig_chains = append[lig_chains,tmp_chains];
        endloop
    endif

    targ_chains = cat targ_chains;
    lig_chains = cat lig_chains;
    
    oSetCollection['Receptor',cat targ_chains];
    View[];
    write ['\nnChains= {}\n', nChains[] ];
    
    pro_Align [Chains[],[superpose:1,enable_structural:0]];
    if length targ_chains == 1 then
        rSetPos[cResidues targ_chains,cAlignmentPositions targ_chains];
    endif
// return;
    if opt.enableCropOnLig then
        local vennAtms = qbSelectOnRadius [cat cAtoms lig_chains, opt.qmcrop_radius];
        vennAtms = diff [vennAtms, cat cAtoms lig_chains];
        local all_rObject = cat cResidues targ_chains;
        aSetSelected [Atoms[],0];
        aSetSelected [rAtoms all_rObject [x_diff [cat cAlignmentPositions targ_chains,uniq sort cat rPos aResidue vennAtms]],1];
        qbCleanDelAtoms cat rAtoms all_rObject [x_diff [cat cAlignmentPositions targ_chains,uniq sort cat rPos aResidue vennAtms]];
    endif

    if opt.enableCutWat then
    // get the solvent atoms that are far from the ligand
        qbCleanDelAtoms qbSelectWatOnRadius [_Atoms '$$ligand',opt.wat_radius,'invert'];
    endif

    local tmpChains;
//    for tmpChainTag in cTag targ_chains loop
//        local tmpChains = Chains[] | cTag Chains [] == tmpChainTag;
    for tmpChainTag in cName targ_chains loop
        tmpChains = Chains[] | cName Chains [] == tmpChainTag;   
        writeMol2[twrite ['{}_rec',tmpChainTag],join [tmpChains,targ_chains],opt];
    endloop
    for tmpChainTag in cName lig_chains loop
        tmpChains = Chains[] | cName Chains [] == tmpChainTag;   
        writeMol2[twrite ['{}_lig',tmpChainTag],join [tmpChains,lig_chains],opt];
    endloop

endfunction

global function qbTetherMMMin [weight,weightedAtoms]
//    pot_Load ['$MOE/lib/mmff94x.ff'];    // switch to OPLS-AA as this will do a better job.

	pot_SetCharges [];

    pot_Setup
        [
        strEnable:1, angEnable:1, stbEnable:1, oopEnable:1, torEnable:1,
        vdwEnable:1, eleEnable:1, solEnable:1, resEnable:1, strWeight:1, 
        angWeight:1, stbWeight:1, oopWeight:1, torWeight:1, vdwWeight:1, 
        eleWeight:1, solWeight:1, cutoffEnable:1, cutoffOn:8, cutoffOff:10, 
        angForm:0, eleDist:0, vdwScale14:0.5, vdwBuffer1:0, vdwBuffer2:0, 
        eleScale14:0.5, eleDielectric:1, eleBuffer:0, solDielectric:80, 
        solDielectricOffset:0, state0:1, state1:0, state2:1, threadCount:0
        ];
    
    pot_Info [];

    local atoms = Atoms [];
    local m = aMMType atoms == '??';
    if anytrue m then
	    write ['\nWARNING:  There are unparameterized atoms in the system.\n\n'];
    endif
    local moveMask;
    if isnull weightedAtoms then
        moveMask = aAtomicNumber atoms <= 1;
    else
        moveMask = m_diff[Atoms[],weightedAtoms];
    endif
    
    local tetherWeight = rep [weight, length atoms];
 //   (tetherWeight | aAtomicNumber atoms <= 1) = 0;
    (tetherWeight | moveMask) = 0;
    
    if weight > 0 then
        MM [    tetherWeight:    tetherWeight    ];
    else
        MM[];
    endif
    
endfunction

local function qbReparentSolvent []
    local solvChains = uniq aChain _Atoms ['$$solvent'];
    oDestroy [cat cAtoms solvChains | aElement cat cAtoms solvChains == 'H'];   // destroys all protons on oxygens
    local solvChain, oxAtm;
    for solvChain in solvChains loop
        local origResidues = cat cResidues solvChain;
        for oxAtm in cat cAtoms solvChain loop
            local newResidue = oCreate solvChain;
            rSetName[newResidue,'HOH'];
            oReparent[oxAtm, newResidue];
        endloop
        oDestroy origResidues;
    endloop
    local atomsToProtonate = cat cAtoms solvChains;
    Protonate3D [atomsToProtonate,atomsToProtonate,atomsToProtonate,[],[],[]];
endfunction

// function to pull a ligand out of a complex and give it its own chain (return chain)
local function qbReparentLigand[inAtoms]
    local ligandResidue = uniq aResidue inAtoms;
    local newChain = oCreate [0];
    cSetName [newChain,cName rChain first ligandResidue];
    cSetTag [newChain, cTag rChain first ligandResidue];
    oReparent[ligandResidue,newChain];
    return newChain;
endfunction

global function qbPrepareSystem [opt]

    opt = tagcat[opt, DEFAULTS];
    
    local atomsToProtonate;
    if not isnull opt.protAtomList then     // needs to be set here because atom numbers can change!
        atomsToProtonate = (Atoms[])[indexof[opt.protAtomList,aNumber Atoms[]]];
    endif
    local atomsNotToProtonate;
    if not isnull opt.notProtAtomList then  // needs to be set here because atom numbers can change!
        atomsNotToProtonate = (Atoms[])[indexof[opt.notProtAtomList,aNumber Atoms[]]];
    endif
    
    write ['Running Options: {}\n', opt];
    
    if opt.enableStripLP then
        qbCleanDelAtoms cat [Atoms [] | aElement Atoms [] == 'LP'];
    endif
    
    if opt.enableAutoPrep then
        StructurePreparation[disableTypes : ['Termini'],batch_protonate3d:0];
    endif

    local ligandAtoms = cat _Atoms '$$ligand';
    local targetAtoms = cat diff [Atoms[], ligandAtoms];

    if isnull targetAtoms or isnull ligandAtoms then
        opt.enableCropOnLig = 0;
        opt.enableCutWat = 0;
    endif

    if targetAtoms === ligandAtoms then
        opt.enableCropOnLig = 0;
        opt.enableCutWat = 0;
    endif
    
    if opt.enableWatPart then
        qbReparentSolvent[];
    endif
    
    if opt.enableCropOnLig then
        qbCleanDelAtoms cat diff [Atoms[],qbSelectResidueOnRadius [cat _Atoms '$$ligand', opt.qmcrop_radius]];
    endif
        
    if opt.enableCutWat then
    // get the solvent atoms that are far from the ligand
        qbCleanDelAtoms qbSelectWatOnRadius [_Atoms '$$ligand',opt.wat_radius,'invert'];
    endif
    
    if opt.enableProtonate then
        local prepTypes = StructurePreparation [cmd:'_types'];
        StructurePreparation [disableTypes : diff [prepTypes, ['HName','AName','HCount']], batch_protonate3d:0];

        local preciseWaters = [];
        if opt.enablePreciseHOH then
            preciseWaters = _Atoms '$$solvent';
        endif

        if not isnull opt.protAtomList then
            atomsToProtonate = join [Atoms[], atomsToProtonate];
        else
            atomsToProtonate = Atoms[];
        endif
        atomsToProtonate = diff [atomsToProtonate, atomsNotToProtonate];
        
        local protOptions = [];
        if not isnull opt.protPH then
            protOptions=[pH:opt.protPH];
        endif
        if opt.enableLigFix then
            Protonate3D [atomsToProtonate,atomsToProtonate,atomsToProtonate,_Atoms '$$ligand',preciseWaters,protOptions];
        else
            Protonate3D [atomsToProtonate,atomsToProtonate,atomsToProtonate,[],preciseWaters,protOptions];
        endif
        StructurePreparation [disableTypes : diff [prepTypes, ['HName','AName']], batch_protonate3d:0];
    endif
    
    if opt.enableOpt then
        qbTetherMMMin [opt.tether_val];
    endif
        
    if not isnull opt.renameLigand then
        write ['Number of Residues Renamed: {}\n',  length uniq cat cat [aResidue _Atoms '$$ligand']];
        rSetName [aResidue uniq _Atoms '$$ligand',opt.renameLigand];
    endif
    
    if not isnull opt.hamiltonian and not isnull opt.qmApplication then
        local testErrs=qb_TestDivCon [twrite ['{} + {}',cName first aChain cat diff [Atoms[], _Atoms '$$ligand'], cName first aChain cat _Atoms '$$ligand'],Atoms[],opt.qmApplication,opt.hamiltonian];
        if first testErrs == 0 then
            write ['WARNING: DivCon Test Prep Failed! Reported:\n'];
            write ['  {}',second testErrs];
            if opt.quitonerror then
                write [' Output Aborted\n'];
                return first testErrs;
            else
                write [' WARNING: output structure files should not be used in DivCon calculation!\n'];
            endif
        endif
    endif
    
endfunction

global function qbPrepareSystemPanel[]
	local wkey = WindowCreate [
	    name: 'shell',
	    title: 'Prepare System',
	    text: ['Run', 'Cancel'],
	    onTrigger: ['return', 'exit'],
	    bubbleHelp: [
		'Hydrate charged atoms.',
		'Exit without hydrating atoms.'
	    ],
	    
	    Checkbox: [
	        name: 'enableStripLP',
	        text: 'Remove Lone Pairs',
	        flushLeft:1,
	        bubbleHelp: [
		    'Remove LPs from file prior doing anything to the structure.'
	        ]],

	    Checkbox: [
	        name: 'enableAutoPrep',
	        text: 'Run MOE Preparation',
	        flushLeft:1,
	        bubbleHelp: [
		    'Run the MOE structure preparation tool.'
	        ]],

	    Checkbox: [
	        name: 'enableOpt',
	        text: 'Optimize Structure',
	        flushLeft:1,
	        bubbleHelp: [
		    'Optimize structure'
	        ]],

	    Text: [
		    name: 'tether_val',
		    type: 'real',
		    title: 'Tether:',
	        bubbleHelp: [
		    'Tether the heavy atoms at a certain restraint.'
	        ]
	        ],

	    Checkbox: [
	        name: 'enableProtonate',
	        text: 'Run Protonate3D',
	        flushLeft:1,
	        bubbleHelp: [
		    'Automatically protonate the structure using Protonate3D.'
	        ]],

	    Text: [
		    name: 'protPH',
		    type: 'real',
		    title: 'pH:',
	        bubbleHelp: [
		    'Set the pH value for Protonate3D.'
	        ]
	        ],

	    Checkbox: [
	        name: 'enablePreciseHOH',
	        text: 'Precise HOH',
	        flushLeft:1,
	        bubbleHelp: [
		    'Turns on precise waters in Protonate3D (can cause LONG calc if turned on).'
	        ]],

	    Checkbox: [
	        name: 'enableLigFix',
	        text: 'Keep Ligand Protonation',
	        flushLeft:1,
	        bubbleHelp: [
		    'Maintain the ligand protonation as originally provided.'
	        ]],

	    Checkbox: [
	        name: 'enableCutWat',
	        text: 'Remove Distant Waters',
	        flushLeft:1,
	        bubbleHelp: [
		    'Remove waters beyond a provided distance from the ligand.'
	        ]],

	    Text: [
		    name: 'wat_radius',
		    type: 'real',
		    title: 'Radius:',
	        bubbleHelp: [
		    'Enter a value in A for which distant waters will be removed.'
	        ]
	        ],

	    Checkbox: [
	        name: 'enableCropOnLig',
	        text: 'Crop Active Site',
	        flushLeft:1,
	        bubbleHelp: [
		    'Crop the target around the ligand based on a provided radius.'
	        ]],

	    Text: [
		    name: 'qmcrop_radius',
		    type: 'real',
		    title: 'Radius:',
	        bubbleHelp: [
		    'Crop the target based on this radius.'
	        ]
	        ],
	        
	    Text: [
		    name: 'renameLigand',
		    type: 'char',
		    title: 'Rename Ligand:',
	        bubbleHelp: [
		    'Rename the ligand based on a new 3-letter code.'
	        ]
	        ]	        
	];

	WindowShow wkey;
	WindowSetData[wkey,CORE_DEFAULTS];

    local [values, trigger] = WindowWait wkey;
	WindowDestroy wkey;

	qbPrepareSystem[values];
endfunction


global function qbPrep2Files [fname_targ, fname_lig, opt]     // x is the function argument
    opt = tagcat[opt, DEFAULTS];
    
    local targ_chains, lig_chains;
        
    pot_Load ['$MOE/lib/mmff94x.ff'];    // switch to OPLS-AA as this will do a better job.

    oDestroy Chains [];
    
    write ['\nReading ... {}\n', fname_targ];
    if fext fname_targ == 'pdb' or fext fname_targ == 'ent' then
        targ_chains = ReadPDB [fname_targ,[install_cryst:1]];
        wasPDB = 1;
    else
        targ_chains = ReadAuto fname_targ;
        wasPDB = 0;
    endif
    if not isnull fname_lig then
        write ['\nReading ... {}\n', fname_lig];
        lig_chains = ReadAuto fname_lig;
    else
        fname_lig = fname_targ;
        lig_chains = uniq aChain _Atoms '$$ligand';
        local tmp_targ_chains = uniq aChain _Atoms '$$receptor';
        if length join[tmp_targ_chains,lig_chains] then
            lig_chains = qbReparentLigand[_Atoms '$$ligand'];
        endif
    endif
    targ_chains = diff [Chains[],lig_chains];
    
    qbPrepareSystem [opt];
    
    targ_chains = join [targ_chains,Chains[]];
    lig_chains = join [lig_chains,Chains[]];

    writeMol2[twrite ['mp_{}',fbase ftail fname_lig],Chains[],opt];
    writeMol2[twrite ['targ_{}',fbase ftail fname_lig],targ_chains,opt];
    writeMol2[twrite ['lig_{}',fbase ftail fname_lig],lig_chains,opt];

endfunction 

global function qbProcessFileGroup [targ_patt,lig_patt,opt]

    write ['Running set ... \n'];

    local srcfilelist_targ = flist [cd [], targ_patt];
    local srcfilelist_lig = flist [cd [], lig_patt];
    
    if length srcfilelist_targ == length srcfilelist_lig then
    
        local fname_targ;
    
        local count = 0;
        for fname_targ in srcfilelist_targ loop
            count = count + 1;
            oDestroy Chains [];
            qbPrep2Files [srcfilelist_targ(count), srcfilelist_lig(count), opt];
        endloop
    endif

endfunction

// lmw - the following function will use MOE's Solvate function in order to add waters within a certain distance of charged atoms.
//      Once the waters are added they are optimized using a forcefield.
function Solvate;
local function HydrateChargedAtoms[opt,chargedAtoms]

    local solvOpt = [ mode            : 'Droplet',
            shape           : 'Sphere',
            margin          : opt.distance,
            solvent         : 'Water',
            delete          : '',
            salt            : '',
            center          : 0,
            align           : 0,
            updatePotential : 1,
            clashCutoff     : 10.00,
            wallForce       : 100.00,
            add_H           : 1,
            verbose         : 1
    ];
    local prevSolvent = _Atoms '$$solvent';
    local maxUID = max rUID Residues [];    // MOE bug where new waters ALWAS start with UID #1
    local chargedAtom;
    for chargedAtom in chargedAtoms loop
        Solvate[chargedAtom,solvOpt];
    endloop
    local newSolvent = diff [_Atoms '$$solvent',prevSolvent];
    local firstChain = first rChain uniq aResidue newSolvent;
    local tmpResidue;
    for tmpResidue in uniq aResidue newSolvent loop
        maxUID = maxUID + 1;
        rSetUID [tmpResidue,maxUID];
        local currentChain = rChain tmpResidue;
        if currentChain <> firstChain then
            oReparent [tmpResidue, firstChain];
        endif
        if not length cat oChildren currentChain then
            oDestroy currentChain;
        endif
    endloop
    write ['Starting Waters: {}\nWaters Added: {}\n',length cat [prevSolvent | aAtomicNumber prevSolvent > 1],length cat [newSolvent | aAtomicNumber newSolvent > 1]];
    if opt.enableOpt then
        qbTetherMMMin[1000,diff [Atoms[],newSolvent]];
    endif

endfunction

function pro_Mutate;
local function MutateSurfaceChargeResidues [opt,chargedAtoms]

    local chargedResidues = uniq cat aResidue chargedAtoms;
    write ['Mutating {} residues.\n', length chargedResidues];
    pro_Mutate [chargedResidues,'ALA'];
    
endfunction

local function NeutralizeSurfaceChargedAtoms [opt,chargedAtoms]

// following functions (between =========) from $MOE/lib/svl/run/builder.svl - MOE v2012.10
//      ==============
    local function aColumn akeys
        if not isflat akeys then return app aColumn akeys; endif
        return el_spValence aElement akeys;
    endfunction
    local function aPiCount atoms
        if not isflat atoms then return app aPiCount atoms; endif
        return app add dec aBondOrder atoms;
    endfunction
    local function aLightBondCount atoms
        if not isflat atoms then return app aLightBondCount atoms; endif
        return app add aIsLight aBonds atoms;
    endfunction
    local function aLightHCount atoms
        local nbr = cat aBonds atoms;
        return s_add [aIsLight nbr and aElement nbr == 'H', aBondCount atoms];
    endfunction
    local function aHeavyBondCount atoms = (
        aBondCount atoms - aLightBondCount atoms
    );
    local function HeavyFC [col, hav, npi] = select [
        (col    ) - (hav + npi),
        (col - 8) + (hav + npi),
        col < 4
    ];
    // aIsExplicitH returns 1 if an atom is expected to be in explicit hydrogens
    // mode.  This means that there are explicit hydrogens in the residue.
    local function aIsExplicitH atoms
        if not isflat atoms then return app aIsExplicitH atoms; endif
        local mask = aIsLight atoms;
        local idx = x_pack not mask;
        mask[idx] = app orE aIsLight rAtoms aResidue atoms[idx];
        return mask;
    endfunction
    local function aIsAPO akeys
        if not isflat akeys then return app aIsAPO akeys; endif
        return m_findmatch ['A*', aName akeys];
    endfunction
    // aLightBonds returns the light bonds in order of atomic number with
    // attachement points at the end.  Hydrogens are first; lone paris last.
    local function aLightBonds atoms
        local nbr = aBonds atoms;
        nbr = nbr || aIsLight nbr;
        nbr = apt get [ nbr, app x_sort aIsAPO nbr ];
        nbr = apt get [ nbr, app x_sort neg aAtomicNumber nbr ];
        return nbr;
    endfunction
    // SetCharge assigns the ionization state of atoms.  Modify the requested
    // charge so that the atom will not change rows and is reasonable.
    local function action_SetCharge [akeys, new_q]
        local idx, mask;
        local changed = [];

	    // Unit extend the input argument and then handle the special
	    // cases: replace neutral terminal light atoms with the parent
	    // key (at the end of the list).  Then retain the unique atoms.

        [akeys,new_q] = uext [akeys, new_q];	// unit extend
        new_q = maxE [-36, minE [36, new_q]];	// just in case

        if orE (mask = aIsLight akeys and not aIon akeys) then
	    akeys = cat [akeys | not mask, aBonds (akeys | mask)];
	    new_q = cat [new_q | not mask, new_q | mask];
        endif

        [akeys,new_q] = [akeys,new_q] || [m_uniq akeys];
        [akeys,new_q] = [akeys,new_q] || [aIon akeys <> new_q];

	    // Isolated lone pair atoms may get any charge at all.
	    // Other LP atoms can be neutralized always.
	    // Otherwise, remove the lone pair atoms.

        mask = (
	        aAtomicNumber akeys == 0
	    and (not aBondCount akeys or new_q == 0)
        );
        if length (idx = x_pack mask) then
	    aSetIon [akeys[idx], new_q];
	    akeys = akeys | not mask;
        endif

        [akeys,new_q] = [akeys,new_q] || [aAtomicNumber akeys > 0];

	    // Adjust the charge to the minimum or maximum permitted by the
	    // element so that it does not change rows.  We cannot make
	    // more positive charge than the elements valence electrons.
	    // For row 1 and the p block, we can only add negative charge
	    // to the extent that we have hydrogens to remove.  Transition
	    // metals are permitted more negation.

        local Z = aAtomicNumber akeys;
        local col = aColumn akeys;
        local npi = aPiCount akeys;
        local impH = aHCount akeys - aExplicitHCount akeys;
        local nH = aLightHCount akeys + impH;
        local nQ = aHeavyBondCount akeys;

        new_q = minE [ new_q, maxE [0, el_Valence aElement akeys - nQ - npi] ];
        new_q = maxE [ new_q, Z - [2,10,18,36,54,72][ELEMENT_ROW[Z]] ];

        idx = x_pack (Z <= 2 or col >= 3);
        new_q[idx] = maxE [new_q[idx], -nH[idx]];

        idx = x_pack (col < 4);
        new_q[idx] = minE [HeavyFC [col[idx], nQ[idx], npi[idx]], new_q[idx]];

        idx = x_pack (col > 4);
        new_q[idx] = maxE [HeavyFC [col[idx], nQ[idx], npi[idx]], new_q[idx]];

        local hintlp = (npi == 1) and (orE eqE [[col-new_q],[3,5]]);

        local geom = aGeometry akeys;		// fix hybridization
        geom[x_pack (geom == 'sp2' and aColumn akeys >= 3 and not npi)] = 'sp3';

	    // Perform the ionization change (and other required changes)

        [akeys,new_q,geom,hintlp] = [akeys,new_q,geom,hintlp] || [
	       new_q <> aIon akeys
	    or geom <> aGeometry akeys
	    or hintlp <> aHintLP akeys
        ];

        local expH = aIsExplicitH akeys;
        local delH = aLightBonds (akeys | geom <> aGeometry akeys);

        aSetIon      [akeys, new_q ];
        aSetHintLP   [akeys, hintlp];
        aSetGeometry [akeys, geom  ];

        oDestroy delH;
        [akeys,expH] = [akeys,expH] || [ oType akeys == 'atom' ];

        Add_H (akeys | expH);
    endfunction
//      ==============
    local startAtoms = Atoms[];
    action_SetCharge [chargedAtoms, 0];
    local addedAtoms = diff [Atoms[],startAtoms];
    write ['Atoms Added (NET): {}\n', length addedAtoms];
    if opt.enableOpt == 1 then
        qbTetherMMMin[1000,Atoms [] | aAtomicNumber Atoms [] > 1];
    endif
endfunction

function _SelectA;      // defined in $MOE/lib/menu.svl
function AtomSurfaceArea;
global function qbFixChargedAtoms[opt]
    opt = tagcat[opt, HYDRATE_DEFAULTS];
    local chargedAtoms = cat [Atoms[] | aFCharge Atoms[] <> 0];
    
    // make sure we only get the exposed charged atoms. (it would be great if we had a function that did not rely on selection)
    if opt.onlySolvExposed == 1 then
        aSetSelected [Atoms[],0];
        _SelectA 'aExposed';
        local exposedAtoms = Atoms [] | aSelected Atoms[];
        chargedAtoms = join [exposedAtoms,chargedAtoms];
    endif
    if opt.enablePocket == 0 then
        chargedAtoms = diff [chargedAtoms,uniq cat [_Atoms '$$pocket',_Atoms '$$ligand'] ];
    endif
    aSetSelected [Atoms[],0];
    aSetSelected [chargedAtoms,1];
    
    write ['Charge (before):    {}\n', add aFCharge Atoms[]];
    write ['    To Be Fixed Atoms:  {}\n', length chargedAtoms];
    write ['    Charged Atoms:      {}\n', length cat [Atoms[] | aFCharge Atoms[] <> 0]];
    if opt.calctype == 1 then
        NeutralizeSurfaceChargedAtoms [opt,chargedAtoms];
    elseif opt.calctype == 2 then
        HydrateChargedAtoms[opt,chargedAtoms];
    elseif opt.calctype == 3 then
        MutateSurfaceChargeResidues [opt,chargedAtoms];
    endif
    write ['Charge (after):     {}\n', add aFCharge Atoms[]];
    write ['    To Be Fixed Atoms:  {}\n', length chargedAtoms];
    write ['    Charged Atoms:      {}\n', length cat [Atoms[] | aFCharge Atoms[] <> 0]];
endfunction

// example: qbmoebatch -exec "run ['qbStructurePrep.svl',['mp_1B0B.mol2',[distance:3.0,enableOpt:0,enablePocket:0] ],'qbFixChargedAtomsFile']" -exit
global function qbFixChargedAtomsFile[inpdbfile,opt]
    if isnull inpdbfile then
        write ['ERROR: input file required to use this function\n'];
        return;
    endif
    opt = tagcat[opt, HYDRATE_DEFAULTS];
    oDestroy Chains[];
    ReadAuto [inpdbfile];
    qbFixChargedAtoms [opt];
    local outfile = twrite['{}-hyd_{}.{}', fbase inpdbfile, opt.distance, fext inpdbfile];
    write ['Outfile: {}\n', outfile];
    WriteAuto [outfile];
endfunction

global function qbFixChargedAtomsPanel[]
	local wkey = WindowCreate [
	    name: 'shell',
	    title: 'Fix Charged Atoms',
	    text: ['Run', 'Cancel'],
	    onTrigger: ['return', 'exit'],
	    bubbleHelp: [
		'Fix charged atoms.',
		'Exit without fixing atoms.'
	    ],
        Radio : [
	        name	: 'calctype',
	        margin	: 1,
	        columns	: 3,
	        type	: 'int',
	        flushLeft	: 1,
	        extendH	: 1,
	        onTrigger	: 'return',
	        font	: 'mediumBold',
	        text	: ['Neutralize','Hydrate','Mutate'],
	        bubbleHelp	: 
	            ['Neutralize charged atoms (add/subtract H).',
	                'Add explicit waters within certain certain distance of charged atoms.',
	                'Mutate charged residues to neutral ALA.']
	    ],

	    Checkbox: [
	        name: 'enableOpt',
	        text: 'Optimize Added Waters',
	        flushLeft:1,
	        bubbleHelp: [
		    'Optimize any added water molecules'
	        ]
	    ],

	    Text: [
		    name: 'distance',
		    type: 'real',
		    title: 'Distance:',
		    shortcut: ['2.5'],
	        bubbleHelp: [
		    'Add waters within this number of angstroms of any charged atoms.'
	        ]
        ],

	    Checkbox: [
	        name: 'enablePocket',
	        text: 'Include Pocket Atoms',
	        flushLeft:1,
	        bubbleHelp: [
		    'Include pocket atoms in the list of charged atoms.'
	        ]
	    ],
	    Checkbox: [
	        name: 'onlySolvExposed',
	        text: 'Solvent Exposed',
	        flushLeft:1,
	        bubbleHelp: [
		    'Only include atoms that are solvent exposed.'
	        ]
	    ]
	];

	WindowShow wkey;
	WindowSetData[wkey,HYDRATE_DEFAULTS];
    WindowSetAttr[wkey,
    [
        calctype:       [value:1],
        enableOpt:      [sensitive:1,text:'Optimize Protons',bubbleHelp:'Optimize all protons in the system.'],
        distance:       [sensitive:0],
        enablePocket:   [sensitive:1]
    ]];

	loop
        local [values, trigger] = WindowWait wkey;
  //        write ['DEBUG: {} | {}\n', values, trigger];

        if trigger === 'shell' then
            if values.shell == 'Cancel' then break ; endif
            if values.shell == 'Run' then
                qbFixChargedAtoms[values];
                break;
            endif
        elseif trigger === 'calctype' then
            if values.calctype == 2 then
                WindowSetAttr[wkey,
                [
                    enableOpt:      [sensitive:1,text:'Optimize Added Waters',bubbleHelp:'Optimize any added water molecules.'],
                    distance:       [sensitive:1],
                    enablePocket:   [sensitive:1]
                ]];
            elseif values.calctype == 1 then
                WindowSetAttr[wkey,
                [
                    enableOpt:      [sensitive:1,text:'Optimize Protons',bubbleHelp:'Optimize all protons in the system.'],
                    distance:       [sensitive:0],
                    enablePocket:   [sensitive:1]
                ]];
            elseif values.calctype == 3 then
                WindowSetAttr[wkey,
                [
                    enableOpt:      [sensitive:0],
                    distance:       [sensitive:0],
                    enablePocket:   [sensitive:1]
                ]];
            endif
        endif
    endloop
	WindowDestroy wkey;
endfunction

